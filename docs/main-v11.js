var _basePath = "";
function log(value) {console.log(value);}
var _appName = "Playground", _buildVersion = 11;

var int; if(!int) int = {};
int.maxValue = 2147483647;
int.minValue = -2147483648;
int.enumerate = function(from, to, selector) {
	let result = []
	for(let i=from; i < to; ++i)
		result.push(selector(i))
	return result
}
int.enumerate2 = function(from, to, step, selector) {
	let result = []
	if(to > from && step > 0) {
		for(let i=from; i < to; i += step)
			result.push(selector(i))
	} else if(to < from && step < 0) {
		for(let i=from; i > to; i += step)
			result.push(selector(i))
	} 
	return result
}
var float; if(!float) float = {};
float.float_modulo_float = function(a, b) {
	return ((a % b) + b) % b
}
String.prototype.splitByLine = function(seperator) {
	let result = [];
	let start = 0;
	while(start < this.length) {
		let end = this.indexOf(seperator, start);
		if(end == -1) {
			break;
		}
		if(end > start + 1) {
			result.push(this.substring(start, end));
		}
		start = end + 1;
	}
	return result;
}
String.prototype.splitToObject = function(selector, seperator) {
	return selector(this.split(seperator))
}
String.prototype.getUntil = function(value, start) {
	let index = this.indexOf(value, start)
	if(index != -1) return this.substring(start, index);
	if(start > 0) return this.substring(start);
					return this
}
String.prototype.getAfter = function(value, start) {
	let index = this.indexOf(value, start)
	if(index == -1) return ""
	return this.substring(index+value.length)
}
String.prototype.getBetween = function(from, to, start) {
	let index = this.indexOf(from, start)
	if(index == -1) return ""
	let startIndex = index + from.length
	let endIndex = this.indexOf(to, startIndex)
	if(endIndex == -1) return this.substring(startIndex)
	return this.substring(startIndex, endIndex)
}
String.prototype.getBetweenLast = function(from, to) {
	let index = this.lastIndexOf(from)
	let startIndex = index + from.length
	let endIndex = this.indexOf(to, startIndex)
	if(endIndex == -1) return this.substring(startIndex)
	return this.substring(startIndex, endIndex)
}
String.prototype.trimQuotes = function() {
	return this.substring(this[0] == '"' ? 1 : 0, this[this.length-1] == '"' ? this.length-1 : this.length)
}
String.prototype.trimTabs = function() {
	let lines = this.split("\n")
	if(lines.length < 2) return this
	let firstLine = lines[1]
	let tabs=0;
	while(tabs < firstLine.length-1 && firstLine[tabs] == "\t") tabs++;
	let result = ""
	for(let i=1; i<lines.length; i++) {
		let line = lines[i]
		if(line.length > tabs) {
			result += lines[i].substring(tabs) + "\n"
		}
	}
	return result
}
String.prototype.getExtension = function() {
	let dot = this.lastIndexOf(".")
	if(dot != -1) return this.substring(dot+1)
	else return ""
}
String.prototype.replaced = function(value, $with) {
	return this.replaceAll(value, $with)
}
String.prototype.capitalize = function() {
	return this.length > 0 ? this[0].toUpperCase() + this.substring(1) : this
}
String.prototype.capitalizeWords = function() {
	let result = "";
	let prevChar = " ";
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(prevChar == " " && ("a" <= it && it <= "z")) {
			result += it.toUpperCase();
		} else {
			result += it;
		}
		prevChar = it;
	}}
	return result;
}
String.prototype.onlyLetters = function() {
	let result = "";
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if("a" <= it && it <= "z" || "A" <= it && it <= "Z") {
			result += it;
		}
	}}
	return result;
}
String.prototype.onlyNumbers = function() {
	let result = "";
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if("0" <= it && it <= "9") {
			result += it;
		}
	}}
	return result;
}
String.prototype.isLetter = function() {
	return this.toLowerCase() != this.toUpperCase();
}
String.prototype.toVector2 = function() {
	let mid = this.indexOf(" ");
	return new Vector2(parseFloat(this.substring(0, mid)), parseFloat(this.substring(mid + 1)), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 15615, 15660, null, null));
}
Array.init = function() {
	Array.temporaryCopy = null;
}
Array.prototype.eachDistinct = function(selector, sortBy, $do) {
	if(this.length > 0) {
		let _subject = this
		let defaultValue;
		if(sortBy == 1) {defaultValue = 0; _subject = [...this].sort((a,b) => (selector(a) || 0) - (selector(b) || 0)); } else
		if(sortBy == 2) {defaultValue = ""; _subject = [...this].sort((a,b) => (selector(a) || "").localeCompare(selector(b) || "")); }
		let it = selector(_subject[0]) || defaultValue, i=0;
		for(let _nextIndex=1; _nextIndex<_subject.length; ++_nextIndex) { 
			let _nextIt = selector(_subject[_nextIndex]) || defaultValue;
			if(_nextIt != it) {
				let items = _subject.slice(i, _nextIndex);
				$do(it, items, i)
				it = _nextIt;
				i = _nextIndex;
			}
		}
		let items = _subject.slice(i, _subject.length);
		$do(it, items, i)
	}
}
Array.prototype.remove = function(item) {
	var index = this.indexOf(item);
	if(index > -1) this.splice(index, 1);
}
Array.prototype.remove2 = function(item, item2) {
	var index = this.indexOf(item);
	if(index > -1) this.splice(index, 1);
	var index = this.indexOf(item2);
	if(index > -1) this.splice(index, 1);
}
Array.prototype.remove3 = function(item, item2, item3) {
	var index = this.indexOf(item);
	if(index > -1) this.splice(index, 1);
	var index = this.indexOf(item2);
	if(index > -1) this.splice(index, 1);
	var index = this.indexOf(item3);
	if(index > -1) this.splice(index, 1);
}
Array.prototype.remove4 = function(item, item2, item3, item4) {
	var index = this.indexOf(item);
	if(index > -1) this.splice(index, 1);
	var index = this.indexOf(item2);
	if(index > -1) this.splice(index, 1);
	var index = this.indexOf(item3);
	if(index > -1) this.splice(index, 1);
	var index = this.indexOf(item4);
	if(index > -1) this.splice(index, 1);
}
Array.prototype.remove5 = function(item, item2, item3, item4, item5) {
	var index = this.indexOf(item);
	if(index > -1) this.splice(index, 1);
	var index = this.indexOf(item2);
	if(index > -1) this.splice(index, 1);
	var index = this.indexOf(item3);
	if(index > -1) this.splice(index, 1);
	var index = this.indexOf(item4);
	if(index > -1) this.splice(index, 1);
	var index = this.indexOf(item5);
	if(index > -1) this.splice(index, 1);
}
Array.prototype.remove6 = function(items) {
	for(let item of items) {
		var index = this.indexOf(item);
		if(index > -1) this.splice(index, 1);
	}
}
Array.prototype.removeWhere = function(condition) {
	for(let _subject=this, i=_subject.length-1; i>=0; --i) { let it = _subject[i]; {
		if(condition(it)) {
			this.splice(i, 1);
		}
	}}
}
Array.prototype.removeFirstWhere = function(condition) {
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(condition(it)) {
			this.splice(i, 1);
			return it;
		}
	}}
	return null;
}
Array.prototype.ensure = function(item) {
	if(!this.includes(item))
		this.push(item)
}
Array.prototype.ensure2 = function(items) {
	for(let it of items)
		if(!this.includes(it))
			this.push(it)
}
Array.prototype.toggle = function(item) {
	let index = this.indexOf(item)
	if(index != -1) this.splice(index, 1)
	else this.push(item)
}
Array.prototype.containsAny = function(list) {
	for(let i=0, _subject=list, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(this.includes(it)) {
			return true;
		}
	}}
	return false;
}
Array.prototype.containsNone = function(list) {
	for(let i=0, _subject=list, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(this.includes(it)) {
			return false;
		}
	}}
	return true;
}
Array.prototype.setFilteredList = function(list, condition) {
	this.length = 0;
	for(let i=0, _subject=list, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(condition(it)) {
			this.push(it);
		}
	}}
}
Array.prototype.setFilteredList2 = function(list, condition, maxCount) {
	this.length = 0;
	let count = 0;
	for(let i=0, _subject=list, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(condition(it)) {
			this.push(it);
			if(++count >= maxCount) {
				break;
			}
		}
	}}
}
Array.prototype.popWhere = function(condition) {
	for(let i=0; i<this.length; ++i) {
		let item = this[i];
		if(condition(item)) {
			this.splice(i, 1);
			return item;
		}
	}
	return null;
}
Array.prototype.setLength = function(length) {
	this.length = length
}
Array.prototype.toString = function() {
	let result = "";
	for(let item of this) {
		if(result) result += ", ";
		result += item;
	}
	return "["+result+"]"
}
Array.prototype.random = function() {
	let randomInteger = math.randomInteger2(this.length);
	return this[randomInteger];
}
Array.prototype.randomWhere = function(condition) {
	let filteredList = this.filter(condition);
	let index = math.randomInteger2(filteredList.length);
	let item = filteredList[index];
	return item;
}
Array.prototype.popRandom = function() {
	if(this.length == 0) {
		return null;
	}
	let index = math.randomInteger2(this.length);
	let item = this[index];
	this.splice(index, 1);
	return item;
}
Array.prototype.popRandomWhere = function(condition) {
	let filteredList = this.filter(condition);
	let index = math.randomInteger2(filteredList.length);
	let item = filteredList[index];
	this.remove(item);
	return item;
}
Array.prototype.next = function(currentItem) {
	var _value;
	let index = this.indexOf(currentItem);
	return this[(_value = this.length, (((index + 1) % _value) + _value) % _value)];
}

Array.prototype.next2 = function(currentItem, where) {
	var _value;
	let baseIndex = this.indexOf(currentItem);
	for(let i=0; i<this.length; ++i) {
		let item = this[(_value = this.length, (((baseIndex + i + 1) % _value) + _value) % _value)];
		if(where(item)) {
			return item;
		}
	}
	return null;
}

Array.prototype.previous = function(currentItem) {
	var _value;
	let index = this.indexOf(currentItem);
	return this[(_value = this.length, (((index - 1) % _value) + _value) % _value)];
}

Array.prototype.prev = function(currentItem) {
	var _value;
	let index = this.indexOf(currentItem);
	return (index != -1 ? this[(_value = this.length, (((index - 1) % _value) + _value) % _value)] : this[this.length - 1]);
}

Array.prototype.pickWithinRangeOrClosest = function(selector, min, max) {
	let closestDistance = Number.POSITIVE_INFINITY;
	let closestIndex = -1;
	let closestItem = null;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		let distance = 0.0;
		if(value > max) {
			distance = value - max;
		} else {
			if(value < min) {
				distance = min - value;
			} else {
				this.splice(i, 1);
				return it;
			}
		}
		if(distance < closestDistance) {
			closestDistance = distance;
			closestIndex = i;
			closestItem = it;
		}
	}}
	if(closestIndex != -1) {
		this.splice(closestIndex, 1);
	}
	return closestItem;
}
Array.prototype.moveToBack = function(item) {
	var index = this.indexOf(item);
	if(index != -1) {
		let endIndex = this.length-1;
		for(let i=index; i<endIndex; ++i) {
			this[i] = this[i+1]
		}
		this[endIndex] = item
	}
}
Array.prototype.moveToFront = function(item) {
	var index = this.indexOf(item);
	if(index != -1) {
		for(let i=index; i>0; --i) {
			this[i] = this[i-1]
		}
		this[0] = item
	}
}
Array.prototype.orderBy = function(expression) {
	return this.sort((a,b) => expression(a) - expression(b));
}
Array.prototype.orderBy2 = function(expression, thenBy) {
	return this.sort((a,b) => expression(a) - expression(b) || thenBy(a) - thenBy(b));
}
Array.prototype.orderBy3 = function(expression, thenBy) {
	return this.sort((a,b) => expression(a) - expression(b) || thenBy(a).localeCompare(thenBy(b)));
}
Array.prototype.orderBy4 = function(expression, thenBy) {
	return this.sort((a,b) => expression(a).localeCompare(expression(b)) || thenBy(a) - thenBy(b));
}
Array.prototype.orderBy5 = function(expression) {
	return this.sort((a,b) => expression(a).localeCompare(expression(b)));
}
Array.prototype.orderBy6 = function(expression, order) {
	if(order == 0/*Ascending*/) {
		return this.sort((a,b) => expression(a) - expression(b));
	} else {
		return this.sort((a,b) => expression(b) - expression(a));
	}
}
Array.prototype.orderBy7 = function(expression) {
	return this.sort((a,b) => (expression(a) - expression(b)));
}
Array.prototype.orderBy8 = function(expression, order) {
	if(order == 0/*Ascending*/) {
		return this.sort((a,b) => (expression(a) - expression(b)));
	} else {
		return this.sort((a,b) => (expression(b) - expression(a)));
	}
}
Array.prototype.orderBy9 = function(expression) {
	return this.sort((a,b) => expression(a) - expression(b));
}
Array.findStartingAtIndex = function(list, condition, startIndex) {
	for(let i=startIndex; i<list.length; ++i) {
		let it = list[i];
		if(condition(it)) {
			return it;
		}
	}
	return null;
}
Array.findLastStartingAtIndex = function(list, condition, startIndex) {
	for(let i=startIndex + 1-1; i>=0; --i) {
		let it = list[i];
		if(condition(it)) {
			return it;
		}
	}
	return null;
}
Array.prototype.findIn = function(selector) {
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value != null) {
			return value;
		}
	}}
	return null;
}
Array.prototype.has = function(condition, startIndex) {
	for(let i=startIndex; i<this.length; ++i) {
		if(condition(this[i])) {
			return true;
		}
	}
	return false;
}
Array.prototype.indexWhere = function(condition, startIndex) {
	for(let i=startIndex; i<this.length; ++i) {
		if(condition(this[i])) {
			return i;
		}
	}
	return -1;
}
Array.prototype.indexWhere2 = function(condition, startIndex) {
	for(let i=this.length - startIndex-1; i>=0; --i) {
		if(condition(this[i])) {
			return i;
		}
	}
	return -1;
}
Array.prototype.lastIndexWhere = function(condition, startIndex) {
	for(let i=this.length - startIndex-1; i>=0; --i) {
		if(condition(this[i])) {
			return i;
		}
	}
	return -1;
}
Array.prototype.except = function(item) {
	let result = [];
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(it != item) {
			result.push(it);
		}
	}}
	return result;
}
Array.prototype.total = function(selector) {
	let sum = new Vector2(0, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 29836, 29841, null, null));
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		sum.plusAssign(selector(it));
	}}
	return sum;
}
Array.prototype.total2 = function(selector) {
	let sum = 0;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		sum += selector(it);
	}}
	return sum;
}
Array.prototype.total3 = function(selector, where) {
	let sum = 0;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			sum += selector(it);
		}
	}}
	return sum;
}
Array.prototype.total4 = function(selector) {
	let sum = 0.0;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		sum += selector(it);
	}}
	return sum;
}
Array.prototype.sum = function() {
	let sum = 0;
	for(let i=0; i<this.length; i++)
		sum += this[i];
	return sum;
}
Array.prototype.average = function(selector) {
	let count = 0;
	let sum = new Vector2(0, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 29959, 29964, null, null));
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		sum.plusAssign(selector(it));
		count++;
	}}
	return sum.divide2(count);
}
Array.prototype.average2 = function(selector, where) {
	let count = 0;
	let sum = new Vector2(0, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 30132, 30137, null, null));
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			sum.plusAssign(selector(it));
			count++;
		}
	}}
	return sum.divide2(count);
}
Array.prototype.average3 = function() {
	return this.length > 0 ? this.sum() / this.length : 0
}
Array.prototype.joinToString = function(selector, separator) {
	let result = "";
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(result) {
			result += separator;
		}
		result += selector(it);
	}}
	return result;
}
Array.prototype.shuffle = function() {
	for(let i=this.length-1; i>=1; --i) {
		let j = Math.floor(math.randomFloat2(1.0) * (i + 1));
		let temp = this[i];
		this[i] = this[j];
		this[j] = temp;
	}
	return this;
}
Array.prototype.shuffled = function() {
	return [...this].shuffle();
}
Array.prototype.percentile = function(value) {
	if(this.length == 0) return 0
	if(this.length == 1) return this[0]
	if(!Array.temporaryCopy) Array.temporaryCopy = []
	const len = Array.temporaryCopy.length = this.length
	for(let i=0; i<len; ++i) Array.temporaryCopy[i] = this[i] 
	Array.temporaryCopy.sort((a,b) => a - b)
	return Array.temporaryCopy[Math.round((Array.temporaryCopy.length-1) * value / 100)]
}
Array.prototype.min = function(selector, threshold, $default) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value < resultValue) {
			resultValue = value;
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.min2 = function(selector, threshold, $default) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value < resultValue) {
			resultValue = value;
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.min3 = function(selector, threshold, $default, where) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			let value = selector(it);
			if(value < resultValue) {
				resultValue = value;
			}
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.min4 = function(selector, threshold, $default, where) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			let value = selector(it);
			if(value < resultValue) {
				resultValue = value;
			}
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.min5 = function(selector, threshold, $default) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value < resultValue) {
			resultValue = value;
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.max = function(selector, threshold, $default) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value > resultValue) {
			resultValue = value;
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.max2 = function(selector, threshold, $default) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value > resultValue) {
			resultValue = value;
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.max3 = function(selector, threshold, $default, where) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			let value = selector(it);
			if(value > resultValue) {
				resultValue = value;
			}
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.max4 = function(selector, threshold, $default, where) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			let value = selector(it);
			if(value > resultValue) {
				resultValue = value;
			}
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.max5 = function(selector, threshold, $default) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value > resultValue) {
			resultValue = value;
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.max6 = function(selector, threshold, $default, where) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			let value = selector(it);
			if(value > resultValue) {
				resultValue = value;
			}
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.maxUnique = function(selector, threshold, $default) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value > resultValue) {
			resultValue = value;
		} else {
			if(value == resultValue) {
				resultValue = threshold;
			}
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.minIndex = function(selector, startIndex, threshold) {
	let resultValue = threshold;
	let index = -1;
	for(let i=startIndex; i<this.length; ++i) {
		let value = selector(this[i]);
		if(value < resultValue) {
			resultValue = value;
			index = i;
		}
	}
	return index;
}
Array.prototype.maxIndex = function(selector, startIndex, threshold) {
	let resultValue = threshold;
	let index = -1;
	for(let i=startIndex; i<this.length; ++i) {
		let value = selector(this[i]);
		if(value > resultValue) {
			resultValue = value;
			index = i;
		}
	}
	return index;
}
Array.prototype.withMin = function(selector, threshold) {
	let resultValue = threshold;
	let resultItem = null;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value < resultValue) {
			resultValue = value;
			resultItem = it;
		}
	}}
	return (resultValue != threshold ? resultItem : null);
}
Array.prototype.withMin2 = function(selector, threshold) {
	let resultValue = threshold;
	let resultItem = null;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value < resultValue) {
			resultValue = value;
			resultItem = it;
		}
	}}
	return (resultValue != threshold ? resultItem : null);
}
Array.prototype.withMin3 = function(selector, threshold, where) {
	let resultValue = threshold;
	let resultItem = null;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			let value = selector(it);
			if(value < resultValue) {
				resultValue = value;
				resultItem = it;
			}
		}
	}}
	return (resultValue != threshold ? resultItem : null);
}
Array.prototype.withMin4 = function(selector, threshold, where) {
	let resultValue = threshold;
	let resultItem = null;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			let value = selector(it);
			if(value < resultValue) {
				resultValue = value;
				resultItem = it;
			}
		}
	}}
	return (resultValue != threshold ? resultItem : null);
}
Array.prototype.withMax = function(selector, threshold) {
	let resultValue = threshold;
	let resultItem = null;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value > resultValue) {
			resultValue = value;
			resultItem = it;
		}
	}}
	return (resultValue != threshold ? resultItem : null);
}
Array.prototype.withMax2 = function(selector, threshold) {
	let resultValue = threshold;
	let resultItem = null;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value > resultValue) {
			resultValue = value;
			resultItem = it;
		}
	}}
	return (resultValue != threshold ? resultItem : null);
}
Array.prototype.withMax3 = function(selector, threshold, where) {
	let resultValue = threshold;
	let resultItem = null;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			let value = selector(it);
			if(value > resultValue) {
				resultValue = value;
				resultItem = it;
			}
		}
	}}
	return (resultValue != threshold ? resultItem : null);
}
Array.prototype.withMax4 = function(selector, threshold, where) {
	let resultValue = threshold;
	let resultItem = null;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			let value = selector(it);
			if(value > resultValue) {
				resultValue = value;
				resultItem = it;
			}
		}
	}}
	return (resultValue != threshold ? resultItem : null);
}
Array.prototype.popMax = function(selector, threshold) {
	let resultValue = threshold;
	let resultItem = null;
	let resultIndex = -1;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value > resultValue) {
			resultValue = value;
			resultItem = it;
			resultIndex = i;
		}
	}}
	if(resultIndex != -1) {
		this.splice(resultIndex, 1);
	}
	return resultItem;
}
Array.prototype.popMax2 = function(selector, threshold) {
	let resultValue = threshold;
	let resultItem = null;
	let resultIndex = -1;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value > resultValue) {
			resultValue = value;
			resultItem = it;
			resultIndex = i;
		}
	}}
	if(resultIndex != -1) {
		this.splice(resultIndex, 1);
	}
	return resultItem;
}
Array.prototype.count = function(predicate) {
	let count = 0;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(predicate(it)) {
			count++;
		}
	}}
	return count;
}
Array.prototype.countNot = function(predicate) {
	let count = 0;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(!predicate(it)) {
			count++;
		}
	}}
	return count;
}
Array.prototype.rotate = function() {
	this.splice(0, 0, this.pop());
}
Array.prototype.rotate2 = function(count) {
	for(let i=0; i<count; ++i) {
		this.splice(0, 0, this.pop());
	}
}
Array.prototype.intersectWith = function(other) {
	const a = this || []
	const b = other || []
	const result = [];
	const map = {};
	for (let i = 0, length = b.length; i < length; ++i) {
		map[b[i]] = true;
	}
	for (let i = 0, length = a.length; i < length; ++i) {
		if (a[i] in map) result.push(a[i]);
	}
	return result;
}
Map.prototype.setAndReturn = function(key, value) {
	this.set(key, value);
	return value;
}
Map.prototype.addToItem = function(key, value) {
	let item = this.get(key)
	if(item) this.set(key, item + value)
	else this.set(key, value)
}
Map.prototype.removeWhere = function(condition) {
	for(var pair of this) {
		if(condition(pair[1])) {
			this.delete(pair[0]);
		}
	}
}
function SourceCodeLocation(file, start, end, left, right) {
	this.file = file;
	this.start = start;
	this.end = end;
	this.left = left;
	this.right = right;
}
SourceCodeLocation.prototype.find = function(file, pos) {
	if(this.file && this.file == file && pos >= this.start && pos <= this.end) {
		return this;
	}
	if(this.left != null) {
		let result = this.left.find(file, pos);
		if(result != null) {
			return result;
		}
	}
	if(this.right != null) {
		let result = this.right.find(file, pos);
		if(result != null) {
			return result;
		}
	}
	return null;
}
SourceCodeLocation.prototype.find2 = function(location) {
	if(this.file == location.file && this.start == location.start && this.end == location.end) {
		return this;
	}
	if(this.left != null) {
		let result = this.left.find2(location);
		if(result != null) {
			return result;
		}
	}
	if(this.right != null) {
		let result = this.right.find2(location);
		if(result != null) {
			return result;
		}
	}
	return null;
}
SourceCodeLocation.prototype.leaf = function() {
	if(this.file) {
		return this;
	}
	if((this.right != null)) {
		let result = this.right.leaf();
		if((result != null)) {
			return result;
		}
	}
	if((this.left != null)) {
		let result = this.left.leaf();
		if((result != null)) {
			return result;
		}
	}
	return null;
}
SourceCodeLocation.prototype.clone = function() {
	let clone = new _SourceCodeLocation();
	clone.file = this.file;
	clone.start = this.start;
	clone.end = this.end;
	clone.left = this.left;
	clone.right = this.right;
	return clone;
}
function _SourceCodeLocation() {};
_SourceCodeLocation.prototype = SourceCodeLocation.prototype;
var object; if(!object) object = {};
object.stringify = function(subject, depth) {
	switch(typeof subject)
	{
		case "object":
			if(subject === null) return "null"
			let result = ""
			if(subject.constructor) result += "_type: " + subject.constructor.name
			if(depth > 0) {
				for(let name in subject) {
					let item = object.stringify(subject[name], depth-1)
					if(item != "") {
						if(result) result += ", "
						result += name + ": " + item
					}
				}
			}
			return "\{" + result + "\}"
			
		case "string":
			return "\"" + subject + "\""
			
		case "undefined":
			return "\"undefined\""
			
		case "function":
			return ""
			
		default:
			return subject.toString()
	}
}
function Player(_id, language, email, name, colorPreferences, id, index, color, darkColor, score, pointerPosition, showSettingsInLobby) {
	this._id = _id;
	this.language = language;
	this.email = email;
	this.name = name;
	this.colorPreferences = colorPreferences;
	this.id = id;
	this.index = index;
	this.color = color;
	this.darkColor = darkColor;
	this.score = score;
	this.pointerPosition = pointerPosition?.clone();
	this.touches = [];
	this.downTouches = [];
	this.enableTouch = true;
	this.textInput = "";
	this.keysCurrentlyDown = [];
	this.controller = new GameController(false, 0/*Keyboard*/);
	this.controllerKeyDownFrame = [0, 0, 0, 0, 0, 0];
	this.isReadyInLobby = false;
	this.showSettingsInLobby = showSettingsInLobby;
}
Player.prototype.tick = function() {
	graphics.drawText("Player", new Vector2(0.0, 0.0, null), new Vector2(0.0, 0.0, null), null, 1/*Center*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, 0, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/app.l", 470, 487, null, null));
}
Player.prototype.cloneBaseData = function() {
	return new Player(this._id, this.language, this.email, this.name, this.colorPreferences, this.id, this.index, null, null, 0, new Vector2(0.0, 0.0, null), false);
}
Player.prototype.toString = function() {
	return this.name || (((this.color != null) ? this.color.name : "Player "+(this.index + 1)?.toString()));
}
Player.prototype.highlightPerspectiveColor = function() {
	return (input.showPerspectiveOf == null || input.showPerspectiveOf == this ? this.color : this.darkColor);
}
Player.prototype.postprocessEvents = function() {
	let hasTouch = this.touches.some(a => a.type == 3/*Touch*/);
	for(let _subject=this.touches, i=_subject.length-1; i>=0; --i) { let it = _subject[i]; {
		switch(it.phase) {
			case 1/*Down*/: {
				it.phase = 0/*Still*/;
				it.isDown = true;
			} break;
			case 3/*Up*/: {
				if(it.type >= 3/*Touch*/ || (hasTouch && it.type != 3/*Touch*/)) {
					this.touches.splice(i, 1);
				} else {
					it.phase = 0/*Still*/;
				}
				this.downTouches.remove(it);
				it.isDown = false;
			} break;
		}
	}}
}
Player.prototype.clone = function() {
	let clone = new _Player();
	clone._id = this._id;
	clone.language = this.language;
	clone.email = this.email;
	clone.name = this.name;
	clone.colorPreferences = this.colorPreferences;
	clone.id = this.id;
	clone.index = this.index;
	clone.color = this.color;
	clone.darkColor = this.darkColor;
	clone.score = this.score;
	clone.pointerPosition = this.pointerPosition.clone();
	clone.touches = this.touches;
	clone.downTouches = this.downTouches;
	clone.enableTouch = this.enableTouch;
	clone.textInput = this.textInput;
	clone.keysCurrentlyDown = this.keysCurrentlyDown;
	clone.controller = this.controller;
	clone.controllerKeyDownFrame = this.controllerKeyDownFrame;
	clone.isReadyInLobby = this.isReadyInLobby;
	clone.showSettingsInLobby = this.showSettingsInLobby;
	return clone;
}
function _Player() {};
_Player.prototype = Player.prototype;
Player.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this._id);
	buffer.writeInt32(this.language);
	buffer.writeString(this.email);
	buffer.writeString(this.name);
	let colorPreferences = this.colorPreferences
	if(colorPreferences) {
		var index = _objectCacheIndex.get(colorPreferences);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(colorPreferences, index = _objectCache.length);
			_objectCache.push(colorPreferences);
			buffer.writeInt32(-index);
			colorPreferences._objectIndex = index;
			buffer.writeInt32(colorPreferences.length);
			for(let i=0, len=colorPreferences.length; i<len; ++i) {
				buffer.writeInt32(colorPreferences[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.id);
	buffer.writeInt32(this.index);
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let darkColor = this.darkColor
	if(darkColor) {
		var index = _objectCacheIndex.get(darkColor);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(darkColor, index = _objectCache.length);
			_objectCache.push(darkColor);
			buffer.writeInt32(-index);
			darkColor._objectIndex = index;
			darkColor.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.score);
	(this.pointerPosition || new _Vector2()).serialize_internal(buffer);
	let touches = this.touches
	if(touches) {
		var index = _objectCacheIndex.get(touches);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(touches, index = _objectCache.length);
			_objectCache.push(touches);
			buffer.writeInt32(-index);
			touches._objectIndex = index;
			buffer.writeInt32(touches.length);
			for(let i=0, len=touches.length; i<len; ++i) {
				let touches_item = touches[i]
				if(touches_item) {
					var index = _objectCacheIndex.get(touches_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(touches_item, index = _objectCache.length);
						_objectCache.push(touches_item);
						buffer.writeInt32(-index);
						touches_item._objectIndex = index;
						touches_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let downTouches = this.downTouches
	if(downTouches) {
		var index = _objectCacheIndex.get(downTouches);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(downTouches, index = _objectCache.length);
			_objectCache.push(downTouches);
			buffer.writeInt32(-index);
			downTouches._objectIndex = index;
			buffer.writeInt32(downTouches.length);
			for(let i=0, len=downTouches.length; i<len; ++i) {
				let downTouches_item = downTouches[i]
				if(downTouches_item) {
					var index = _objectCacheIndex.get(downTouches_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(downTouches_item, index = _objectCache.length);
						_objectCache.push(downTouches_item);
						buffer.writeInt32(-index);
						downTouches_item._objectIndex = index;
						downTouches_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeBool(this.enableTouch);
	buffer.writeString(this.textInput);
	let keysCurrentlyDown = this.keysCurrentlyDown
	if(keysCurrentlyDown) {
		var index = _objectCacheIndex.get(keysCurrentlyDown);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(keysCurrentlyDown, index = _objectCache.length);
			_objectCache.push(keysCurrentlyDown);
			buffer.writeInt32(-index);
			keysCurrentlyDown._objectIndex = index;
			buffer.writeInt32(keysCurrentlyDown.length);
			for(let i=0, len=keysCurrentlyDown.length; i<len; ++i) {
				buffer.writeInt32(keysCurrentlyDown[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let controller = this.controller
	if(controller) {
		var index = _objectCacheIndex.get(controller);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(controller, index = _objectCache.length);
			_objectCache.push(controller);
			buffer.writeInt32(-index);
			controller._objectIndex = index;
			controller.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let controllerKeyDownFrame = this.controllerKeyDownFrame
	if(controllerKeyDownFrame) {
		var index = _objectCacheIndex.get(controllerKeyDownFrame);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(controllerKeyDownFrame, index = _objectCache.length);
			_objectCache.push(controllerKeyDownFrame);
			buffer.writeInt32(-index);
			controllerKeyDownFrame._objectIndex = index;
			buffer.writeInt32(controllerKeyDownFrame.length);
			for(let i=0, len=controllerKeyDownFrame.length; i<len; ++i) {
				buffer.writeInt32(controllerKeyDownFrame[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeBool(this.isReadyInLobby);
	buffer.writeBool(this.showSettingsInLobby);
}
Player.prototype.deserialize_internal = function(buffer) {
	this._id = buffer.readString();
	this.language = buffer.readInt32();
	this.email = buffer.readString();
	this.name = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.colorPreferences = _objectCache[index];
	} else {
		let colorPreferences = this.colorPreferences
		if(!colorPreferences || colorPreferences._objectIndex != -index) this.colorPreferences = colorPreferences = [];
		_objectCache[-index] = colorPreferences;
		for(let i=0, len = colorPreferences.length = buffer.readInt32(); i<len; ++i) {
				colorPreferences[i] = buffer.readInt32();
		}
	}
	this.id = buffer.readInt32();
	this.index = buffer.readInt32();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.color = _objectCache[index];
	} else {
		let color = this.color
		if(!color || color._objectIndex != -index)
			this.color = color = new _Color();
		(_objectCache[-index] = color).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.darkColor = _objectCache[index];
	} else {
		let darkColor = this.darkColor
		if(!darkColor || darkColor._objectIndex != -index)
			this.darkColor = darkColor = new _Color();
		(_objectCache[-index] = darkColor).deserialize_internal(buffer);
	}
	this.score = buffer.readInt32();
	(this.pointerPosition || (this.pointerPosition = new _Vector2())).deserialize_internal(buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.touches = _objectCache[index];
	} else {
		let touches = this.touches
		if(!touches || touches._objectIndex != -index) this.touches = touches = [];
		_objectCache[-index] = touches;
		for(let i=0, len = touches.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					touches[i] = _objectCache[index];
				} else {
					let touches_item = touches[i]
					if(!touches_item || touches_item._objectIndex != -index)
						touches[i] = touches_item = new _Touch();
					(_objectCache[-index] = touches_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.downTouches = _objectCache[index];
	} else {
		let downTouches = this.downTouches
		if(!downTouches || downTouches._objectIndex != -index) this.downTouches = downTouches = [];
		_objectCache[-index] = downTouches;
		for(let i=0, len = downTouches.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					downTouches[i] = _objectCache[index];
				} else {
					let downTouches_item = downTouches[i]
					if(!downTouches_item || downTouches_item._objectIndex != -index)
						downTouches[i] = downTouches_item = new _Touch();
					(_objectCache[-index] = downTouches_item).deserialize_internal(buffer);
				}
		}
	}
	this.enableTouch = buffer.readBool();
	this.textInput = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.keysCurrentlyDown = _objectCache[index];
	} else {
		let keysCurrentlyDown = this.keysCurrentlyDown
		if(!keysCurrentlyDown || keysCurrentlyDown._objectIndex != -index) this.keysCurrentlyDown = keysCurrentlyDown = [];
		_objectCache[-index] = keysCurrentlyDown;
		for(let i=0, len = keysCurrentlyDown.length = buffer.readInt32(); i<len; ++i) {
				keysCurrentlyDown[i] = buffer.readInt32();
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.controller = _objectCache[index];
	} else {
		let controller = this.controller
		if(!controller || controller._objectIndex != -index)
			this.controller = controller = new _GameController();
		(_objectCache[-index] = controller).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.controllerKeyDownFrame = _objectCache[index];
	} else {
		let controllerKeyDownFrame = this.controllerKeyDownFrame
		if(!controllerKeyDownFrame || controllerKeyDownFrame._objectIndex != -index) this.controllerKeyDownFrame = controllerKeyDownFrame = [];
		_objectCache[-index] = controllerKeyDownFrame;
		for(let i=0, len = controllerKeyDownFrame.length = buffer.readInt32(); i<len; ++i) {
				controllerKeyDownFrame[i] = buffer.readInt32();
		}
	}
	this.isReadyInLobby = buffer.readBool();
	this.showSettingsInLobby = buffer.readBool();
}
Player.prototype.serialize_external = function(buffer) {
	buffer.writeString("_id");
	buffer.writeString(this._id);
	buffer.writeString("language");
	buffer.writeInt32(4);
	buffer.writeInt32(this.language);
	buffer.writeString("email");
	buffer.writeString(this.email);
	buffer.writeString("name");
	buffer.writeString(this.name);
	buffer.writeString("colorPreferences");
	let colorPreferences = this.colorPreferences
	let colorPreferences_startPos = buffer.reserveSize();
	if(colorPreferences) {
		var index = _objectCacheIndex.get(colorPreferences);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(colorPreferences, index = _objectCache.length);
			_objectCache.push(colorPreferences);
			buffer.writeInt32(-index);
			colorPreferences._objectIndex = index;
			buffer.writeInt32(colorPreferences.length);
			for(let i=0, len=colorPreferences.length; i<len; ++i) {
				buffer.writeInt32(colorPreferences[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(colorPreferences_startPos);
	buffer.writeString("id");
	buffer.writeInt32(4);
	buffer.writeInt32(this.id);
	buffer.writeString("index");
	buffer.writeInt32(4);
	buffer.writeInt32(this.index);
	buffer.writeString("color");
	let color_startPos = buffer.reserveSize();
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(color_startPos);
	buffer.writeString("darkColor");
	let darkColor_startPos = buffer.reserveSize();
	let darkColor = this.darkColor
	if(darkColor) {
		var index = _objectCacheIndex.get(darkColor);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(darkColor, index = _objectCache.length);
			_objectCache.push(darkColor);
			buffer.writeInt32(-index);
			darkColor._objectIndex = index;
			darkColor.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(darkColor_startPos);
	buffer.writeString("score");
	buffer.writeInt32(4);
	buffer.writeInt32(this.score);
	buffer.writeString("pointerPosition");
	let pointerPosition_startPos = buffer.reserveSize();
	(this.pointerPosition || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(pointerPosition_startPos);
	buffer.writeString("touches");
	let touches = this.touches
	let touches_startPos = buffer.reserveSize();
	if(touches) {
		var index = _objectCacheIndex.get(touches);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(touches, index = _objectCache.length);
			_objectCache.push(touches);
			buffer.writeInt32(-index);
			touches._objectIndex = index;
			buffer.writeInt32(touches.length);
			for(let i=0, len=touches.length; i<len; ++i) {
				let touches_item = touches[i]
				if(touches_item) {
					var index = _objectCacheIndex.get(touches_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(touches_item, index = _objectCache.length);
						_objectCache.push(touches_item);
						buffer.writeInt32(-index);
						touches_item._objectIndex = index;
						touches_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(touches_startPos);
	buffer.writeString("downTouches");
	let downTouches = this.downTouches
	let downTouches_startPos = buffer.reserveSize();
	if(downTouches) {
		var index = _objectCacheIndex.get(downTouches);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(downTouches, index = _objectCache.length);
			_objectCache.push(downTouches);
			buffer.writeInt32(-index);
			downTouches._objectIndex = index;
			buffer.writeInt32(downTouches.length);
			for(let i=0, len=downTouches.length; i<len; ++i) {
				let downTouches_item = downTouches[i]
				if(downTouches_item) {
					var index = _objectCacheIndex.get(downTouches_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(downTouches_item, index = _objectCache.length);
						_objectCache.push(downTouches_item);
						buffer.writeInt32(-index);
						downTouches_item._objectIndex = index;
						downTouches_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(downTouches_startPos);
	buffer.writeString("enableTouch");
	buffer.writeInt32(1);
	buffer.writeBool(this.enableTouch);
	buffer.writeString("textInput");
	buffer.writeString(this.textInput);
	buffer.writeString("keysCurrentlyDown");
	let keysCurrentlyDown = this.keysCurrentlyDown
	let keysCurrentlyDown_startPos = buffer.reserveSize();
	if(keysCurrentlyDown) {
		var index = _objectCacheIndex.get(keysCurrentlyDown);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(keysCurrentlyDown, index = _objectCache.length);
			_objectCache.push(keysCurrentlyDown);
			buffer.writeInt32(-index);
			keysCurrentlyDown._objectIndex = index;
			buffer.writeInt32(keysCurrentlyDown.length);
			for(let i=0, len=keysCurrentlyDown.length; i<len; ++i) {
				buffer.writeInt32(keysCurrentlyDown[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(keysCurrentlyDown_startPos);
	buffer.writeString("controller");
	let controller_startPos = buffer.reserveSize();
	let controller = this.controller
	if(controller) {
		var index = _objectCacheIndex.get(controller);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(controller, index = _objectCache.length);
			_objectCache.push(controller);
			buffer.writeInt32(-index);
			controller._objectIndex = index;
			controller.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(controller_startPos);
	buffer.writeString("controllerKeyDownFrame");
	let controllerKeyDownFrame = this.controllerKeyDownFrame
	let controllerKeyDownFrame_startPos = buffer.reserveSize();
	if(controllerKeyDownFrame) {
		var index = _objectCacheIndex.get(controllerKeyDownFrame);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(controllerKeyDownFrame, index = _objectCache.length);
			_objectCache.push(controllerKeyDownFrame);
			buffer.writeInt32(-index);
			controllerKeyDownFrame._objectIndex = index;
			buffer.writeInt32(controllerKeyDownFrame.length);
			for(let i=0, len=controllerKeyDownFrame.length; i<len; ++i) {
				buffer.writeInt32(controllerKeyDownFrame[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(controllerKeyDownFrame_startPos);
	buffer.writeString("isReadyInLobby");
	buffer.writeInt32(1);
	buffer.writeBool(this.isReadyInLobby);
	buffer.writeString("showSettingsInLobby");
	buffer.writeInt32(1);
	buffer.writeBool(this.showSettingsInLobby);
	buffer.writeString("");
}
Player.prototype.deserialize_external = function(buffer) {
	let _id_is_set = false, language_is_set = false, email_is_set = false, name_is_set = false, colorPreferences_is_set = false, id_is_set = false, index_is_set = false, color_is_set = false, darkColor_is_set = false, score_is_set = false, pointerPosition_is_set = false, touches_is_set = false, downTouches_is_set = false, enableTouch_is_set = false, textInput_is_set = false, keysCurrentlyDown_is_set = false, controller_is_set = false, controllerKeyDownFrame_is_set = false, isReadyInLobby_is_set = false, showSettingsInLobby_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "_id":
				this._id = buffer.readString();
				_id_is_set = true;
				break;
			case "language":
				buffer.readInt32();
				this.language = buffer.readInt32();
				language_is_set = true;
				break;
			case "email":
				this.email = buffer.readString();
				email_is_set = true;
				break;
			case "name":
				this.name = buffer.readString();
				name_is_set = true;
				break;
			case "colorPreferences":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.colorPreferences = _objectCache[index];
				} else {
					let colorPreferences = this.colorPreferences
					if(!colorPreferences || colorPreferences._objectIndex != -index) this.colorPreferences = colorPreferences = [];
					_objectCache[-index] = colorPreferences;
					for(let i=0, len = colorPreferences.length = buffer.readInt32(); i<len; ++i) {
							colorPreferences[i] = buffer.readInt32();
					}
				}
				colorPreferences_is_set = true;
				break;
			case "id":
				buffer.readInt32();
				this.id = buffer.readInt32();
				id_is_set = true;
				break;
			case "index":
				buffer.readInt32();
				this.index = buffer.readInt32();
				index_is_set = true;
				break;
			case "color":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.color = _objectCache[index];
				} else {
					let color = this.color
					if(!color || color._objectIndex != -index)
						this.color = color = new _Color();
					(_objectCache[-index] = color).deserialize_external(buffer);
				}
				color_is_set = true;
				break;
			case "darkColor":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.darkColor = _objectCache[index];
				} else {
					let darkColor = this.darkColor
					if(!darkColor || darkColor._objectIndex != -index)
						this.darkColor = darkColor = new _Color();
					(_objectCache[-index] = darkColor).deserialize_external(buffer);
				}
				darkColor_is_set = true;
				break;
			case "score":
				buffer.readInt32();
				this.score = buffer.readInt32();
				score_is_set = true;
				break;
			case "pointerPosition":
				buffer.readInt32();
				(this.pointerPosition || (this.pointerPosition = new _Vector2())).deserialize_external(buffer);
				pointerPosition_is_set = true;
				break;
			case "touches":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.touches = _objectCache[index];
				} else {
					let touches = this.touches
					if(!touches || touches._objectIndex != -index) this.touches = touches = [];
					_objectCache[-index] = touches;
					for(let i=0, len = touches.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								touches[i] = _objectCache[index];
							} else {
								let touches_item = touches[i]
								if(!touches_item || touches_item._objectIndex != -index)
									touches[i] = touches_item = new _Touch();
								(_objectCache[-index] = touches_item).deserialize_external(buffer);
							}
					}
				}
				touches_is_set = true;
				break;
			case "downTouches":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.downTouches = _objectCache[index];
				} else {
					let downTouches = this.downTouches
					if(!downTouches || downTouches._objectIndex != -index) this.downTouches = downTouches = [];
					_objectCache[-index] = downTouches;
					for(let i=0, len = downTouches.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								downTouches[i] = _objectCache[index];
							} else {
								let downTouches_item = downTouches[i]
								if(!downTouches_item || downTouches_item._objectIndex != -index)
									downTouches[i] = downTouches_item = new _Touch();
								(_objectCache[-index] = downTouches_item).deserialize_external(buffer);
							}
					}
				}
				downTouches_is_set = true;
				break;
			case "enableTouch":
				buffer.readInt32();
				this.enableTouch = buffer.readBool();
				enableTouch_is_set = true;
				break;
			case "textInput":
				this.textInput = buffer.readString();
				textInput_is_set = true;
				break;
			case "keysCurrentlyDown":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.keysCurrentlyDown = _objectCache[index];
				} else {
					let keysCurrentlyDown = this.keysCurrentlyDown
					if(!keysCurrentlyDown || keysCurrentlyDown._objectIndex != -index) this.keysCurrentlyDown = keysCurrentlyDown = [];
					_objectCache[-index] = keysCurrentlyDown;
					for(let i=0, len = keysCurrentlyDown.length = buffer.readInt32(); i<len; ++i) {
							keysCurrentlyDown[i] = buffer.readInt32();
					}
				}
				keysCurrentlyDown_is_set = true;
				break;
			case "controller":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.controller = _objectCache[index];
				} else {
					let controller = this.controller
					if(!controller || controller._objectIndex != -index)
						this.controller = controller = new _GameController();
					(_objectCache[-index] = controller).deserialize_external(buffer);
				}
				controller_is_set = true;
				break;
			case "controllerKeyDownFrame":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.controllerKeyDownFrame = _objectCache[index];
				} else {
					let controllerKeyDownFrame = this.controllerKeyDownFrame
					if(!controllerKeyDownFrame || controllerKeyDownFrame._objectIndex != -index) this.controllerKeyDownFrame = controllerKeyDownFrame = [];
					_objectCache[-index] = controllerKeyDownFrame;
					for(let i=0, len = controllerKeyDownFrame.length = buffer.readInt32(); i<len; ++i) {
							controllerKeyDownFrame[i] = buffer.readInt32();
					}
				}
				controllerKeyDownFrame_is_set = true;
				break;
			case "isReadyInLobby":
				buffer.readInt32();
				this.isReadyInLobby = buffer.readBool();
				isReadyInLobby_is_set = true;
				break;
			case "showSettingsInLobby":
				buffer.readInt32();
				this.showSettingsInLobby = buffer.readBool();
				showSettingsInLobby_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!_id_is_set) this._id = "";
				if(!language_is_set) this.language = 0/*English*/;
				if(!email_is_set) this.email = "";
				if(!name_is_set) this.name = "";
				if(!colorPreferences_is_set) this.colorPreferences = [];
				if(!id_is_set) this.id = 0;
				if(!index_is_set) this.index = 0;
				if(!color_is_set) this.color = null;
				if(!darkColor_is_set) this.darkColor = null;
				if(!score_is_set) this.score = 0;
				if(!pointerPosition_is_set) this.pointerPosition = new Vector2(0.0, 0.0, null);
				if(!touches_is_set) this.touches = [];
				if(!downTouches_is_set) this.downTouches = [];
				if(!enableTouch_is_set) this.enableTouch = true;
				if(!textInput_is_set) this.textInput = "";
				if(!keysCurrentlyDown_is_set) this.keysCurrentlyDown = [];
				if(!controller_is_set) this.controller = new GameController(false, 0/*Keyboard*/);
				if(!controllerKeyDownFrame_is_set) this.controllerKeyDownFrame = [0, 0, 0, 0, 0, 0];
				if(!isReadyInLobby_is_set) this.isReadyInLobby = false;
				if(!showSettingsInLobby_is_set) this.showSettingsInLobby = false;
				return;
		}
	}
}
function $Image(file, texture, size, frames) {
	this.file = file;
	this.texture = texture;
	this.size = size?.clone();
	this.frames = frames;
}
$Image.init = function() {
	$Image.atlas = new Texture("atlas-v1.png", new Vector2(4096, 4096, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 57, 68, null, null)), null, null);
	_constCache.push($Image.atlas);
	$Image.Background = new $Image("media/Background.png", $Image.atlas, new Vector2(2604, 1924, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 135, 146, null, null)), [new ImageFrame(2, 2, 2602, 1922, 2600, 1920)]);
	_constCache.push($Image.Background);
	$Image.TopPipe = new $Image("media/TopPipe.png", $Image.atlas, new Vector2(212, 1084, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 252, 262, null, null)), [new ImageFrame(2606, 2, 2814, 1082, 208, 1080)]);
	_constCache.push($Image.TopPipe);
	$Image.BottomPipe = new $Image("media/BottomPipe.png", $Image.atlas, new Vector2(212, 972, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 376, 385, null, null)), [new ImageFrame(2818, 2, 3026, 970, 208, 968)]);
	_constCache.push($Image.BottomPipe);
	$Image.VideoScreen = new $Image("lib/core/play/media/VideoScreen0.png", $Image.atlas, new Vector2(444, 444, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 514, 523, null, null)), [new ImageFrame(2, 1926, 442, 2256, 440, 330), new ImageFrame(2, 2260, 442, 2700, 440, 440)]);
	_constCache.push($Image.VideoScreen);
	$Image.LargeButton = new $Image("lib/core/play/media/LargeButton.png", $Image.atlas, new Vector2(427, 65, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 693, 701, null, null)), [new ImageFrame(446, 1926, 869, 1987, 423, 61)]);
	_constCache.push($Image.LargeButton);
	$Image.LargeButtonAccent = new $Image("lib/core/play/media/LargeButtonAccent1.png", $Image.atlas, new Vector2(427, 65, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 843, 851, null, null)), [new ImageFrame(1300, 1926, 1722, 1987, 422, 61), new ImageFrame(873, 1926, 1296, 1987, 423, 61)]);
	_constCache.push($Image.LargeButtonAccent);
	$Image.Button = new $Image("lib/core/play/media/Button.png", $Image.atlas, new Vector2(305, 65, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 1016, 1024, null, null)), [new ImageFrame(1726, 1926, 2027, 1987, 301, 61)]);
	_constCache.push($Image.Button);
	$Image.ButtonAccent = new $Image("lib/core/play/media/ButtonAccent1.png", $Image.atlas, new Vector2(305, 65, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 1158, 1166, null, null)), [new ImageFrame(2336, 1926, 2636, 1987, 300, 61), new ImageFrame(2031, 1926, 2332, 1987, 301, 61)]);
	_constCache.push($Image.ButtonAccent);
	$Image.Nuke = new $Image("lib/core/play/media/Nuke0.png", $Image.atlas, new Vector2(260, 260, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 1329, 1338, null, null)), [new ImageFrame(446, 1991, 702, 2247, 256, 256), new ImageFrame(706, 1991, 962, 2247, 256, 256), new ImageFrame(1226, 2260, 1482, 2516, 256, 256), new ImageFrame(1746, 2260, 2002, 2516, 256, 256), new ImageFrame(2006, 2260, 2262, 2516, 256, 256), new ImageFrame(2266, 2260, 2522, 2516, 256, 256), new ImageFrame(2526, 2260, 2782, 2516, 256, 256), new ImageFrame(2, 2704, 258, 2960, 256, 256), new ImageFrame(262, 2704, 518, 2960, 256, 256), new ImageFrame(522, 2704, 778, 2960, 256, 256), new ImageFrame(966, 1991, 1222, 2247, 256, 256), new ImageFrame(1226, 1991, 1482, 2247, 256, 256), new ImageFrame(1486, 1991, 1742, 2247, 256, 256), new ImageFrame(1746, 1991, 2002, 2247, 256, 256), new ImageFrame(2006, 1991, 2262, 2247, 256, 256), new ImageFrame(2266, 1991, 2522, 2247, 256, 256), new ImageFrame(2526, 1991, 2782, 2247, 256, 256), new ImageFrame(446, 2260, 702, 2516, 256, 256), new ImageFrame(706, 2260, 962, 2516, 256, 256), new ImageFrame(966, 2260, 1222, 2516, 256, 256), new ImageFrame(1486, 2260, 1742, 2516, 256, 256)]);
	_constCache.push($Image.Nuke);
	$Image.SmallButton = new $Image("lib/core/play/media/SmallButton.png", $Image.atlas, new Vector2(172, 45, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 2372, 2380, null, null)), [new ImageFrame(2818, 974, 2986, 1015, 168, 41)]);
	_constCache.push($Image.SmallButton);
	$Image.SmallButtonAccent = new $Image("lib/core/play/media/SmallButtonAccent1.png", $Image.atlas, new Vector2(172, 45, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 2523, 2531, null, null)), [new ImageFrame(2818, 1064, 2985, 1105, 167, 41), new ImageFrame(2818, 1019, 2986, 1060, 168, 41)]);
	_constCache.push($Image.SmallButtonAccent);
	$Image.Bird = new $Image("media/Bird01.png", $Image.atlas, new Vector2(148, 116, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 2681, 2690, null, null)), [new ImageFrame(2818, 1109, 2962, 1221, 144, 112), new ImageFrame(2818, 1225, 2962, 1337, 144, 112), new ImageFrame(2818, 1341, 2962, 1453, 144, 112)]);
	_constCache.push($Image.Bird);
	$Image.finger = new $Image("lib/core/play/media/finger0.png", $Image.atlas, new Vector2(57, 80, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 2905, 2912, null, null)), [new ImageFrame(2966, 1109, 3019, 1185, 53, 76), new ImageFrame(2966, 1225, 3019, 1301, 53, 76)]);
	_constCache.push($Image.finger);
	$Image.Next = new $Image("lib/core/play/media/Next.png", $Image.atlas, new Vector2(68, 68, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 3072, 3079, null, null)), [new ImageFrame(2818, 1457, 2882, 1521, 64, 64)]);
	_constCache.push($Image.Next);
	$Image.ThumbsUp = new $Image("lib/core/play/media/ThumbsUp.png", $Image.atlas, new Vector2(68, 68, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 3203, 3210, null, null)), [new ImageFrame(2886, 1457, 2950, 1521, 64, 64)]);
	_constCache.push($Image.ThumbsUp);
	$Image.Spark = new $Image("lib/core/play/media/Spark0.png", $Image.atlas, new Vector2(62, 62, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 3329, 3336, null, null)), [new ImageFrame(2966, 1341, 3024, 1399, 58, 58), new ImageFrame(2922, 1629, 2970, 1677, 48, 48), new ImageFrame(2870, 1681, 2908, 1719, 38, 38)]);
	_constCache.push($Image.Spark);
	$Image.Back = new $Image("lib/core/play/media/Back.png", $Image.atlas, new Vector2(52, 52, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 3540, 3547, null, null)), [new ImageFrame(2966, 1403, 3014, 1451, 48, 48)]);
	_constCache.push($Image.Back);
	$Image.cameraIcon = new $Image("lib/core/play/media/cameraIcon.png", $Image.atlas, new Vector2(52, 52, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 3675, 3682, null, null)), [new ImageFrame(2954, 1457, 3002, 1505, 48, 48)]);
	_constCache.push($Image.cameraIcon);
	$Image.Checkbox = new $Image("lib/core/play/media/Checkbox0.png", $Image.atlas, new Vector2(52, 52, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 3807, 3814, null, null)), [new ImageFrame(2818, 1525, 2866, 1573, 48, 48), new ImageFrame(2870, 1525, 2918, 1573, 48, 48)]);
	_constCache.push($Image.Checkbox);
	$Image.Help = new $Image("lib/core/play/media/Help0.png", $Image.atlas, new Vector2(52, 52, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 3975, 3982, null, null)), [new ImageFrame(2922, 1525, 2970, 1573, 48, 48), new ImageFrame(2974, 1525, 3022, 1573, 48, 48)]);
	_constCache.push($Image.Help);
	$Image.Menu = new $Image("lib/core/play/media/Menu.png", $Image.atlas, new Vector2(52, 52, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 4142, 4149, null, null)), [new ImageFrame(2818, 1577, 2866, 1625, 48, 48)]);
	_constCache.push($Image.Menu);
	$Image.microphoneIcon = new $Image("lib/core/play/media/microphoneIcon.png", $Image.atlas, new Vector2(52, 52, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 4285, 4292, null, null)), [new ImageFrame(2870, 1577, 2918, 1625, 48, 48)]);
	_constCache.push($Image.microphoneIcon);
	$Image.New = new $Image("lib/core/play/media/New.png", $Image.atlas, new Vector2(52, 52, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 4406, 4413, null, null)), [new ImageFrame(2922, 1577, 2970, 1625, 48, 48)]);
	_constCache.push($Image.New);
	$Image.Quit = new $Image("lib/core/play/media/Quit.png", $Image.atlas, new Vector2(52, 52, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 4529, 4536, null, null)), [new ImageFrame(2974, 1577, 3022, 1625, 48, 48)]);
	_constCache.push($Image.Quit);
	$Image.Save = new $Image("lib/core/play/media/Save.png", $Image.atlas, new Vector2(52, 52, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 4652, 4659, null, null)), [new ImageFrame(2818, 1629, 2866, 1677, 48, 48)]);
	_constCache.push($Image.Save);
	$Image.settingsIcon = new $Image("lib/core/play/media/settingsIcon.png", $Image.atlas, new Vector2(52, 52, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 4791, 4798, null, null)), [new ImageFrame(2870, 1629, 2918, 1677, 48, 48)]);
	_constCache.push($Image.settingsIcon);
	$Image.speakerIcon = new $Image("lib/core/play/media/speakerIcon.png", $Image.atlas, new Vector2(52, 52, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 4928, 4935, null, null)), [new ImageFrame(2974, 1629, 3022, 1677, 48, 48)]);
	_constCache.push($Image.speakerIcon);
	$Image.starParticle = new $Image("lib/core/play/media/starParticle2.png", $Image.atlas, new Vector2(52, 48, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 5068, 5075, null, null)), [new ImageFrame(2912, 1681, 2938, 1705, 26, 24), new ImageFrame(2990, 999, 3000, 1009, 10, 10), new ImageFrame(2818, 1681, 2866, 1725, 48, 44)]);
	_constCache.push($Image.starParticle);
	$Image.Tutorial = new $Image("lib/core/play/media/Tutorial.png", $Image.atlas, new Vector2(52, 52, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 5286, 5293, null, null)), [new ImageFrame(2818, 1729, 2866, 1777, 48, 48)]);
	_constCache.push($Image.Tutorial);
	$Image.Flag = [new $Image("lib/core/play/media/Flag-Language1-State0.png", $Image.atlas, new Vector2(37, 25, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 5429, 5436, null, null)), [new ImageFrame(2989, 1064, 3021, 1085, 32, 21), new ImageFrame(2966, 1189, 2998, 1210, 32, 21)]), new $Image("lib/core/play/media/Flag-Language1-State0.png", $Image.atlas, new Vector2(37, 25, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 5586, 5593, null, null)), [new ImageFrame(2990, 974, 3023, 995, 33, 21), new ImageFrame(2990, 1019, 3023, 1040, 33, 21)])];
	$Image.ResizeHandle = new $Image("lib/core/play/media/ResizeHandle.png", $Image.atlas, new Vector2(36, 36, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 5768, 5775, null, null)), [new ImageFrame(2966, 1305, 2998, 1337, 32, 32)]);
	_constCache.push($Image.ResizeHandle);
}
$Image.prototype.clone = function() {
	let clone = new _Image();
	clone.file = this.file;
	clone.texture = this.texture;
	clone.size = this.size.clone();
	clone.frames = this.frames;
	return clone;
}
function _Image() {};
_Image.prototype = $Image.prototype;
function Image_serialize_internal(buffer) {
	let _Flag = $Image.Flag
	if(_Flag) {
		var index = _objectCacheIndex.get(_Flag);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_Flag, index = _objectCache.length);
			_objectCache.push(_Flag);
			buffer.writeInt32(-index);
			_Flag._objectIndex = index;
			buffer.writeInt32(_Flag.length);
			for(let i=0, len=_Flag.length; i<len; ++i) {
				let _Flag_item = _Flag[i]
				if(_Flag_item) {
					var index = _objectCacheIndex.get(_Flag_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_Flag_item, index = _objectCache.length);
						_objectCache.push(_Flag_item);
						buffer.writeInt32(-index);
						_Flag_item._objectIndex = index;
						_Flag_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
function Image_deserialize_internal(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		$Image.Flag = _objectCache[index];
	} else {
		let _Flag = $Image.Flag
		if(!_Flag || _Flag._objectIndex != -index) $Image.Flag = _Flag = [];
		_objectCache[-index] = _Flag;
		for(let i=0, len = _Flag.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_Flag[i] = _objectCache[index];
				} else {
					let _Flag_item = _Flag[i]
					if(!_Flag_item || _Flag_item._objectIndex != -index)
						_Flag[i] = _Flag_item = new _Image();
					(_objectCache[-index] = _Flag_item).deserialize_internal(buffer);
				}
		}
	}
}
$Image.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.file);
	let texture = this.texture
	if(texture) {
		var index = _objectCacheIndex.get(texture);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(texture, index = _objectCache.length);
			_objectCache.push(texture);
			buffer.writeInt32(-index);
			texture._objectIndex = index;
			texture.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	(this.size || new _Vector2()).serialize_internal(buffer);
	let frames = this.frames
	if(frames) {
		var index = _objectCacheIndex.get(frames);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(frames, index = _objectCache.length);
			_objectCache.push(frames);
			buffer.writeInt32(-index);
			frames._objectIndex = index;
			buffer.writeInt32(frames.length);
			for(let i=0, len=frames.length; i<len; ++i) {
				(frames[i] || new _ImageFrame()).serialize_internal(buffer);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
$Image.prototype.deserialize_internal = function(buffer) {
	this.file = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.texture = _objectCache[index];
	} else {
		let texture = this.texture
		if(!texture || texture._objectIndex != -index)
			this.texture = texture = new _Texture();
		(_objectCache[-index] = texture).deserialize_internal(buffer);
	}
	(this.size || (this.size = new _Vector2())).deserialize_internal(buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.frames = _objectCache[index];
	} else {
		let frames = this.frames
		if(!frames || frames._objectIndex != -index) this.frames = frames = [];
		_objectCache[-index] = frames;
		for(let i=0, len = frames.length = buffer.readInt32(); i<len; ++i) {
				(frames[i] || (frames[i] = new _ImageFrame())).deserialize_internal(buffer);
		}
	}
}
function Image_serialize_external(buffer) {
	buffer.writeString("Flag");
	let _Flag = $Image.Flag
	let _Flag_startPos = buffer.reserveSize();
	if(_Flag) {
		var index = _objectCacheIndex.get(_Flag);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_Flag, index = _objectCache.length);
			_objectCache.push(_Flag);
			buffer.writeInt32(-index);
			_Flag._objectIndex = index;
			buffer.writeInt32(_Flag.length);
			for(let i=0, len=_Flag.length; i<len; ++i) {
				let _Flag_item = _Flag[i]
				if(_Flag_item) {
					var index = _objectCacheIndex.get(_Flag_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_Flag_item, index = _objectCache.length);
						_objectCache.push(_Flag_item);
						buffer.writeInt32(-index);
						_Flag_item._objectIndex = index;
						_Flag_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_Flag_startPos);
	buffer.writeString("");
}
function Image_deserialize_external(buffer) {
	let Flag_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "Flag":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					$Image.Flag = _objectCache[index];
				} else {
					let _Flag = $Image.Flag
					if(!_Flag || _Flag._objectIndex != -index) $Image.Flag = _Flag = [];
					_objectCache[-index] = _Flag;
					for(let i=0, len = _Flag.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_Flag[i] = _objectCache[index];
							} else {
								let _Flag_item = _Flag[i]
								if(!_Flag_item || _Flag_item._objectIndex != -index)
									_Flag[i] = _Flag_item = new _Image();
								(_objectCache[-index] = _Flag_item).deserialize_external(buffer);
							}
					}
				}
				Flag_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!Flag_is_set) $Image.Flag = [new $Image("lib/core/play/media/Flag-Language1-State0.png", $Image.atlas, new Vector2(37, 25, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 5429, 5436, null, null)), [new ImageFrame(2989, 1064, 3021, 1085, 32, 21), new ImageFrame(2966, 1189, 2998, 1210, 32, 21)]), new $Image("lib/core/play/media/Flag-Language1-State0.png", $Image.atlas, new Vector2(37, 25, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/media.l", 5586, 5593, null, null)), [new ImageFrame(2990, 974, 3023, 995, 33, 21), new ImageFrame(2990, 1019, 3023, 1040, 33, 21)])];
				return;
		}
	}
}
$Image.prototype.serialize_external = function(buffer) {
	buffer.writeString("file");
	buffer.writeString(this.file);
	buffer.writeString("texture");
	let texture_startPos = buffer.reserveSize();
	let texture = this.texture
	if(texture) {
		var index = _objectCacheIndex.get(texture);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(texture, index = _objectCache.length);
			_objectCache.push(texture);
			buffer.writeInt32(-index);
			texture._objectIndex = index;
			texture.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(texture_startPos);
	buffer.writeString("size");
	let size_startPos = buffer.reserveSize();
	(this.size || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(size_startPos);
	buffer.writeString("frames");
	let frames = this.frames
	let frames_startPos = buffer.reserveSize();
	if(frames) {
		var index = _objectCacheIndex.get(frames);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(frames, index = _objectCache.length);
			_objectCache.push(frames);
			buffer.writeInt32(-index);
			frames._objectIndex = index;
			buffer.writeInt32(frames.length);
			for(let i=0, len=frames.length; i<len; ++i) {
				(frames[i] || new _ImageFrame()).serialize_external(buffer);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(frames_startPos);
	buffer.writeString("");
}
$Image.prototype.deserialize_external = function(buffer) {
	let file_is_set = false, texture_is_set = false, size_is_set = false, frames_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "file":
				this.file = buffer.readString();
				file_is_set = true;
				break;
			case "texture":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.texture = _objectCache[index];
				} else {
					let texture = this.texture
					if(!texture || texture._objectIndex != -index)
						this.texture = texture = new _Texture();
					(_objectCache[-index] = texture).deserialize_external(buffer);
				}
				texture_is_set = true;
				break;
			case "size":
				buffer.readInt32();
				(this.size || (this.size = new _Vector2())).deserialize_external(buffer);
				size_is_set = true;
				break;
			case "frames":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.frames = _objectCache[index];
				} else {
					let frames = this.frames
					if(!frames || frames._objectIndex != -index) this.frames = frames = [];
					_objectCache[-index] = frames;
					for(let i=0, len = frames.length = buffer.readInt32(); i<len; ++i) {
							(frames[i] || (frames[i] = new _ImageFrame())).deserialize_external(buffer);
					}
				}
				frames_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!file_is_set) this.file = "";
				if(!texture_is_set) this.texture = null;
				if(!size_is_set) this.size = new Vector2(0.0, 0.0, null);
				if(!frames_is_set) this.frames = [];
				return;
		}
	}
}
function Font(name, file, offset, actualHeightFactor) {
	this.name = name;
	this.file = file;
	this.offset = offset?.clone();
	this.actualHeightFactor = actualHeightFactor;
}
Font.init = function() {
	Font.ByTheWay = new Font("ByTheWay", "ByTheWay.woff2", new Vector2(0.0, 0.0, null), .76);
	_constCache.push(Font.ByTheWay);
	Font.OpenSans = new Font("OpenSans", "OpenSans.woff2", new Vector2(0.0, 0.0, null), .76);
	_constCache.push(Font.OpenSans);
	Font.ShadowedSerif = new Font("ShadowedSerif", "ShadowedSerif.woff2", new Vector2(0.0, 0.0, null), .76);
	_constCache.push(Font.ShadowedSerif);
}
Font.prototype.open = async function() {
	if(!window._fontCache) _fontCache = {}
	let font = _fontCache[this.file]
	if(!font) {
		let font = new FontFace(this.name, "url("+Platform.getAbsoluteUrl(this.file)+")");
		await font.load();
		document.fonts.add(font);
		_fontCache[this.file] = font;
		setTimeout(() => this.calculateOffset(), 0)
	}
	this.calculateOffset()
	return this
}
Font.prototype.calculateOffset = function() {
	const fontsize = 64.0
	const margin = 32.0
	const canvas = document.createElement("canvas");
	const context=canvas.getContext("2d");
	const w = fontsize*2+margin, h = fontsize*2+margin;
	canvas.height = h;
	canvas.width = w;
	context.textBaseline="top";
	context.font=fontsize+"px "+this.name;
	context.fillStyle="red";
	context.fillText("M", margin, margin);
	let pixels = context.getImageData(0,0,w,h).data;
	
	let minY = 0
	findMinY:
	for(var y=0;y<h;y++) {
		for(var x=0;x<w;x++) {
			if(pixels[(y*w+x)*4+3] > 0) {
				minY = y-margin; break findMinY;
			}
		}
	}
	
	let minX = 0
	findMinX:
	for(var x=0;x<w;x++) {
		for(var y=0;y<h;y++) {
			if(pixels[(y*w+x)*4+3] > 0) {
				minX = x-margin; break findMinX;
			}
		}
	}
	this.offset = new Vector2(minX/fontsize, minY/(fontsize*this.actualHeightFactor))
}
Font.prototype.clone = function() {
	let clone = new _Font();
	clone.name = this.name;
	clone.file = this.file;
	clone.offset = this.offset.clone();
	clone.actualHeightFactor = this.actualHeightFactor;
	return clone;
}
function _Font() {};
_Font.prototype = Font.prototype;
function Font_serialize_internal(buffer) {
}
function Font_deserialize_internal(buffer) {
}
Font.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.name);
	buffer.writeString(this.file);
	(this.offset || new _Vector2()).serialize_internal(buffer);
	buffer.writeFloat64(this.actualHeightFactor);
}
Font.prototype.deserialize_internal = function(buffer) {
	this.name = buffer.readString();
	this.file = buffer.readString();
	(this.offset || (this.offset = new _Vector2())).deserialize_internal(buffer);
	this.actualHeightFactor = buffer.readFloat64();
}
function Font_serialize_external(buffer) {
	buffer.writeString("");
}
function Font_deserialize_external(buffer) {
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				return;
		}
	}
}
Font.prototype.serialize_external = function(buffer) {
	buffer.writeString("name");
	buffer.writeString(this.name);
	buffer.writeString("file");
	buffer.writeString(this.file);
	buffer.writeString("offset");
	let offset_startPos = buffer.reserveSize();
	(this.offset || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(offset_startPos);
	buffer.writeString("actualHeightFactor");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.actualHeightFactor);
	buffer.writeString("");
}
Font.prototype.deserialize_external = function(buffer) {
	let name_is_set = false, file_is_set = false, offset_is_set = false, actualHeightFactor_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "name":
				this.name = buffer.readString();
				name_is_set = true;
				break;
			case "file":
				this.file = buffer.readString();
				file_is_set = true;
				break;
			case "offset":
				buffer.readInt32();
				(this.offset || (this.offset = new _Vector2())).deserialize_external(buffer);
				offset_is_set = true;
				break;
			case "actualHeightFactor":
				buffer.readInt32();
				this.actualHeightFactor = buffer.readFloat64();
				actualHeightFactor_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!name_is_set) this.name = "";
				if(!file_is_set) this.file = "";
				if(!offset_is_set) this.offset = new Vector2(0.0, 0.0, null);
				if(!actualHeightFactor_is_set) this.actualHeightFactor = .76;
				return;
		}
	}
}
var Platform; if(!Platform) Platform = {};
Platform.init = function() {
	Platform.userCount = 4;
	Platform.supportedUserCount = new Range(2, 4);
	Platform.showDebugInfo = false;
	Platform.isLocal = false;
	Platform.intervalMode = 0/*JavaScriptInterval*/;
	Platform.os = 0/*Windows*/;
	Platform.isMobile = false;
	Platform.isBrowser = false;
	Platform.isNode = false;
	Platform.isDebug = false;
	Platform.isSmallScreen = false;
	Platform.isStaging = false;
	Platform.engineStarted = false;
	Platform.mode = 0/*Pause*/;
	Platform.fastForward = false;
	Platform.isDrawing = false;
	Platform.waitingForInitialData = 0;
	Platform.receivedInitialData = 0;
	Platform.logSerialize = false;
	Platform.interval = null;
	Platform.nextHeartbeatTime = 0.0;
}
Platform.openMedia = function(callback) {
	Promise.all([$Image.atlas.open(),Font.ByTheWay.open(),Font.OpenSans.open(),Font.ShadowedSerif.open()]).then(() => callback())
}
Platform.protocolAndHost = function() {
	return (location.hostname && location.hostname != "127.0.0.1" ? "https://" + location.hostname : "http://127.0.0.1");
}
Platform.getAbsoluteUrl = function(relativeUrl) {
	return relativeUrl.startsWith("http") || relativeUrl.startsWith("data:") ? relativeUrl : _basePath+relativeUrl
}
Platform.setTitle = function(title) {
	document.title = title
}
Platform.setFullscreen = async function(value, forPlayer) {
	if(!Platform.isStaging && !Platform.isDebug && !Platform.fastForward && (forPlayer == null || input.localUser?.id == forPlayer.id)) {
		try {
			if(value) await document.body.requestFullscreen()
			else await document.exitFullscreen()
		} catch(error) {
			core.onError(error)
		}
	} 
}
Platform.setLocalStorageObject = function(key, value, then, $else) {
	try {
		localStorage.setItem(key, JSON.stringify(value))
		then?.()
	} catch(e) {
		$else?.()
	}
}
Platform.getLocalStorageObject = function(key) {
	try {
		let str = localStorage.getItem(key)
		return str ? JSON.parse(str) : null 
	} catch {
		return null
	}
}
Platform.setLocalStorageString = function(key, value) {
	try {
		localStorage.setItem(key, value)
		return true
	} catch(e) {
		return false
	}
}
Platform.getLocalStorageString = function(key) {
	try {
		return localStorage.getItem(key) || ""
	} catch {
		return ""
	}
}
Platform.setInterval = function(interval, code) {
	setInterval(code, interval)
}
Platform.initPlatform = function() {
	statistics.init();
	IndexedDB?.init();
	Platform.init();
	graphics.init();
	math.init();
	core.init();
	input.init();
	gizmo.init();
	Loca.init();
	ServerNetwork.init();
	PeerNetwork.init();
	if(typeof(pocketBase) != "undefined") pocketBase.init();
	core.log("Loading...")
	Platform.isMobile = false;
	Platform.isBrowser = !window.require;
	Platform.isNode = window.process && process.versions.node
	Platform.logSerialize = window._serializeLog != null
	let platform = navigator.platform
	Platform.os = platform.startsWith("Win") ? 0 : platform.startsWith("Mac") ? 1 : 2
	if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) 
		|| /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0,4))) { 
		Platform.isMobile = true;
	}
	if(!Platform.isMobile) 
		window.onresize = e => { 
			graphics.onResize();
			if(Platform.mode < 3/*Pause,Manipulator,Slide*/ && Platform.engineStarted) Platform.goToCurrentFrame();
		}
	if(app.init) app.init();
}
Platform.start = async function(isDebug, referenceSizeX, referenceSizeY, userCount, simulateConnection) {
	try {
		let now = performance.now();
		Platform.nextHeartbeatTime = 0;
		Platform.heartbeat("start");
		_constCache = [null]
		audio.init();
		$Image.init?.();
		Font.init?.();
		Sound.init?.();
		Time.timezoneOffset = new Date().getTimezoneOffset() * 60000;
		Platform.initPlatform();
		Platform.engineStarted = false;
		Platform.isDebug = isDebug;
		Platform.userCount = userCount;
		if(typeof(pocketBase) != "undefined") await pocketBase.connect2();
		statistics.startTime = now;
		core.simulateConnection = simulateConnection;
		Platform.showDebugInfo = Platform.getLocalStorageObject("showDebugInfo") == "true";
		await graphics.setup(new Vector2(referenceSizeX, referenceSizeY, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/platform.l", 4719, 4751, null, null)));
		graphics.onResize();
		if(Platform.mode >= 3/*Play*/) {
			Platform.mode = 0/*Pause*/;
		}
		let path = location.href.getUntil("?", 0).split("/");
		let gameId = path[3];
		let roomId = path[4];
		Platform.isStaging = isDebug || roomId == "staging" || roomId == "latest";
		let userId = -1;
		if(roomId) {
			let dashIndex = roomId.indexOf("x");
			if(dashIndex != -1) {
				Platform.isStaging = true;
			} else {
				dashIndex = roomId.indexOf("u");
			}
			if(dashIndex != -1) {
				userId = parseInt(roomId.substring(dashIndex + 1));
				roomId = roomId.substring(0, dashIndex);
			}
		}
		await Platform.preload();
		Platform.openMedia(() => {
			try {
				Platform.engineStarted = true;
				statistics.loadTime = (performance.now() - statistics.startTime);
				Platform.startInterval();
				if(isDebug || Platform.isLocal || roomId == "local" || location.href.startsWith("file")) {
					core.startLocal();
				} else {
					core.join(gameId, roomId, userId);
				}
				if(!isDebug) {
					Platform.record();
				}
			} catch(error) {
				if(window._sendErrorToEditor) _sendErrorToEditor(error)
				else console.error(error);
			} finally {
				console.log("[app] Finished initializing")
				if(Platform.isDebug) _sendToEditor({type:"finished"});
			}
		});
	} catch(error) {
		if(window._sendErrorToEditor) _sendErrorToEditor(error)
		else console.error(error);
		console.log("[app] Finished initializing")
		if(Platform.isDebug) _sendToEditor({type:"finished"});
	}
}
Platform.preload = async function() {
	if(app.preload) await app.preload();
}
Platform.replay = async function() {
	try {
		Platform.heartbeat("replay");
		_constCache = [null]
		audio.init();
		$Image.init?.();
		Font.init?.();
		Sound.init?.();
		Time.timezoneOffset = new Date().getTimezoneOffset() * 60000;
		if(typeof(pocketBase) != "undefined") await pocketBase.connect2();
		Platform.openMedia(() => {
			Platform.goToCurrentFrame();
		});
	} catch(error) {
		if(window._sendErrorToEditor) _sendErrorToEditor(error)
		else console.error(error);
		console.log("[app] Finished initializing")
		if(Platform.isDebug) _sendToEditor({type:"finished"});
	}
}
Platform.generateIntegrationTest = function(mode) {
	input.generateIntegrationTest = mode;
	input.integrationTest = "";
	Platform.goToCurrentFrame();
	input.generateIntegrationTest = 0/*None*/;
	if(Platform.isDebug) _sendToEditor(({type:"integrationTest", text:input.integrationTest}));
}
Platform.goToCurrentFrame = function() {
	try {
		core.goToFrame(core.frame - 1, true);
	} catch(error) {
		if(window._sendErrorToEditor) _sendErrorToEditor(error)
		else console.error(error);
	} finally {
		console.log("[app] Finished initializing")
		if(Platform.isDebug) _sendToEditor({type:"finished"});
	}
}
Platform.startInterval = function() {
	if(Platform.interval) clearInterval(Platform.interval)
	if(window.tick) return
		
	if(Platform.intervalMode == 0) {
		Platform.interval = setInterval(() => Platform.tick(), 1000/core.targetFps)
	} else {
		window.tick = function() {
			Platform.tick();
			window.requestAnimationFrame(window.tick);
		}
		window.tick();
	}
}
Platform.tick = function() {
	Platform.heartbeat("tick");
	if(Platform.mode == 3/*Play*/ || Platform.mode == 4/*Record*/ || Platform.waitingForInitialData) {
		core.animationFrame();
	}
}
Platform.enterSlideMode = function(mode) {
	Platform.mode = mode;
	Platform.sendMode();
}
Platform.stop = function() {
	Platform.mode = 0/*Pause*/;
	gizmo.clear();
	core.stop();
	Platform.sendMode();
}
Platform.pause = function() {
	Platform.mode = 0/*Pause*/;
	gizmo.clear();
	audio.stop();
	Platform.sendMode();
}
Platform.record = function() {
	core.adjustStartTimeIfNeeded();
	Platform.mode = 4/*Record*/;
	core.record();
	gizmo.clear();
	Platform.sendMode();
}
Platform.play = function() {
	core.adjustStartTimeIfNeeded();
	Platform.mode = 3/*Play*/;
	gizmo.clear();
	Platform.sendMode();
}
Platform.switchToPlayer = function(index) {
	core.switchToPlayer(input.players[index]);
	if(Platform.mode == 0/*Pause*/) {
		core.step(false, true);
	}
}
Platform.goToFrame = function(targetFrame) {
	Platform.pause();
	core.goToFrame(targetFrame, false);
}
Platform.sendSelectToEditor = function(cursorFile, cursorPos) {
	_sendToEditor({type:"select", cursorFile, cursorPos})
}
Platform.sendDeselectToEditor = function() {
	_sendToEditor({type:"deselect"})
}
Platform.sendStartManipulationToEditor = function(influences) {
	_sendToEditor({type:"startManipulation", influences})
}
Platform.sendMoveManipulationToEditor = function(influences, codeId) {
	_sendToEditor({type:"moveManipulation", influences, codeId})
}
Platform.sendFrame = function(frame, frames) {
	_sendToEditor({type:"frame", frame, frames})
}
Platform.sendWatch = function(frame, text, location, file) {
	_sendToEditor({type:"watch", frame, text, location, file})
}
Platform.sendClearTimeline = function() {
	_sendToEditor({type:"clearTimeline"})
}
Platform.sendMode = function() {
	if(Platform.isDebug) _sendToEditor({type:"setPlatformMode", mode:Platform.mode, frame:core.frame})
}
Platform.heartbeat = function(context) {
	if(!Platform.isDebug) return
	let now = Date.now();
	if(now > Platform.nextHeartbeatTime) {
		Platform.nextHeartbeatTime = now + 3000;
		_sendStringToEditor("~");
	}
}
Platform.toggleDebugInfo = function() {
	Platform.showDebugInfo = !Platform.showDebugInfo;
	Platform.setLocalStorageObject("showDebugInfo", (Platform.showDebugInfo ? "true" : "false"), null, null);
	graphics.updateBaseMatrix();
}
Platform.toggleSmallScreen = function() {
	Platform.isSmallScreen = !Platform.isSmallScreen;
	System.print("isSmallScreen: "+Platform.isSmallScreen, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/platform.l", 10038, 10057, null, null));
	Platform.setLocalStorageObject("smallScreen", (Platform.isSmallScreen ? "true" : "false"), null, null);
}
Platform.generateObjectId = function() {
	var result = (Date.now() / 1000 | 0).toString(16)
	for(let i=0; i<16; i++)
		result += (Math.random() * 16 | 0).toString(16)
	return result.toLowerCase()
}
Platform.stack = function() {
	try { _ }
	catch(e) { return e.stack }
}
Platform.quit = function() {
}
Platform.openDevTools = function() {
	require('@electron/remote/main').remote.getCurrentWindow().toggleDevTools()
}
function ImmutableList(list) {
	this.list = list;
}
function _ImmutableList() {};
_ImmutableList.prototype = ImmutableList.prototype;
function Reference(container, key) {
	this.container = container;
	this.key = key;
}
Reference.prototype.set = function(value) {
	this.container[this.key] = value;
}
Reference.prototype.get = function() {
	return this.container[this.key];
}
function _Reference() {};
_Reference.prototype = Reference.prototype;
var System; if(!System) System = {};
System.log = function(value) {
	console.log(value)
}
System.watch = function(text, sourceCodeLocation) {
	if(Platform.isDebug && core.frame >= core.frameWithNewWatches && sourceCodeLocation) {
		Platform.sendWatch(core.frame, text, sourceCodeLocation.start, sourceCodeLocation.file)
	}
}
System.visualize = function(position, color, text, location) {
	new VisualizeObject(position, new Vector2(0.0, 0.0, null), 0.0, 1, null, 0, false, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 7115, 7176, null, null), color, core.watchIndex, text);
	if(Platform.isDebug && core.frame >= core.frameWithNewWatches && (location != null)) {
		Platform.sendWatch(core.frame, text || position.toString(), location.start, location.file);
	}
	core.watchIndex++;
}
System.print = function(text, location) {
	
	core.log(text);
	if(Platform.isDebug) {
		var stringValue = typeof text === "string" ? text : JSON.stringify(text);
		if(stringValue) _sendToEditor({type:"log", value:stringValue, location:location ? location.start : 0, file:location ? location.file: ""});
	}
}
var math; if(!math) math = {};
math.PI = 3.141592653589793;
math.TwoPI = 6.283185307179586;
math.moveTowards = function(value, targetValue, speed) {
	if(targetValue > value) {
		return Math.min(value + speed, targetValue);
	} else {
		if(targetValue < value) {
			return Math.max(value - speed, targetValue);
		}
	}
}
math.moveTowards2 = function(value, targetValue, speed) {
	if(targetValue > value) {
		return Math.min(value + speed, targetValue);
	} else {
		if(targetValue < value) {
			return Math.max(value - speed, targetValue);
		}
	}
}
math.sin = function(angle) {
	let result = (angle - .5 - Math.floor(angle));
	result *= 16 * (Math.abs(result) - .5);
	result += .225 * result * (Math.abs(result) - 1);
	return result;
}
math.cos = function(angle) {
	let result = (angle - .25 - Math.floor(angle + .25));
	result *= 16 * (Math.abs(result) - .5);
	result += .225 * result * (Math.abs(result) - 1);
	return result;
}
math.tan = function(angle) {
	return math.sin(angle) / math.cos(angle);
}
math.atan2 = function(y, x) {
	let r = 0.0;
	let angle = 0.0;
	let abs_x = Math.abs(x) + .00000000001;
	if(y > 0.0) {
		r = (abs_x - y) / (abs_x + y);
		angle = .375;
	} else {
		r = (-abs_x - y) / (abs_x - y);
		angle = .125;
	}
	angle += ((.03124211533 * r * r - .1562424076) * r);
	if(x < 0.0) {
		return -angle;
	} else {
		return angle;
	}
}
math.limit = function(value, min, max) {
	if(value < min) {
		return min;
	}
	if(value > max) {
		return max;
	}
	return value;
}
math.limit2 = function(value, max) {
	if(value > max) {
		return max;
	}
	return value;
}
math.limit3 = function(value, min) {
	if(value < min) {
		return min;
	}
	return value;
}
math.limit4 = function(value, min, max) {
	if(value < min) {
		return min;
	}
	if(value > max) {
		return max;
	}
	return value;
}
math.limit5 = function(value, max) {
	if(value > max) {
		return max;
	}
	return value;
}
math.limit6 = function(value, min) {
	if(value < min) {
		return min;
	}
	return value;
}
math.randomString = function(length) {
	let chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
	let token = "";
	for(let i=0; i<length; ++i) {
		token += chars[math.randomInteger2(chars.length - 1)];
	}
	return token;
}
math.getAngleForVector = function(vector) {
	return math.atan2(vector.y, vector.x);
}
math.getVectorForAngle = function(angle, radius) {
	return new Vector2(math.sin(angle) * radius, -math.cos(angle) * radius, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 34509, 34565, null, null));
}
math.intersectLines = function(startA, endA, startB, endB, typeA, typeB) {
	let x1 = startA.x, y1 = startA.y;
	let x2 = endA.x, y2 = endA.y;
	let x3 = startB.x, y3 = startB.y;
	let x4 = endB.x, y4 = endB.y;
	if((x1 == x2 && y1 == y2) || (x3 == x4 && y3 == y4)) {
		return new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null);
	}
	let denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
	if((denominator == 0)) {
		return new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null);
	}
	let ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
	let ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;
	if((typeA >= 1/*Ray*/ && ua < 0) || (typeA == 2/*Segment*/ && ua > 1) || (typeB >= 1/*Ray*/ && ub < 0) || (typeB == 2/*Segment*/ && ub > 1)) {
		return new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null);
	}
	return new Vector2(x1 + ua * (x2 - x1), y1 + ua * (y2 - y1), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 35669, 35718, null, null));
}
math.projectPointOnLine = function(from, to, type, point) {
	let lineVector = to.minus(from);
	let pointVector = point.minus(from);
	let scalar = (pointVector.dot(lineVector)) / lineVector.lengthSquared();
	if(type >= 1/*Ray*/ && scalar < 0) {
		return new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null);
	}
	if(type == 2/*Segment*/ && scalar > 1) {
		return new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null);
	}
	return from.plus(lineVector.multiply2(scalar));
}
math.closestPointOnLine = function(from, to, type, point) {
	let lineVector = to.minus(from);
	let pointVector = point.minus(from);
	let scalar = (pointVector.dot(lineVector)) / lineVector.lengthSquared();
	if(type >= 1/*Ray*/ && scalar < 0) {
		scalar = 0;
	}
	if(type == 2/*Segment*/ && scalar > 1) {
		scalar = 1;
	}
	return from.plus(lineVector.multiply2(scalar));
}
math.map = function(progress, from, to, start, target) {
	if(progress <= from) {
		return start;
	}
	if(progress >= to) {
		return target;
	}
	let factor = (progress - from) / (to - from);
	return start + (target - start) * factor;
}
math.map2 = function(progress, start, target) {
	if(progress <= 0) {
		return start;
	}
	if(progress >= 1) {
		return target;
	}
	return start + (target - start) * progress;
}
math.map3 = function(progress, from, to, start, target, ease) {
	if(progress <= from) {
		return start;
	}
	if(progress >= to) {
		return target;
	}
	let factor = ease.function?.invoke((progress - from) / (to - from));
	return start + (target - start) * factor;
}
math.interpolate = function(from, to, startTime, duration) {
	let value = Time.now - startTime;
	if(value <= 0) {
		return from;
	}
	if(value >= duration) {
		return to;
	}
	return from + (to - from) * (value / duration);
}
math.interpolate2 = function(from, to, startTime, duration) {
	return from.interpolateTo(to, (Time.now - startTime) / duration);
}
math.init = function() {
	math.randomSeed = "";
	math.randomValueIndex = 0;
	math.randomValues = [];
	math.initDefaultRandomGenerator();
}
math.initDefaultRandomGenerator = function() {
	math.randomGenerator = Math.random
}
math.generateRandomSeed = function() {
	let crypto = !window.crypto && typeof(require) != "undefined" ? require("crypto") : window.crypto
	if(crypto) {
		let out = new Uint8Array(256);
		crypto.getRandomValues(out);
		return out.toString();
	}
}
math.recreateRandomValues = function() {
	let targetRandomValueIndex = math.randomValueIndex;
	math.setRandomSeed(math.randomSeed);
	for(let i=0; i<targetRandomValueIndex; ++i) {
		math.randomFloat2(1.0);
	}
}
math.setRandomSeed = function(seed) {
	math.randomSeed = seed
	math.randomValues.length = 0
	math.randomValueIndex = 0
	
	
	
	function xmur3(str) {
		for(var i = 0, h = 1779033703 ^ str.length; i < str.length; i++) {
			h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
			h = h << 13 | h >>> 19;
		} return function() {
			h = Math.imul(h ^ (h >>> 16), 2246822507);
			h = Math.imul(h ^ (h >>> 13), 3266489909);
			return (h ^= h >>> 16) >>> 0;
		}
	}
	
	function sfc32(a, b, c, d) {
		return function() {
			a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0; 
			var t = (a + b) | 0;
			a = b ^ b >>> 9;
			b = c + (c << 3) | 0;
			c = (c << 21 | c >>> 11);
			d = d + 1 | 0;
			t = t + d | 0;
			c = c + t | 0;
			return (t >>> 0) / 4294967296;
		}
	}
	
	function mulberry32(a) {
		return function() {
			var t = a += 0x6D2B79F5;
			t = Math.imul(t ^ t >>> 15, t | 1);
			t ^= t + Math.imul(t ^ t >>> 7, t | 61);
			return ((t ^ t >>> 14) >>> 0) / 4294967296;
		}
	}
	
	var seed = xmur3(seed);
	var rand = sfc32(seed(), seed(), seed(), seed());
	var rand = mulberry32(seed());
	
	math.randomGenerator = function() {
		let value
		if(math.randomValueIndex < math.randomValues.length) {
			value = math.randomValues[math.randomValueIndex]
			math.randomValueIndex++
		} else {
			value = rand()
			math.randomValues[math.randomValueIndex++] = value;
		}
		return value
	}
}
math.randomInteger = function(from, to) {
	return from + Math.floor(math.randomGenerator() * (to-from))
}
math.randomInteger2 = function(to) {
	return Math.floor(math.randomGenerator() * to)
}
math.randomFloat = function(from, to) {
	return from + math.randomGenerator() * (to-from)
}
math.randomFloat2 = function(to) {
	return math.randomGenerator() * to
}
function math_serialize_internal(buffer) {
	buffer.writeInt32(math.randomValueIndex);
}
function math_deserialize_internal(buffer) {
	math.randomValueIndex = buffer.readInt32();
}
function math_serialize_external(buffer) {
	buffer.writeString("randomValueIndex");
	buffer.writeInt32(4);
	buffer.writeInt32(math.randomValueIndex);
	buffer.writeString("");
}
function math_deserialize_external(buffer) {
	let randomValueIndex_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "randomValueIndex":
				buffer.readInt32();
				math.randomValueIndex = buffer.readInt32();
				randomValueIndex_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!randomValueIndex_is_set) math.randomValueIndex = 0;
				return;
		}
	}
}
function RollingList(length, fractionDigits) {
	this.length = length;
	this.fractionDigits = fractionDigits;
	this.values = [];
	this.index = 0;
}
RollingList.prototype.add = function(value) {
	this.values[(((this.index++ % this.length) + this.length) % this.length)] = value;
}
RollingList.prototype.measure = function($do) {
	let startTime = performance.now();
	$do();
	this.values[(((this.index++ % this.length) + this.length) % this.length)] = performance.now() - startTime;
}
RollingList.prototype.average = function() {
	if(this.values.length == 0) {
		return 0.0;
	}
	let total = 0.0;
	for(let i=0, _subject=this.values, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		total += it;
	}}
	return total / ((this.values.length > this.length ? this.length : this.values.length));
}
RollingList.prototype.max = function() {
	if(this.values.length == 0) {
		return 0.0;
	}
	let max = -Number.MAX_VALUE;
	for(let i=0, _subject=this.values, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(it > max) {
			max = it;
		}
	}}
	return max;
}
RollingList.prototype.min = function() {
	if(this.values.length == 0) {
		return 0.0;
	}
	let min = Number.MAX_VALUE;
	for(let i=0, _subject=this.values, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(it < min) {
			min = it;
		}
	}}
	return min;
}
RollingList.prototype.toString = function() {
	return this.average().toLocaleString("en-US", {maximumFractionDigits:this.fractionDigits, minimumFractionDigits:this.fractionDigits, minimumIntegerDigits:1, useGrouping:false});
}
RollingList.prototype.clone = function() {
	let clone = new _RollingList();
	clone.length = this.length;
	clone.fractionDigits = this.fractionDigits;
	clone.values = this.values;
	clone.index = this.index;
	return clone;
}
function _RollingList() {};
_RollingList.prototype = RollingList.prototype;
RollingList.prototype.serialize_internal = function(buffer) {
	buffer.writeInt32(this.length);
	buffer.writeInt32(this.fractionDigits);
	let values = this.values
	if(values) {
		var index = _objectCacheIndex.get(values);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(values, index = _objectCache.length);
			_objectCache.push(values);
			buffer.writeInt32(-index);
			values._objectIndex = index;
			buffer.writeInt32(values.length);
			for(let i=0, len=values.length; i<len; ++i) {
				buffer.writeFloat64(values[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.index);
}
RollingList.prototype.deserialize_internal = function(buffer) {
	this.length = buffer.readInt32();
	this.fractionDigits = buffer.readInt32();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.values = _objectCache[index];
	} else {
		let values = this.values
		if(!values || values._objectIndex != -index) this.values = values = [];
		_objectCache[-index] = values;
		for(let i=0, len = values.length = buffer.readInt32(); i<len; ++i) {
				values[i] = buffer.readFloat64();
		}
	}
	this.index = buffer.readInt32();
}
RollingList.prototype.serialize_external = function(buffer) {
	buffer.writeString("length");
	buffer.writeInt32(4);
	buffer.writeInt32(this.length);
	buffer.writeString("fractionDigits");
	buffer.writeInt32(4);
	buffer.writeInt32(this.fractionDigits);
	buffer.writeString("values");
	let values = this.values
	let values_startPos = buffer.reserveSize();
	if(values) {
		var index = _objectCacheIndex.get(values);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(values, index = _objectCache.length);
			_objectCache.push(values);
			buffer.writeInt32(-index);
			values._objectIndex = index;
			buffer.writeInt32(values.length);
			for(let i=0, len=values.length; i<len; ++i) {
				buffer.writeFloat64(values[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(values_startPos);
	buffer.writeString("index");
	buffer.writeInt32(4);
	buffer.writeInt32(this.index);
	buffer.writeString("");
}
RollingList.prototype.deserialize_external = function(buffer) {
	let length_is_set = false, fractionDigits_is_set = false, values_is_set = false, index_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "length":
				buffer.readInt32();
				this.length = buffer.readInt32();
				length_is_set = true;
				break;
			case "fractionDigits":
				buffer.readInt32();
				this.fractionDigits = buffer.readInt32();
				fractionDigits_is_set = true;
				break;
			case "values":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.values = _objectCache[index];
				} else {
					let values = this.values
					if(!values || values._objectIndex != -index) this.values = values = [];
					_objectCache[-index] = values;
					for(let i=0, len = values.length = buffer.readInt32(); i<len; ++i) {
							values[i] = buffer.readFloat64();
					}
				}
				values_is_set = true;
				break;
			case "index":
				buffer.readInt32();
				this.index = buffer.readInt32();
				index_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!length_is_set) this.length = 30;
				if(!fractionDigits_is_set) this.fractionDigits = 1;
				if(!values_is_set) this.values = [];
				if(!index_is_set) this.index = 0;
				return;
		}
	}
}
function Range(from, to) {
	this.from = from;
	this.to = to;
}
Range.prototype.clone = function() {
	let clone = new _Range();
	clone.from = this.from;
	clone.to = this.to;
	return clone;
}
function _Range() {};
_Range.prototype = Range.prototype;
Range.prototype.serialize_internal = function(buffer) {
	buffer.writeInt32(this.from);
	buffer.writeInt32(this.to);
}
Range.prototype.deserialize_internal = function(buffer) {
	this.from = buffer.readInt32();
	this.to = buffer.readInt32();
}
Range.prototype.serialize_external = function(buffer) {
	buffer.writeString("from");
	buffer.writeInt32(4);
	buffer.writeInt32(this.from);
	buffer.writeString("to");
	buffer.writeInt32(4);
	buffer.writeInt32(this.to);
	buffer.writeString("");
}
Range.prototype.deserialize_external = function(buffer) {
	let from_is_set = false, to_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "from":
				buffer.readInt32();
				this.from = buffer.readInt32();
				from_is_set = true;
				break;
			case "to":
				buffer.readInt32();
				this.to = buffer.readInt32();
				to_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!from_is_set) this.from = 0;
				if(!to_is_set) this.to = 0;
				return;
		}
	}
}
function File(lastModified, lastModifiedDate, name, path, size, type) {
	this.lastModified = lastModified;
	this.lastModifiedDate = lastModifiedDate;
	this.name = name;
	this.path = path;
	this.size = size;
	this.type = type;
}
File.prototype.clone = function() {
	let clone = new _File();
	clone.lastModified = this.lastModified;
	clone.lastModifiedDate = this.lastModifiedDate;
	clone.name = this.name;
	clone.path = this.path;
	clone.size = this.size;
	clone.type = this.type;
	return clone;
}
function _File() {};
_File.prototype = File.prototype;
File.prototype.serialize_internal = function(buffer) {
	buffer.writeFloat64(this.lastModified);
	buffer.writeString(this.lastModifiedDate);
	buffer.writeString(this.name);
	buffer.writeString(this.path);
	buffer.writeInt32(this.size);
	buffer.writeString(this.type);
}
File.prototype.deserialize_internal = function(buffer) {
	this.lastModified = buffer.readFloat64();
	this.lastModifiedDate = buffer.readString();
	this.name = buffer.readString();
	this.path = buffer.readString();
	this.size = buffer.readInt32();
	this.type = buffer.readString();
}
File.prototype.serialize_external = function(buffer) {
	buffer.writeString("lastModified");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.lastModified);
	buffer.writeString("lastModifiedDate");
	buffer.writeString(this.lastModifiedDate);
	buffer.writeString("name");
	buffer.writeString(this.name);
	buffer.writeString("path");
	buffer.writeString(this.path);
	buffer.writeString("size");
	buffer.writeInt32(4);
	buffer.writeInt32(this.size);
	buffer.writeString("type");
	buffer.writeString(this.type);
	buffer.writeString("");
}
File.prototype.deserialize_external = function(buffer) {
	let lastModified_is_set = false, lastModifiedDate_is_set = false, name_is_set = false, path_is_set = false, size_is_set = false, type_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "lastModified":
				buffer.readInt32();
				this.lastModified = buffer.readFloat64();
				lastModified_is_set = true;
				break;
			case "lastModifiedDate":
				this.lastModifiedDate = buffer.readString();
				lastModifiedDate_is_set = true;
				break;
			case "name":
				this.name = buffer.readString();
				name_is_set = true;
				break;
			case "path":
				this.path = buffer.readString();
				path_is_set = true;
				break;
			case "size":
				buffer.readInt32();
				this.size = buffer.readInt32();
				size_is_set = true;
				break;
			case "type":
				this.type = buffer.readString();
				type_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!lastModified_is_set) this.lastModified = 0.0;
				if(!lastModifiedDate_is_set) this.lastModifiedDate = "";
				if(!name_is_set) this.name = "";
				if(!path_is_set) this.path = "";
				if(!size_is_set) this.size = 0;
				if(!type_is_set) this.type = "";
				return;
		}
	}
}
var Loca; if(!Loca) Loca = {};
Loca.languageName = function() {
	return Loca.languageNames[Loca.language];
}
Loca.init = function() {
	Loca.defaultLocaleForLanguage = ["en-001", "de-DE", "es-ES", "fr-FR", "it-IT", "pt-PT", "ja-JP", "zh-Hans-CN", "ko-KR", "nl-NL", "tr-TR", "pl-PL", "ru-RU", "hi-IN", "ar-001", "bn-BD", "ur-IN", "id-ID"];
	Loca.languageNames = ["English", "German", "Spanish", "French", "Italian", "Portuguese", "Japanese", "Chinese", "Korean", "Dutch", "Turkish", "Polish", "Russian", "Hindi", "Arabic", "Bengali", "Urdu", "Indonesian", "Invariant"];
	Loca.supportedLanguages = [0/*English*/, 1/*German*/];
	Loca.language = 0/*English*/;
	Loca.locale = Loca.defaultLocaleForLanguage[Loca.language];
	Loca.setLanguage(0/*English*/, null);
}
Loca.setLanguage = function(language, locale) {
	Loca.language = language
	Loca.locale = locale || Loca.defaultLocaleForLanguage[language]
}
Loca.format = function(id) {
	let entry = _strings[Loca.language][id]
	if(!entry || entry.s.length == 0) return "##########"
	let strings = entry.s
	let result = strings[0]
	let stringIndex = 1
	for(let placeholderNumber of entry.p) {
		if(placeholderNumber >= 0) {
			
			
			
			let placeholderValue = arguments[placeholderNumber+1]
			result += placeholderValue
			if(stringIndex < strings.length) {
				let str = strings[stringIndex++]
				if(str) result += str
			}
		} else {
			
			
			
			
			let placeholderValue = arguments[-placeholderNumber]
			result += placeholderValue
			let str = strings[placeholderValue == 1 ? stringIndex : stringIndex+1]
			if(str) result += str
			stringIndex += 2
		}
	}
	return result
}
function Loca_serialize_internal(buffer) {
	let _defaultLocaleForLanguage = Loca.defaultLocaleForLanguage
	if(_defaultLocaleForLanguage) {
		var index = _objectCacheIndex.get(_defaultLocaleForLanguage);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_defaultLocaleForLanguage, index = _objectCache.length);
			_objectCache.push(_defaultLocaleForLanguage);
			buffer.writeInt32(-index);
			_defaultLocaleForLanguage._objectIndex = index;
			buffer.writeInt32(_defaultLocaleForLanguage.length);
			for(let i=0, len=_defaultLocaleForLanguage.length; i<len; ++i) {
				buffer.writeString(_defaultLocaleForLanguage[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let _languageNames = Loca.languageNames
	if(_languageNames) {
		var index = _objectCacheIndex.get(_languageNames);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_languageNames, index = _objectCache.length);
			_objectCache.push(_languageNames);
			buffer.writeInt32(-index);
			_languageNames._objectIndex = index;
			buffer.writeInt32(_languageNames.length);
			for(let i=0, len=_languageNames.length; i<len; ++i) {
				buffer.writeString(_languageNames[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let _supportedLanguages = Loca.supportedLanguages
	if(_supportedLanguages) {
		var index = _objectCacheIndex.get(_supportedLanguages);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_supportedLanguages, index = _objectCache.length);
			_objectCache.push(_supportedLanguages);
			buffer.writeInt32(-index);
			_supportedLanguages._objectIndex = index;
			buffer.writeInt32(_supportedLanguages.length);
			for(let i=0, len=_supportedLanguages.length; i<len; ++i) {
				buffer.writeInt32(_supportedLanguages[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(Loca.language);
	buffer.writeString(Loca.locale);
}
function Loca_deserialize_internal(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		Loca.defaultLocaleForLanguage = _objectCache[index];
	} else {
		let _defaultLocaleForLanguage = Loca.defaultLocaleForLanguage
		if(!_defaultLocaleForLanguage || _defaultLocaleForLanguage._objectIndex != -index) Loca.defaultLocaleForLanguage = _defaultLocaleForLanguage = [];
		_objectCache[-index] = _defaultLocaleForLanguage;
		for(let i=0, len = _defaultLocaleForLanguage.length = buffer.readInt32(); i<len; ++i) {
				_defaultLocaleForLanguage[i] = buffer.readString();
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Loca.languageNames = _objectCache[index];
	} else {
		let _languageNames = Loca.languageNames
		if(!_languageNames || _languageNames._objectIndex != -index) Loca.languageNames = _languageNames = [];
		_objectCache[-index] = _languageNames;
		for(let i=0, len = _languageNames.length = buffer.readInt32(); i<len; ++i) {
				_languageNames[i] = buffer.readString();
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Loca.supportedLanguages = _objectCache[index];
	} else {
		let _supportedLanguages = Loca.supportedLanguages
		if(!_supportedLanguages || _supportedLanguages._objectIndex != -index) Loca.supportedLanguages = _supportedLanguages = [];
		_objectCache[-index] = _supportedLanguages;
		for(let i=0, len = _supportedLanguages.length = buffer.readInt32(); i<len; ++i) {
				_supportedLanguages[i] = buffer.readInt32();
		}
	}
	Loca.language = buffer.readInt32();
	Loca.locale = buffer.readString();
}
function Loca_serialize_external(buffer) {
	buffer.writeString("defaultLocaleForLanguage");
	let _defaultLocaleForLanguage = Loca.defaultLocaleForLanguage
	let _defaultLocaleForLanguage_startPos = buffer.reserveSize();
	if(_defaultLocaleForLanguage) {
		var index = _objectCacheIndex.get(_defaultLocaleForLanguage);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_defaultLocaleForLanguage, index = _objectCache.length);
			_objectCache.push(_defaultLocaleForLanguage);
			buffer.writeInt32(-index);
			_defaultLocaleForLanguage._objectIndex = index;
			buffer.writeInt32(_defaultLocaleForLanguage.length);
			for(let i=0, len=_defaultLocaleForLanguage.length; i<len; ++i) {
				buffer.writeString(_defaultLocaleForLanguage[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_defaultLocaleForLanguage_startPos);
	buffer.writeString("languageNames");
	let _languageNames = Loca.languageNames
	let _languageNames_startPos = buffer.reserveSize();
	if(_languageNames) {
		var index = _objectCacheIndex.get(_languageNames);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_languageNames, index = _objectCache.length);
			_objectCache.push(_languageNames);
			buffer.writeInt32(-index);
			_languageNames._objectIndex = index;
			buffer.writeInt32(_languageNames.length);
			for(let i=0, len=_languageNames.length; i<len; ++i) {
				buffer.writeString(_languageNames[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_languageNames_startPos);
	buffer.writeString("supportedLanguages");
	let _supportedLanguages = Loca.supportedLanguages
	let _supportedLanguages_startPos = buffer.reserveSize();
	if(_supportedLanguages) {
		var index = _objectCacheIndex.get(_supportedLanguages);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_supportedLanguages, index = _objectCache.length);
			_objectCache.push(_supportedLanguages);
			buffer.writeInt32(-index);
			_supportedLanguages._objectIndex = index;
			buffer.writeInt32(_supportedLanguages.length);
			for(let i=0, len=_supportedLanguages.length; i<len; ++i) {
				buffer.writeInt32(_supportedLanguages[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_supportedLanguages_startPos);
	buffer.writeString("language");
	buffer.writeInt32(4);
	buffer.writeInt32(Loca.language);
	buffer.writeString("locale");
	buffer.writeString(Loca.locale);
	buffer.writeString("");
}
function Loca_deserialize_external(buffer) {
	let defaultLocaleForLanguage_is_set = false, languageNames_is_set = false, supportedLanguages_is_set = false, language_is_set = false, locale_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "defaultLocaleForLanguage":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Loca.defaultLocaleForLanguage = _objectCache[index];
				} else {
					let _defaultLocaleForLanguage = Loca.defaultLocaleForLanguage
					if(!_defaultLocaleForLanguage || _defaultLocaleForLanguage._objectIndex != -index) Loca.defaultLocaleForLanguage = _defaultLocaleForLanguage = [];
					_objectCache[-index] = _defaultLocaleForLanguage;
					for(let i=0, len = _defaultLocaleForLanguage.length = buffer.readInt32(); i<len; ++i) {
							_defaultLocaleForLanguage[i] = buffer.readString();
					}
				}
				defaultLocaleForLanguage_is_set = true;
				break;
			case "languageNames":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Loca.languageNames = _objectCache[index];
				} else {
					let _languageNames = Loca.languageNames
					if(!_languageNames || _languageNames._objectIndex != -index) Loca.languageNames = _languageNames = [];
					_objectCache[-index] = _languageNames;
					for(let i=0, len = _languageNames.length = buffer.readInt32(); i<len; ++i) {
							_languageNames[i] = buffer.readString();
					}
				}
				languageNames_is_set = true;
				break;
			case "supportedLanguages":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Loca.supportedLanguages = _objectCache[index];
				} else {
					let _supportedLanguages = Loca.supportedLanguages
					if(!_supportedLanguages || _supportedLanguages._objectIndex != -index) Loca.supportedLanguages = _supportedLanguages = [];
					_objectCache[-index] = _supportedLanguages;
					for(let i=0, len = _supportedLanguages.length = buffer.readInt32(); i<len; ++i) {
							_supportedLanguages[i] = buffer.readInt32();
					}
				}
				supportedLanguages_is_set = true;
				break;
			case "language":
				buffer.readInt32();
				Loca.language = buffer.readInt32();
				language_is_set = true;
				break;
			case "locale":
				Loca.locale = buffer.readString();
				locale_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!defaultLocaleForLanguage_is_set) Loca.defaultLocaleForLanguage = ["en-001", "de-DE", "es-ES", "fr-FR", "it-IT", "pt-PT", "ja-JP", "zh-Hans-CN", "ko-KR", "nl-NL", "tr-TR", "pl-PL", "ru-RU", "hi-IN", "ar-001", "bn-BD", "ur-IN", "id-ID"];
				if(!languageNames_is_set) Loca.languageNames = ["English", "German", "Spanish", "French", "Italian", "Portuguese", "Japanese", "Chinese", "Korean", "Dutch", "Turkish", "Polish", "Russian", "Hindi", "Arabic", "Bengali", "Urdu", "Indonesian", "Invariant"];
				if(!supportedLanguages_is_set) Loca.supportedLanguages = [0/*English*/, 1/*German*/];
				if(!language_is_set) Loca.language = 0/*English*/;
				if(!locale_is_set) Loca.locale = Loca.defaultLocaleForLanguage[Loca.language];
				return;
		}
	}
}
function Buffer(buffer, size, readPos, writePos) {
	this.readPos = readPos;
	this.writePos = writePos;
	this.buffer = buffer;
	this.dataView = null;
	this.setup(size);
}
Buffer.prototype.writeInt = function(value) {
	if(value <= -2147483647 || value >= 2147483647)
		throw new Error("Value out of integer range: "+value)
	let n, lastByte
	if(value > 0) {
		n = value
		lastByte = n & 0x3f
	} else {
		n = -value
		lastByte = (n & 0x3f) | 0x40
	}
	if (n < (1 << 13)) {
		if (n < (1 << 6)) {
			if(this.writePos+1 > this.buffer.byteLength) this.expandBuffer(this.writePos+1)
			let dataView = this.dataView
			dataView.setUint8(this.writePos++, lastByte);
			return 1;
		} else {
			if(this.writePos+2 > this.buffer.byteLength) this.expandBuffer(this.writePos+2)
			let dataView = this.dataView
			dataView.setUint8(this.writePos++, (n >> 6) | 0x80);
			dataView.setUint8(this.writePos++, lastByte);
			return 2;
		}
	} else if (n < (1 << 27)) {
		if (n < (1 << 20)) {
			if(this.writePos+3 > this.buffer.byteLength) this.expandBuffer(this.writePos+3)
			let dataView = this.dataView
			dataView.setUint8(this.writePos++, (n >> 13) | 0x80);
			dataView.setUint8(this.writePos++, ((n >> 6) & 0x7f) | 0x80);
			dataView.setUint8(this.writePos++, lastByte);
			return 3;
		} else {
			if(this.writePos+4 > this.buffer.byteLength) this.expandBuffer(this.writePos+4)
			let dataView = this.dataView
			dataView.setUint8(this.writePos++, (n >> 20) | 0x80);
			dataView.setUint8(this.writePos++, ((n >> 13) & 0x7f) | 0x80);
			dataView.setUint8(this.writePos++, ((n >> 6) & 0x7f) | 0x80);
			dataView.setUint8(this.writePos++, lastByte);
			return 4;
		}
	} else {
		if(this.writePos+5 > this.buffer.byteLength) this.expandBuffer(this.writePos+5)
		let dataView = this.dataView
		dataView.setUint8(this.writePos++, (n >> 27) | 0x80);
		dataView.setUint8(this.writePos++, ((n >> 20) & 0x7f) | 0x80);
		dataView.setUint8(this.writePos++, ((n >> 13) & 0x7f) | 0x80);
		dataView.setUint8(this.writePos++, ((n >> 6) & 0x7f) | 0x80);
		dataView.setUint8(this.writePos++, lastByte);
		return 5;
	}
}
Buffer.prototype.readInt = function() {
	let dataView = this.dataView
	let a = dataView.getUint8(this.readPos++);
	if((a & 0x80) == 0) {
		return a & 0x40 ? -(a & 0x3f) 
						: a;
	} else {
		a &= 0x7f;
		let b = dataView.getUint8(this.readPos++);
		if((b & 0x80) == 0) {
			return b & 0x40 ? -((b & 0x3f) | (a << 6)) 
							: (b | (a << 6));
		} else {
			b &= 0x7f;
			let c = dataView.getUint8(this.readPos++);
			if((c & 0x80) == 0) {
				return c & 0x40 ? -((c & 0x3f) | (b << 6) | (a << 13))
								: (c | (b << 6) | (a << 13));
			} else {
				c &= 0x7f;
				let d = dataView.getUint8(this.readPos++);
				if((d & 0x80) == 0) {
					return d & 0x40 ? -((d & 0x3f) | (c << 6) | (b << 13) | (a << 20))
									: (d | (c << 6) | (b << 13) | (a << 20));
				} else {
					d &= 0x7f;
					let e = dataView.getUint8(this.readPos++);
					return e & 0x40 ? -((e & 0x3f) | (d << 6) | (c << 13) | (b << 20) | (a << 27))
									: (e | (d << 6) | (c << 13) | (b << 20) | (a << 27));
				}
			}
		}
	}
}
Buffer.prototype.writeUnsignedInt = function(value) {
	if(value < 0 || value >= 2147483648)
		throw new Error("Value out of integer range: "+value)
		
	var n = value
	if (n < (1 << 14)) {
		if (n < (1 << 7)) {
			if(this.writePos+1 > this.buffer.byteLength) this.expandBuffer(this.writePos+1)
			let dataView = this.dataView
			dataView.setUint8(this.writePos++, n);
			return 1;
		} else {
			if(this.writePos+2 > this.buffer.byteLength) this.expandBuffer(this.writePos+2)
			let dataView = this.dataView
			dataView.setUint8(this.writePos++, (n >> 7) | 0x80);
			dataView.setUint8(this.writePos++, n & 0x7f);
			return 2;
		}
	} else if (n < (1 << 28)) {
		if (n < (1 << 21)) {
			if(this.writePos+3 > this.buffer.byteLength) this.expandBuffer(this.writePos+3)
			let dataView = this.dataView
			dataView.setUint8(this.writePos++, (n >> 14) | 0x80);
			dataView.setUint8(this.writePos++, ((n >> 7) & 0x7f) | 0x80);
			dataView.setUint8(this.writePos++, n & 0x7f);
			return 3;
		} else {
			if(this.writePos+4 > this.buffer.byteLength) this.expandBuffer(this.writePos+4)
			let dataView = this.dataView
			dataView.setUint8(this.writePos++, (n >> 21) | 0x80);
			dataView.setUint8(this.writePos++, ((n >> 14) & 0x7f) | 0x80);
			dataView.setUint8(this.writePos++, ((n >> 7) & 0x7f) | 0x80);
			dataView.setUint8(this.writePos++, n & 0x7f);
			return 4;
		}
	} else {
		if(this.writePos+5 > this.buffer.byteLength) this.expandBuffer(this.writePos+5)
		let dataView = this.dataView
		dataView.setUint8(this.writePos++, (n >> 28) | 0x80);
		dataView.setUint8(this.writePos++, ((n >> 21) & 0x7f) | 0x80);
		dataView.setUint8(this.writePos++, ((n >> 14) & 0x7f) | 0x80);
		dataView.setUint8(this.writePos++, ((n >> 7) & 0x7f) | 0x80);
		dataView.setUint8(this.writePos++, n & 0x7f);
		return 5;
	}
}
Buffer.prototype.readUnsignedInt = function() {
	let dataView = this.dataView
	let a = dataView.getUint8(this.readPos++);
	if((a & 0x80) == 0) {
		return a;
	} else {
		a &= 0x7f;
		let b = dataView.getUint8(this.readPos++);
		if((b & 0x80) == 0) {
			return b | (a << 7);
		} else {
			b &= 0x7f;
			let c = dataView.getUint8(this.readPos++);
			if((c & 0x80) == 0) {
				return c | (b << 7) | (a << 14);
			} else {
				c &= 0x7f;
				let d = dataView.getUint8(this.readPos++);
				if((d & 0x80) == 0) {
					return d | (c << 7) | (b << 14) | (a << 21);
				} else {
					d &= 0x7f;
					let e = dataView.getUint8(this.readPos++);
					return e | (d << 7) | (c << 14) | (b << 21) | (a << 28);
				}
			}
		}
	}
}
Buffer.prototype.writeString = function(value) {
	if(!value) {
		if(this.writePos+4 > this.buffer.byteLength)
			this.expandBuffer(this.writePos+4)
		this.dataView.setInt32(this.writePos, 0)
		this.writePos += 4
		return
	}
	let maxSize = value.length*3
	if(this.writePos+maxSize+4 > this.buffer.byteLength)
		this.expandBuffer(this.writePos+maxSize+4)
		
	var array = new Uint8Array(this.buffer, this.writePos+4, maxSize)
	var result = Buffer.textEncoder.encodeInto(value, array)
	var size = result.written
	this.dataView.setInt32(this.writePos, size)
	this.writePos += size + 4
}
Buffer.prototype.readString = function() {
	let size = this.dataView.getInt32(this.readPos)
	this.readPos += 4
	var array = new Uint8Array(this.buffer, this.readPos, size)
	this.readPos += size
	return Buffer.textDecoder.decode(array)
}
Buffer.prototype.skip = function(count) {
	this.readPos += count;
}
Buffer.prototype.reserveSize = function() {
	this.writePos += 4
	return this.writePos
}
Buffer.prototype.writeSize = function(pos) {
	this.dataView.setInt32(pos-4, this.writePos-pos)
}
Buffer.prototype.writeInt8 = function(value) {
	if(this.writePos+1 > this.buffer.byteLength)
		this.expandBuffer(this.writePos+1)
	this.dataView.setInt8(this.writePos, value)
	this.writePos += 1
}
Buffer.prototype.writeUnsignedInt8 = function(value) {
	if(this.writePos+1 > this.buffer.byteLength)
		this.expandBuffer(this.writePos+1)
	this.dataView.setUint8(this.writePos, value)
	this.writePos += 1
}
Buffer.prototype.writeInt16 = function(value) {
	if(this.writePos+2 > this.buffer.byteLength)
		this.expandBuffer(this.writePos+2)
	this.dataView.setInt16(this.writePos, value)
	this.writePos += 2
}
Buffer.prototype.writeUnsignedInt16 = function(value) {
	if(this.writePos+2 > this.buffer.byteLength)
		this.expandBuffer(this.writePos+2)
	this.dataView.setUint16(this.writePos, value)
	this.writePos += 2
}
Buffer.prototype.writeInt32 = function(value) {
	if(this.writePos+4 > this.buffer.byteLength)
		this.expandBuffer(this.writePos+4)
	this.dataView.setInt32(this.writePos, value)
	this.writePos += 4
}
Buffer.prototype.writeFloat32 = function(value) {
	if(this.writePos+4 > this.buffer.byteLength)
		this.expandBuffer(this.writePos+4)
	this.dataView.setFloat32(this.writePos, value)
	this.writePos += 4
}
Buffer.prototype.writeFloat64 = function(value) {
	if(this.writePos+8 > this.buffer.byteLength)
		this.expandBuffer(this.writePos+8)
	this.dataView.setFloat64(this.writePos, value)
	this.writePos += 8
}
Buffer.prototype.writeBool = function(value) {
	if(this.writePos+1 > this.buffer.byteLength)
		this.expandBuffer(this.writePos+1)
	this.dataView.setInt8(this.writePos, value ? 1 : 0)
	this.writePos += 1
}
Buffer.prototype.writeBuffer = function(source) {
	this.writeBuffer2(source, 0, source.writePos);
}
Buffer.prototype.writeBuffer2 = function(source, start, length) {
	
	if(this.writePos+length+4 > this.buffer.byteLength)
		this.expandBuffer(this.writePos+length+4)
		
	
	this.writeInt(length)
	
	
	let readPos = start
	let writePos = this.writePos
	let readPosEnd = start + length
	while(readPos < readPosEnd)
		this.dataView.setUint8(writePos++, source.dataView.getUint8(readPos++))
		
	this.writePos = writePos
}
Buffer.prototype.insertArrayBuffer = function(sourceArrayBuffer) {
	let length = sourceArrayBuffer.byteLength
	
	
	if(this.writePos+length > this.buffer.byteLength)
		this.expandBuffer(this.writePos+length)
		
	
	let readPos = 0
	let writePos = this.writePos
	let sourceDataView = new DataView(sourceArrayBuffer)
	while(readPos < length)
		this.dataView.setUint8(writePos++, sourceDataView.getUint8(readPos++))
	this.writePos = writePos
}
Buffer.prototype.copyFromBuffer = function(source) {
	let readPos = 0
	let length = source.writePos
	let writePos = this.writePos
	
	
	if(writePos+length > this.buffer.byteLength)
		this.expandBuffer(writePos+length)
		
	
	let readPosEnd = readPos + length
	while(readPos < readPosEnd)
		this.dataView.setUint8(writePos++, source.dataView.getUint8(readPos++))
		
	this.writePos = writePos
}
Buffer.prototype.set = function(source) {
	let readPos = 0
	let length = source.writePos
	let writePos = 0
	
	
	if(writePos+length > this.buffer.byteLength)
		this.expandBuffer(writePos+length)
		
	
	let readPosEnd = readPos + length
	while(readPos < readPosEnd)
		this.dataView.setUint8(writePos++, source.dataView.getUint8(readPos++))
		
	this.writePos = writePos
}
Buffer.prototype.readInt8 = function() {
	return this.dataView.getInt8(this.readPos++)
}
Buffer.prototype.readUnsignedInt8 = function() {
	return this.dataView.getUint8(this.readPos++)
}
Buffer.prototype.readInt16 = function() {
	let value = this.dataView.getInt16(this.readPos)
	this.readPos += 2
	return value
}
Buffer.prototype.readUnsignedInt16 = function() {
	let value = this.dataView.getUint16(this.readPos)
	this.readPos += 2
	return value
}
Buffer.prototype.readInt32 = function() {
	let value = this.dataView.getInt32(this.readPos)
	this.readPos += 4
	return value
}
Buffer.prototype.readFloat32 = function() {
	let value = this.dataView.getFloat32(this.readPos)
	this.readPos += 4
	return value
}
Buffer.prototype.readFloat64 = function() {
	let value = this.dataView.getFloat64(this.readPos)
	this.readPos += 8
	return value
}
Buffer.prototype.readBool = function() {
	return this.dataView.getInt8(this.readPos++) != 0
}
Buffer.prototype.readBuffer = function(writeBuffer, writeStart) {
	
	let length = this.readInt()
	
	
	if(writeStart+length > writeBuffer.buffer.byteLength)
		writeBuffer.expandBuffer(writeStart+length)
		
	
	let readPos = this.readPos
	let writePos = writeStart
	let readPosEnd = readPos + length
	while(readPos < readPosEnd)
		writeBuffer.dataView.setUint8(writePos++, this.dataView.getUint8(readPos++))
		
	this.readPos = readPos
	writeBuffer.writePos = writePos
	return length
}
Buffer.prototype.toString = function() {
	let result = "readPos:" + this.readPos + " writePos:" + this.writePos
	for(let i=0; i<this.writePos; i ++)
		result += " " + this.dataView.getUint8(i)
	return result
}
Buffer.prototype.toRangeString = function(start, end) {
	let result = ""
	for(let i=start; i<end; i++)
		result += " " + this.dataView.getUint8(i)
	return result
}
Buffer.init = function() {
	Buffer.textEncoder = null;
	Buffer.textDecoder = null;
	Buffer.setupTextEncoder();
}
Buffer.prototype.setup = function(size) {
	if(!this.buffer) this.buffer = new ArrayBuffer(size)
	else this.writePos = this.buffer.byteLength
	this.dataView = new DataView(this.buffer)
}
Buffer.setupTextEncoder = function() {
	Buffer.textEncoder = new TextEncoder
	Buffer.textDecoder = new TextDecoder
}
Buffer.prototype.canRead = function() {
	return this.readPos < this.writePos;
}
Buffer.prototype.toByteArray = function() {
	return new Uint8Array(this.buffer, 0, this.writePos)
}
Buffer.prototype.reset = function() {
	this.writePos = 0;
	this.readPos = 0;
}
Buffer.prototype.rewind = function() {
	this.readPos = 0;
}
Buffer.prototype.expandBuffer = function(size) {
	let prevLength = this.buffer.byteLength
	let len = Math.max(prevLength*2, size)
	this.buffer = new ArrayBuffer(len)
	let prevDataView = this.dataView
	let newDataView = new DataView(this.buffer)
	for(let i=0; i<prevLength; i++)
		newDataView.setInt8(i, prevDataView.getInt8(i))
			
	this.dataView = newDataView
}
Buffer.prototype.equal = function(value) {
	if(this.writePos != value.writePos) return false;
	for(var i=0, len=this.writePos; i<len; i++) {
		if(this.dataView.getUint8(i) != value.dataView.getUint8(i)) {
			return false;
		}
	}
	return true;
}
Buffer.prototype.notEqual = function(value) {
	if(this.writePos != value.writePos) return true;
	for(var i=0, len=this.writePos; i<len; i++) {
		if(this.dataView.getUint8(i) != value.dataView.getUint8(i)) {
			return true;
		}
	}
	return false;
}
Buffer.prototype.checksum = function() {
	let hash = 0;
	for (let i = 0; i < this.writePos; i++) {
		let value = this.dataView.getUint8(i);
		hash = (hash << 5) - hash + value;
		hash |= 0; 
	}
	return hash;
}
Buffer.listToChecksum = function(list) {
	let hash = 0;
	for (let i = 0; i < list.length; i++) {
		let value = list[i];
		hash = (hash << 5) - hash + value;
		hash |= 0; 
	}
	return hash;
}
Buffer.prototype.toList = function() {
	let result = []
	for(let i=0; i<this.writePos; i++)
		result.push(this.dataView.getUint8(i))
	return result
}
Buffer.prototype.clone = function() {
	let clone = new _Buffer();
	clone.readPos = this.readPos;
	clone.writePos = this.writePos;
	clone.buffer = this.buffer;
	clone.dataView = this.dataView;
	return clone;
}
function _Buffer() {};
_Buffer.prototype = Buffer.prototype;
function Time() {
}
Time.init = function() {
	Time.timezoneOffset = 0;
	Time.now = 0.0;
}
Time.toHourMinuteString = function(value, language) {
	var _value, _value2;
	let hour = Math.floor(((_value = 86400000, (value % _value) + _value) % _value) / 3600000);
	let minute = Math.floor(((_value2 = 3600000, (value % _value2) + _value2) % _value2) / 60000);
	if(language == 0/*English*/) {
		return "" + (((((hour - 1) % 12) + 12) % 12) + 1)?.toString() + ":" + ((minute < 10 ? "0" : "")) + minute?.toString() + ((hour < 12 ? " am" : " pm"));
	} else {
		return "" + hour?.toString() + ":" + ((minute < 10 ? "0" : "")) + minute?.toString();
	}
}

Time.fromTimeString = function(timeString) {
	if(!timeString) {
		return 0;
	}
	let value = 0;
	let colon1 = timeString.indexOf(":");
	if(colon1 == -1) {
		value += parseInt(timeString) * 3600000;
	} else {
		value += parseInt(timeString.substring(0, colon1)) * 3600000;
		let colon2 = timeString.indexOf(":", colon1 + 1);
		if(colon2 == -1) {
			value += parseInt(timeString.substring(colon1 + 1)) * 60000;
		} else {
			value += parseInt(timeString.substring(colon1 + 1, colon2)) * 60000;
			value += parseInt(timeString.substring(colon2 + 1)) * 1000;
		}
	}
	return value;
}
Time.toMinutesHoursDaysOrWeeksString = function(time, showWeeksAfterDays) {
	if(time < (2*60000)) {
		return "1 minute";
	}
	if(time < (1*3600000)) {
		return ""+Math.floor(time / 60000) ?.toString()+" minutes";
	}
	if(time < (2*3600000)) {
		return "1 hour";
	}
	if(time < (1*86400000)) {
		return ""+Math.floor(time / 3600000)?.toString()+" hours";
	}
	if(time < (2*86400000)) {
		return "1 day";
	}
	if(time < (showWeeksAfterDays*86400000)) {
		return ""+Math.floor(time / 86400000)?.toString()+" days";
	}
	if(time < (2*604800000)) {
		return "1 week";
	}
	return ""+Math.floor(time / 604800000)?.toString()+" weeks";
}
Time.measure = function($do) {
	let startTime = performance.now();
	$do();
	return performance.now() - startTime;
}
Time.startTimer = function() {
	window._timerStart = performance.now()
}
Time.printTimer = function(text) {
	log(text+": "+(performance.now()-window._timerStart))
}
function _Time() {};
_Time.prototype = Time.prototype;
function TimeString() {
}
TimeString.now = function() {
	return DateTime.fromTime(Time.now, 0).toTimeString();
}
TimeString.fromTime = function(value) {
	return DateTime.fromTime(value, 0).toTimeString();
}
function _TimeString() {};
_TimeString.prototype = TimeString.prototype;
function PlainTimeString() {
}
PlainTimeString.now = function() {
	return DateTime.fromTime(Time.now - Time.timezoneOffset, 0).toPlainTimeString();
}
function _PlainTimeString() {};
_PlainTimeString.prototype = PlainTimeString.prototype;
function DateTime(time, year, month, day, dayOfWeek, hour, minute, second, timezoneOffset) {
	this.time = time;
	this.year = year;
	this.month = month;
	this.day = day;
	this.dayOfWeek = dayOfWeek;
	this.hour = hour;
	this.minute = minute;
	this.second = second;
	this.timezoneOffset = timezoneOffset;
}
DateTime.init = function() {
	DateTime.dayNames = [["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"]];
	DateTime.shortDayNames = [["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"]];
	DateTime.monthNames = [["", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], ["", "Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"]];
	DateTime.shortMonthNames = [["", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["", "Jan", "Feb", "Mär", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"]];
	DateTime.atString = [" at ", " um "];
	DateTime.timeSuffixString = ["", " Uhr"];
	DateTime.daysInMonthCommon = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	DateTime.daysInMonthLeap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
}
DateTime.prototype.twoDigitDay = function() {
	return ((this.day < 10 ? "0" + this.day?.toString() : this.day?.toString()));
}
DateTime.prototype.twoDigitMonth = function() {
	return ((this.month < 10 ? "0" + this.month?.toString() : this.month?.toString()));
}
DateTime.prototype.twoDigitHour = function() {
	return ((this.hour < 10 ? "0" + this.hour?.toString() : this.hour?.toString()));
}
DateTime.prototype.twoDigitMinute = function() {
	return ((this.minute < 10 ? "0" + this.minute?.toString() : this.minute?.toString()));
}
DateTime.prototype.twoDigitSecond = function() {
	return ((this.second < 10 ? "0" + this.second?.toString() : this.second?.toString()));
}
DateTime.now = function() {
	return DateTime.fromTime(Time.now, Time.timezoneOffset);
}
DateTime.fromTimeInSeconds = function(timeInSeconds, outputTimezone) {
	return DateTime.fromTime((timeInSeconds * 1000), outputTimezone);
}
DateTime.fromTime = function(time, outputTimezone) {
	var _value, _value2, _value3;
	if(!time) {
		return new DateTime(0, 1970, 1, 1, 4, 0, 0, 0, 0);
	}
	let outputTime = time - outputTimezone;
	let daysSinceEpoch = Math.floor(outputTime / 86400000);
	let currentYear = 1970;
	let daysLeft = daysSinceEpoch;
	for(;;) {
		let daysInYear = ((((currentYear % 4)) == 0 && ((currentYear % 100)) != 0) || ((currentYear % 400) == 0) ? 366 : 365);
		if(daysLeft < daysInYear) {
			break;
		}
		daysLeft -= daysInYear;
		currentYear++;
	}
	let daysInMonth = ((((currentYear % 4)) == 0 && ((currentYear % 100)) != 0) || ((currentYear % 400) == 0) ? DateTime.daysInMonthLeap : DateTime.daysInMonthCommon);
	let currentMonth = 0;
	while(daysLeft >= daysInMonth[currentMonth]) {
		daysLeft -= daysInMonth[currentMonth];
		currentMonth++;
	}
	return new DateTime(time, currentYear, currentMonth + 1, daysLeft + 1, ((((daysSinceEpoch + 4) % 7) + 7) % 7), Math.floor(((_value = 86400000, (outputTime % _value) + _value) % _value) / 3600000), Math.floor(((_value2 = 3600000, (outputTime % _value2) + _value2) % _value2) / 60000), Math.floor(((_value3 = 60000, (outputTime % _value3) + _value3) % _value3) / 1000), outputTimezone);
}

DateTime.fromValues = function(year, month, day, hour, minute, second, milliseconds, inputTimezone, outputTimezone) {
	let daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	let days = 0;
	for(let i=1970; i<year; ++i) {
		days += (((((i % 4) + 4) % 4) == 0 && (((i % 100) + 100) % 100) != 0) || ((((i % 400) + 400) % 400) == 0) ? 366 : 365);
	}
	for(let i=0; i<month - 1; ++i) {
		days += daysInMonth[i];
	}
	if((month > 2 && ((((year % 4) + 4) % 4) == 0 && (((year % 100) + 100) % 100) != 0) || ((((year % 400) + 400) % 400) == 0))) {
		days += 1;
	}
	days += day - 1;
	milliseconds += days * 24 * 60 * 60 * 1000;
	milliseconds += hour * 60 * 60 * 1000;
	milliseconds += minute * 60 * 1000;
	milliseconds += second * 1000;
	if(inputTimezone == outputTimezone) {
		return new DateTime((milliseconds + inputTimezone), year, month, day, ((((days + 4) % 7) + 7) % 7), hour, minute, second, outputTimezone);
	} else {
		return DateTime.fromTime((milliseconds + inputTimezone), outputTimezone);
	}
}
DateTime.prototype.dayMonthString = function(language) {
	if(language == 1/*German*/) {
		return ""+this.day?.toString()+"."+this.month?.toString()+".";
	} else {
		return ""+this.month?.toString()+"-"+this.day?.toString();
	}
}
DateTime.prototype.dayMonthYearString = function(language) {
	if(language == 1/*German*/) {
		return ""+this.twoDigitDay()+"."+this.twoDigitMonth()+"."+this.year?.toString();
	} else {
		return ""+this.year?.toString()+"-"+this.twoDigitMonth()+"-"+this.twoDigitDay();
	}
}
DateTime.prototype.dayMonthNameYearString = function(language) {
	return ""+this.day?.toString()+" "+DateTime.monthNames[language][this.month]+" "+this.year?.toString();
}
DateTime.prototype.dayShortMonthNameString = function(language) {
	return ""+this.day?.toString()+" "+DateTime.shortMonthNames[language][this.month];
}
DateTime.prototype.dayOfWeekDayMonthNameYearString = function(language) {
	return ""+DateTime.dayNames[language][this.dayOfWeek]+", "+this.day?.toString()+" "+DateTime.monthNames[language][this.month]+" "+this.year?.toString();
}
DateTime.prototype.dayOfWeekDayMonthString = function(language) {
	if(language == 1/*German*/) {
		return ""+DateTime.dayNames[language][this.dayOfWeek]+", "+this.day?.toString()+". "+DateTime.monthNames[language][this.month];
	} else {
		return ""+DateTime.dayNames[language][this.dayOfWeek]+", "+this.day?.toString()+" "+DateTime.monthNames[language][this.month];
	}
}
DateTime.prototype.dayOfWeekString = function(language) {
	return DateTime.dayNames[language][this.dayOfWeek];
}
DateTime.prototype.dayOfWeekShortString = function(language) {
	return DateTime.shortDayNames[language][this.dayOfWeek];
}
DateTime.prototype.hourMinuteString = function(language) {
	if(language == 1/*German*/) {
		return "" + this.hour?.toString() + ":" + ((this.minute < 10 ? "0" : "")) + this.minute?.toString() + " Uhr";
	} else {
		return "" + (((((this.hour - 1) % 12) + 12) % 12) + 1)?.toString() + ":" + ((this.minute < 10 ? "0" : "")) + this.minute?.toString() + ((this.hour < 12 ? " am" : " pm"));
	}
}
DateTime.prototype.dayOfWeekDayMonthAtHourMinuteString = function(language) {
	return this.dayOfWeekDayMonthString(language) + DateTime.atString[language] + this.hourMinuteString(language) + DateTime.timeSuffixString[language];
}
DateTime.prototype.dayOfWeekDayMonthYearHourMinuteString = function(language) {
	return this.dayOfWeekDayMonthNameYearString(language) + ", " + this.hourMinuteString(language);
}
DateTime.prototype.compactString = function() {
	return ""+this.year?.toString()+this.twoDigitMonth()+this.twoDigitDay()+"T"+this.twoDigitHour()+this.twoDigitMinute()+this.twoDigitSecond()+"+02:00";
}
DateTime.fromTimeString = function(timeString) {
	return DateTime.fromIsoString(timeString, Time.timezoneOffset);
}
DateTime.fromTimeString2 = function(timeString) {
	return DateTime.fromIsoString(timeString, 0);
}
DateTime.fromIsoString = function(str, outputTimezone) {
	if(!str || str.length < 19) {
		return null;
	}
	let hasMilliseconds = str[19] == ".";
	let timezoneIndex = (hasMilliseconds ? 24 : 20);
	let timezoneSign = str[timezoneIndex - 1];
	return DateTime.fromValues(parseInt(str.substring(0, 4)), parseInt(str.substring(5, 7)), parseInt(str.substring(8, 10)), parseInt(str.substring(11, 13)), parseInt(str.substring(14, 16)), parseInt(str.substring(17, 19)), (hasMilliseconds ? parseInt(str.substring(20, 23)) : 0), (timezoneSign == "Z" ? 0 : (parseInt(str.substring(timezoneIndex, timezoneIndex + 2))) * 3600000 * ((timezoneSign == "-" ? 1 : -1))), outputTimezone);
}
DateTime.prototype.toPlainTimeString = function() {
	return (""+this.year?.toString()+"-"+this.twoDigitMonth()+"-"+this.twoDigitDay()+" "+this.twoDigitHour()+":"+this.twoDigitMinute()+":"+this.twoDigitSecond());
}
DateTime.prototype.toTimeString = function() {
	return (""+this.year?.toString()+"-"+this.twoDigitMonth()+"-"+this.twoDigitDay()+" "+this.twoDigitHour()+":"+this.twoDigitMinute()+":"+this.twoDigitSecond());
}
DateTime.prototype.clone = function() {
	let clone = new _DateTime();
	clone.time = this.time;
	clone.year = this.year;
	clone.month = this.month;
	clone.day = this.day;
	clone.dayOfWeek = this.dayOfWeek;
	clone.hour = this.hour;
	clone.minute = this.minute;
	clone.second = this.second;
	clone.timezoneOffset = this.timezoneOffset;
	return clone;
}
function _DateTime() {};
_DateTime.prototype = DateTime.prototype;
DateTime.prototype.serialize_internal = function(buffer) {
	buffer.writeFloat64(this.time);
	buffer.writeInt32(this.year);
	buffer.writeInt32(this.month);
	buffer.writeInt32(this.day);
	buffer.writeInt32(this.dayOfWeek);
	buffer.writeInt32(this.hour);
	buffer.writeInt32(this.minute);
	buffer.writeInt32(this.second);
	buffer.writeInt32(this.timezoneOffset);
}
DateTime.prototype.deserialize_internal = function(buffer) {
	this.time = buffer.readFloat64();
	this.year = buffer.readInt32();
	this.month = buffer.readInt32();
	this.day = buffer.readInt32();
	this.dayOfWeek = buffer.readInt32();
	this.hour = buffer.readInt32();
	this.minute = buffer.readInt32();
	this.second = buffer.readInt32();
	this.timezoneOffset = buffer.readInt32();
}
DateTime.prototype.serialize_external = function(buffer) {
	buffer.writeString("time");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.time);
	buffer.writeString("year");
	buffer.writeInt32(4);
	buffer.writeInt32(this.year);
	buffer.writeString("month");
	buffer.writeInt32(4);
	buffer.writeInt32(this.month);
	buffer.writeString("day");
	buffer.writeInt32(4);
	buffer.writeInt32(this.day);
	buffer.writeString("dayOfWeek");
	buffer.writeInt32(4);
	buffer.writeInt32(this.dayOfWeek);
	buffer.writeString("hour");
	buffer.writeInt32(4);
	buffer.writeInt32(this.hour);
	buffer.writeString("minute");
	buffer.writeInt32(4);
	buffer.writeInt32(this.minute);
	buffer.writeString("second");
	buffer.writeInt32(4);
	buffer.writeInt32(this.second);
	buffer.writeString("timezoneOffset");
	buffer.writeInt32(4);
	buffer.writeInt32(this.timezoneOffset);
	buffer.writeString("");
}
DateTime.prototype.deserialize_external = function(buffer) {
	let time_is_set = false, year_is_set = false, month_is_set = false, day_is_set = false, dayOfWeek_is_set = false, hour_is_set = false, minute_is_set = false, second_is_set = false, timezoneOffset_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "time":
				buffer.readInt32();
				this.time = buffer.readFloat64();
				time_is_set = true;
				break;
			case "year":
				buffer.readInt32();
				this.year = buffer.readInt32();
				year_is_set = true;
				break;
			case "month":
				buffer.readInt32();
				this.month = buffer.readInt32();
				month_is_set = true;
				break;
			case "day":
				buffer.readInt32();
				this.day = buffer.readInt32();
				day_is_set = true;
				break;
			case "dayOfWeek":
				buffer.readInt32();
				this.dayOfWeek = buffer.readInt32();
				dayOfWeek_is_set = true;
				break;
			case "hour":
				buffer.readInt32();
				this.hour = buffer.readInt32();
				hour_is_set = true;
				break;
			case "minute":
				buffer.readInt32();
				this.minute = buffer.readInt32();
				minute_is_set = true;
				break;
			case "second":
				buffer.readInt32();
				this.second = buffer.readInt32();
				second_is_set = true;
				break;
			case "timezoneOffset":
				buffer.readInt32();
				this.timezoneOffset = buffer.readInt32();
				timezoneOffset_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!time_is_set) this.time = 0.0;
				if(!year_is_set) this.year = 0;
				if(!month_is_set) this.month = 0;
				if(!day_is_set) this.day = 0;
				if(!dayOfWeek_is_set) this.dayOfWeek = 0;
				if(!hour_is_set) this.hour = 0;
				if(!minute_is_set) this.minute = 0;
				if(!second_is_set) this.second = 0;
				if(!timezoneOffset_is_set) this.timezoneOffset = 0;
				return;
		}
	}
}
Date.init = function() {
	Date.dayStrings = [["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"]];
	Date.shortDayStrings = [["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"]];
}
Date.toTwoDigitString = function(value) {
	return (value < 10 ? "0" + value?.toString() : value?.toString());
}
Date.prototype.dayMonthString = function(language) {
	return this.getDate().toLocaleString('en-US', {minimumIntegerDigits:2})+"."+(this.getMonth()+1).toLocaleString('en-US', {minimumIntegerDigits:2})+"."
}
Date.prototype.dayMonthYearString = function(language) {
	return this.getDate().toLocaleString('en-US', {minimumIntegerDigits:2})+"."+(this.getMonth()+1).toLocaleString('en-US', {minimumIntegerDigits:2})+"."+this.getFullYear()
}
Date.prototype.dayLongMonthNameYearString = function(language) {
	return this.getDate().toLocaleString('en-US', {minimumIntegerDigits:2})+" "+this.toLocaleString('en-US', {month: 'long'})+" "+this.getFullYear()
}
Date.prototype.dayShortMonthNameYearString = function(language) {
	return this.getDate()+" "+this.toLocaleString('en-US', {month: 'short'})+" "+this.getFullYear()
}
Date.prototype.dayOfWeekString = function(language) {
	return Date.dayStrings[language][this.getDay()];
}
Date.prototype.shortDayOfWeekString = function(language) {
	return Date.shortDayStrings[language][this.getDay()];
}
Date.prototype.hourMinuteString = function(language) {
	if(language == 0/*English*/) {
		let h = this.getHours();
		return "" + (((((h - 1) % 12) + 12) % 12) + 1)?.toString() + ":" + Date.toTwoDigitString(this.getMinutes()) + ((h < 12 ? " am" : " pm"));
	} else {
		return "" + this.getHours()?.toString() + ":" + Date.toTwoDigitString(this.getMinutes());
	}
}
Date.prototype.hourMinuteSecondString = function(language) {
	if(language == 0/*English*/) {
		let h = this.getHours();
		return "" + (((((h - 1) % 12) + 12) % 12) + 1)?.toString() + ":" + Date.toTwoDigitString(this.getMinutes()) + ":" + Date.toTwoDigitString(this.getSeconds()) + ((h < 12 ? " am" : " pm"));
	} else {
		return "" + this.getHours()?.toString() + ":" + Date.toTwoDigitString(this.getMinutes()) + ":" + Date.toTwoDigitString(this.getSeconds());
	}
}
Date.prototype.hourMinuteSecondMillisecondString = function(language) {
	return "" + this.getHours()?.toString() + ":" + Date.toTwoDigitString(this.getMinutes()) + ":" + Date.toTwoDigitString(this.getSeconds()) + "." + this.getMilliseconds()?.toString();
}
Date.prototype.dayMonthYearHourMinuteString = function(language) {
	if(language == 1000) return this.getDate().toLocaleString('en-US', {minimumIntegerDigits:2})+"-"+(this.getMonth()+1).toLocaleString('en-US', {minimumIntegerDigits:2})+"-"+this.getFullYear()+" "+this.getHours().toLocaleString('en-US', {minimumIntegerDigits:2})+"-"+this.getMinutes().toLocaleString('en-US', {minimumIntegerDigits:2})
	else return this.getDate().toLocaleString('en-US', {minimumIntegerDigits:2})+"."+(this.getMonth()+1).toLocaleString('en-US', {minimumIntegerDigits:2})+"."+this.getFullYear()+" "+this.getHours().toLocaleString('en-US', {minimumIntegerDigits:2})+":"+this.getMinutes().toLocaleString('en-US', {minimumIntegerDigits:2})
}
Date.prototype.dayMonthYearHourMinuteSecondString = function(language) {
	return this.getDate().toLocaleString('en-US', {minimumIntegerDigits:2})+"."+(this.getMonth()+1).toLocaleString('en-US', {minimumIntegerDigits:2})+"."+this.getFullYear()+" "+this.getHours().toLocaleString('en-US', {minimumIntegerDigits:2})+":"+this.getMinutes().toLocaleString('en-US', {minimumIntegerDigits:2})+":"+this.getSeconds().toLocaleString('en-US', {minimumIntegerDigits:2})
}
Date.prototype.invariantDayMonthYearHourMinuteSecondString = function(language) {
	return this.getDate().toLocaleString('en-US', {minimumIntegerDigits:2})+"-"+(this.getMonth()+1).toLocaleString('en-US', {minimumIntegerDigits:2})+"-"+this.getFullYear()+" "+this.getHours().toLocaleString('en-US', {minimumIntegerDigits:2})+"-"+this.getMinutes().toLocaleString('en-US', {minimumIntegerDigits:2})+"-"+this.getSeconds().toLocaleString('en-US', {minimumIntegerDigits:2})
}
Date.prototype.isoString = function() {
	let tzo = -this.getTimezoneOffset()
	let dif = tzo >= 0 ? '+' : '-'
	
	function pad (num) {
		return (num < 10 ? '0' : '') + num;
	}
	
	return this.getFullYear() +
		"-" + pad(this.getMonth() + 1) +
		"-" + pad(this.getDate()) +
		"T" + pad(this.getHours()) +
		":" + pad(this.getMinutes()) +
		":" + pad(this.getSeconds()) +
		dif + pad(Math.floor(Math.abs(tzo) / 60)) +
		":" + pad(Math.abs(tzo) % 60);
}
var fx; if(!fx) fx = {};
fx.init = function() {
	fx.animations = [];
}
fx.add = function(animation) {
	fx.animations.push(animation);
}
fx.removeForObject = function(object) {
	fx.animations.removeWhere(a => a.object == object);
}
fx.endOfPrevAnimation = function(object) {
	let lastAnimation = fx.animations[fx.animations.length-1];
	if(lastAnimation?.object == object) {
		return Math.max(Time.now, (lastAnimation.startTime + lastAnimation.duration));
	}
	return Time.now;
}
fx.tick = function() {
	let now = Time.now;
	for(let _subject=fx.animations, i=_subject.length-1; i>=0; --i) { let it = _subject[i]; {
		if(now >= it.startTime) {
			let f = (it.duration ? (now - it.startTime) / it.duration : 1);
			if(f >= 1) {
				f = 1;
				fx.animations.splice(i, 1);
			}
			it.tick(f);
		}
	}}
}
fx.delay = function(time, $do) {
	fx.add(new DelayAnimation(Time.now + time, 0.0, null, $do));
}
fx.delay2 = async function(time) {
	return new Promise((resolve, reject) => {
		setTimeout(resolve, time);
	})
}
function Lambda0($do, from, to) {
	this._id = 0;
	this.do = $do;
	this.from = from;
	this.to = to;
}
Lambda0.prototype.invoke = function(progress) {
	this.do.invoke(this.from + (this.to - this.from) * progress);
}
Lambda0.prototype.serialize_internal = function(buffer) {
	let $do = this.do
	if($do) {
		var index = _objectCacheIndex.get($do);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set($do, index = _objectCache.length);
			_objectCache.push($do);
			buffer.writeInt32(-index);
			buffer.writeInt32($do._id);
			$do._objectIndex = index;
			$do.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeFloat64(this.from);
	buffer.writeFloat64(this.to);
}
Lambda0.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this.do = _objectCache[index];
	} else {
		let $do = this.do
		let _id = buffer.readInt32();
		if(!$do || $do._id != _id || $do._objectIndex != -index)
			this.do = $do = new _lambdaContructors[_id]();
		$do._id = _id;
		(_objectCache[-index] = $do).deserialize_internal(buffer);
	}
	this.from = buffer.readFloat64();
	this.to = buffer.readFloat64();
}
Lambda0.prototype.serialize_external = function(buffer) {
	buffer.writeString("do");
	let $do_startPos = buffer.reserveSize();
	let $do = this.do
	if($do) {
		var index = _objectCacheIndex.get($do);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set($do, index = _objectCache.length);
			_objectCache.push($do);
			buffer.writeInt32(-index);
			buffer.writeInt32($do._id);
			$do._objectIndex = index;
			$do.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize($do_startPos);
	buffer.writeString("from");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.from);
	buffer.writeString("to");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.to);
	buffer.writeString("");
}
Lambda0.prototype.deserialize_external = function(buffer) {
	let do_is_set = false, from_is_set = false, to_is_set = false;
	for(;;) {
		switch(buffer.readString()) {
			case "do":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.do = _objectCache[index];
				} else {
					let $do = this.do
					let _id = buffer.readInt32();
					if(!$do || $do._id != _id || $do._objectIndex != -index)
						this.do = $do = new _lambdaContructors[_id]();
					$do._id = _id;
					(_objectCache[-index] = $do).deserialize_external(buffer);
				}
				do_is_set = true;
				break;
			case "from":
				buffer.readInt32();
				this.from = buffer.readFloat64();
				from_is_set = true;
				break;
			case "to":
				buffer.readInt32();
				this.to = buffer.readFloat64();
				to_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				if(!do_is_set) this.do = null;
				if(!from_is_set) this.from = 0.0;
				if(!to_is_set) this.to = 0.0;
				return;
		}
	}
}
function _Lambda0() {
	this._id = 0;
};
_Lambda0.prototype = Lambda0.prototype;
fx.interpolate = function(from, to, $do, delay, duration) {
	fx.add(new InterpolateAnimation(Time.now + delay, duration, null, new Lambda0($do, from, to)));
}
function Lambda1($do, ease, from, to) {
	this._id = 1;
	this.do = $do;
	this.ease = ease;
	this.from = from;
	this.to = to;
}
Lambda1.prototype.invoke = function(progress) {
	this.do.invoke(this.ease.function?.invoke(this.from + (this.to - this.from) * progress));
}
Lambda1.prototype.serialize_internal = function(buffer) {
	let $do = this.do
	if($do) {
		var index = _objectCacheIndex.get($do);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set($do, index = _objectCache.length);
			_objectCache.push($do);
			buffer.writeInt32(-index);
			buffer.writeInt32($do._id);
			$do._objectIndex = index;
			$do.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let ease = this.ease
	if(ease) {
		var index = _objectCacheIndex.get(ease);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(ease, index = _objectCache.length);
			_objectCache.push(ease);
			buffer.writeInt32(-index);
			ease._objectIndex = index;
			ease.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeFloat64(this.from);
	buffer.writeFloat64(this.to);
}
Lambda1.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this.do = _objectCache[index];
	} else {
		let $do = this.do
		let _id = buffer.readInt32();
		if(!$do || $do._id != _id || $do._objectIndex != -index)
			this.do = $do = new _lambdaContructors[_id]();
		$do._id = _id;
		(_objectCache[-index] = $do).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.ease = _objectCache[index];
	} else {
		let ease = this.ease
		if(!ease || ease._objectIndex != -index)
			this.ease = ease = new _EaseFunction();
		(_objectCache[-index] = ease).deserialize_internal(buffer);
	}
	this.from = buffer.readFloat64();
	this.to = buffer.readFloat64();
}
Lambda1.prototype.serialize_external = function(buffer) {
	buffer.writeString("do");
	let $do_startPos = buffer.reserveSize();
	let $do = this.do
	if($do) {
		var index = _objectCacheIndex.get($do);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set($do, index = _objectCache.length);
			_objectCache.push($do);
			buffer.writeInt32(-index);
			buffer.writeInt32($do._id);
			$do._objectIndex = index;
			$do.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize($do_startPos);
	buffer.writeString("ease");
	let ease_startPos = buffer.reserveSize();
	let ease = this.ease
	if(ease) {
		var index = _objectCacheIndex.get(ease);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(ease, index = _objectCache.length);
			_objectCache.push(ease);
			buffer.writeInt32(-index);
			ease._objectIndex = index;
			ease.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(ease_startPos);
	buffer.writeString("from");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.from);
	buffer.writeString("to");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.to);
	buffer.writeString("");
}
Lambda1.prototype.deserialize_external = function(buffer) {
	let do_is_set = false, ease_is_set = false, from_is_set = false, to_is_set = false;
	for(;;) {
		switch(buffer.readString()) {
			case "do":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.do = _objectCache[index];
				} else {
					let $do = this.do
					let _id = buffer.readInt32();
					if(!$do || $do._id != _id || $do._objectIndex != -index)
						this.do = $do = new _lambdaContructors[_id]();
					$do._id = _id;
					(_objectCache[-index] = $do).deserialize_external(buffer);
				}
				do_is_set = true;
				break;
			case "ease":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.ease = _objectCache[index];
				} else {
					let ease = this.ease
					if(!ease || ease._objectIndex != -index)
						this.ease = ease = new _EaseFunction();
					(_objectCache[-index] = ease).deserialize_external(buffer);
				}
				ease_is_set = true;
				break;
			case "from":
				buffer.readInt32();
				this.from = buffer.readFloat64();
				from_is_set = true;
				break;
			case "to":
				buffer.readInt32();
				this.to = buffer.readFloat64();
				to_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				if(!do_is_set) this.do = null;
				if(!ease_is_set) this.ease = null;
				if(!from_is_set) this.from = 0.0;
				if(!to_is_set) this.to = 0.0;
				return;
		}
	}
}
function _Lambda1() {
	this._id = 1;
};
_Lambda1.prototype = Lambda1.prototype;
fx.interpolate2 = function(from, to, $do, delay, duration, ease) {
	fx.add(new InterpolateAnimation(Time.now + delay, duration, null, new Lambda1($do, ease, from, to)));
}
function Lambda2($do, from, to) {
	this._id = 2;
	this.do = $do;
	this.from = from.clone();
	this.to = to.clone();
}
Lambda2.prototype.invoke = function(progress) {
	this.do.invoke(this.from.interpolateTo(this.to, progress));
}
Lambda2.prototype.serialize_internal = function(buffer) {
	let $do = this.do
	if($do) {
		var index = _objectCacheIndex.get($do);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set($do, index = _objectCache.length);
			_objectCache.push($do);
			buffer.writeInt32(-index);
			buffer.writeInt32($do._id);
			$do._objectIndex = index;
			$do.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	(this.from || new _Vector2()).serialize_internal(buffer);
	(this.to || new _Vector2()).serialize_internal(buffer);
}
Lambda2.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this.do = _objectCache[index];
	} else {
		let $do = this.do
		let _id = buffer.readInt32();
		if(!$do || $do._id != _id || $do._objectIndex != -index)
			this.do = $do = new _lambdaContructors[_id]();
		$do._id = _id;
		(_objectCache[-index] = $do).deserialize_internal(buffer);
	}
	(this.from || (this.from = new _Vector2())).deserialize_internal(buffer);
	(this.to || (this.to = new _Vector2())).deserialize_internal(buffer);
}
Lambda2.prototype.serialize_external = function(buffer) {
	buffer.writeString("do");
	let $do_startPos = buffer.reserveSize();
	let $do = this.do
	if($do) {
		var index = _objectCacheIndex.get($do);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set($do, index = _objectCache.length);
			_objectCache.push($do);
			buffer.writeInt32(-index);
			buffer.writeInt32($do._id);
			$do._objectIndex = index;
			$do.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize($do_startPos);
	buffer.writeString("from");
	let from_startPos = buffer.reserveSize();
	(this.from || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(from_startPos);
	buffer.writeString("to");
	let to_startPos = buffer.reserveSize();
	(this.to || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(to_startPos);
	buffer.writeString("");
}
Lambda2.prototype.deserialize_external = function(buffer) {
	let do_is_set = false, from_is_set = false, to_is_set = false;
	for(;;) {
		switch(buffer.readString()) {
			case "do":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.do = _objectCache[index];
				} else {
					let $do = this.do
					let _id = buffer.readInt32();
					if(!$do || $do._id != _id || $do._objectIndex != -index)
						this.do = $do = new _lambdaContructors[_id]();
					$do._id = _id;
					(_objectCache[-index] = $do).deserialize_external(buffer);
				}
				do_is_set = true;
				break;
			case "from":
				buffer.readInt32();
				(this.from || (this.from = new _Vector2())).deserialize_external(buffer);
				from_is_set = true;
				break;
			case "to":
				buffer.readInt32();
				(this.to || (this.to = new _Vector2())).deserialize_external(buffer);
				to_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				if(!do_is_set) this.do = null;
				if(!from_is_set) this.from = new Vector2(0.0, 0.0, null);
				if(!to_is_set) this.to = new Vector2(0.0, 0.0, null);
				return;
		}
	}
}
function _Lambda2() {
	this._id = 2;
};
_Lambda2.prototype = Lambda2.prototype;
fx.interpolate3 = function(from, to, $do, delay, duration) {
	fx.add(new InterpolateAnimation(Time.now + delay, duration, null, new Lambda2($do, from, to)));
}
function Lambda3($do, from, to, ease) {
	this._id = 3;
	this.do = $do;
	this.from = from.clone();
	this.to = to.clone();
	this.ease = ease;
}
Lambda3.prototype.invoke = function(progress) {
	this.do.invoke(this.from.interpolateTo3(this.to, progress, this.ease));
}
Lambda3.prototype.serialize_internal = function(buffer) {
	let $do = this.do
	if($do) {
		var index = _objectCacheIndex.get($do);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set($do, index = _objectCache.length);
			_objectCache.push($do);
			buffer.writeInt32(-index);
			buffer.writeInt32($do._id);
			$do._objectIndex = index;
			$do.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	(this.from || new _Vector2()).serialize_internal(buffer);
	(this.to || new _Vector2()).serialize_internal(buffer);
	let ease = this.ease
	if(ease) {
		var index = _objectCacheIndex.get(ease);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(ease, index = _objectCache.length);
			_objectCache.push(ease);
			buffer.writeInt32(-index);
			ease._objectIndex = index;
			ease.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
Lambda3.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this.do = _objectCache[index];
	} else {
		let $do = this.do
		let _id = buffer.readInt32();
		if(!$do || $do._id != _id || $do._objectIndex != -index)
			this.do = $do = new _lambdaContructors[_id]();
		$do._id = _id;
		(_objectCache[-index] = $do).deserialize_internal(buffer);
	}
	(this.from || (this.from = new _Vector2())).deserialize_internal(buffer);
	(this.to || (this.to = new _Vector2())).deserialize_internal(buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.ease = _objectCache[index];
	} else {
		let ease = this.ease
		if(!ease || ease._objectIndex != -index)
			this.ease = ease = new _EaseFunction();
		(_objectCache[-index] = ease).deserialize_internal(buffer);
	}
}
Lambda3.prototype.serialize_external = function(buffer) {
	buffer.writeString("do");
	let $do_startPos = buffer.reserveSize();
	let $do = this.do
	if($do) {
		var index = _objectCacheIndex.get($do);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set($do, index = _objectCache.length);
			_objectCache.push($do);
			buffer.writeInt32(-index);
			buffer.writeInt32($do._id);
			$do._objectIndex = index;
			$do.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize($do_startPos);
	buffer.writeString("from");
	let from_startPos = buffer.reserveSize();
	(this.from || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(from_startPos);
	buffer.writeString("to");
	let to_startPos = buffer.reserveSize();
	(this.to || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(to_startPos);
	buffer.writeString("ease");
	let ease_startPos = buffer.reserveSize();
	let ease = this.ease
	if(ease) {
		var index = _objectCacheIndex.get(ease);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(ease, index = _objectCache.length);
			_objectCache.push(ease);
			buffer.writeInt32(-index);
			ease._objectIndex = index;
			ease.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(ease_startPos);
	buffer.writeString("");
}
Lambda3.prototype.deserialize_external = function(buffer) {
	let do_is_set = false, from_is_set = false, to_is_set = false, ease_is_set = false;
	for(;;) {
		switch(buffer.readString()) {
			case "do":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.do = _objectCache[index];
				} else {
					let $do = this.do
					let _id = buffer.readInt32();
					if(!$do || $do._id != _id || $do._objectIndex != -index)
						this.do = $do = new _lambdaContructors[_id]();
					$do._id = _id;
					(_objectCache[-index] = $do).deserialize_external(buffer);
				}
				do_is_set = true;
				break;
			case "from":
				buffer.readInt32();
				(this.from || (this.from = new _Vector2())).deserialize_external(buffer);
				from_is_set = true;
				break;
			case "to":
				buffer.readInt32();
				(this.to || (this.to = new _Vector2())).deserialize_external(buffer);
				to_is_set = true;
				break;
			case "ease":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.ease = _objectCache[index];
				} else {
					let ease = this.ease
					if(!ease || ease._objectIndex != -index)
						this.ease = ease = new _EaseFunction();
					(_objectCache[-index] = ease).deserialize_external(buffer);
				}
				ease_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				if(!do_is_set) this.do = null;
				if(!from_is_set) this.from = new Vector2(0.0, 0.0, null);
				if(!to_is_set) this.to = new Vector2(0.0, 0.0, null);
				if(!ease_is_set) this.ease = null;
				return;
		}
	}
}
function _Lambda3() {
	this._id = 3;
};
_Lambda3.prototype = Lambda3.prototype;
fx.interpolate4 = function(from, to, $do, delay, duration, ease) {
	fx.add(new InterpolateAnimation(Time.now + delay, duration, null, new Lambda3($do, from, to, ease)));
}
function Lambda4($do, from, to) {
	this._id = 4;
	this.do = $do;
	this.from = from;
	this.to = to;
}
Lambda4.prototype.invoke = function(progress) {
	this.do.invoke(this.from.interpolateTo(this.to, progress));
}
Lambda4.prototype.serialize_internal = function(buffer) {
	let $do = this.do
	if($do) {
		var index = _objectCacheIndex.get($do);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set($do, index = _objectCache.length);
			_objectCache.push($do);
			buffer.writeInt32(-index);
			buffer.writeInt32($do._id);
			$do._objectIndex = index;
			$do.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let from = this.from
	if(from) {
		var index = _objectCacheIndex.get(from);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(from, index = _objectCache.length);
			_objectCache.push(from);
			buffer.writeInt32(-index);
			from._objectIndex = index;
			from.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let to = this.to
	if(to) {
		var index = _objectCacheIndex.get(to);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(to, index = _objectCache.length);
			_objectCache.push(to);
			buffer.writeInt32(-index);
			to._objectIndex = index;
			to.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
Lambda4.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this.do = _objectCache[index];
	} else {
		let $do = this.do
		let _id = buffer.readInt32();
		if(!$do || $do._id != _id || $do._objectIndex != -index)
			this.do = $do = new _lambdaContructors[_id]();
		$do._id = _id;
		(_objectCache[-index] = $do).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.from = _objectCache[index];
	} else {
		let from = this.from
		if(!from || from._objectIndex != -index)
			this.from = from = new _Color();
		(_objectCache[-index] = from).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.to = _objectCache[index];
	} else {
		let to = this.to
		if(!to || to._objectIndex != -index)
			this.to = to = new _Color();
		(_objectCache[-index] = to).deserialize_internal(buffer);
	}
}
Lambda4.prototype.serialize_external = function(buffer) {
	buffer.writeString("do");
	let $do_startPos = buffer.reserveSize();
	let $do = this.do
	if($do) {
		var index = _objectCacheIndex.get($do);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set($do, index = _objectCache.length);
			_objectCache.push($do);
			buffer.writeInt32(-index);
			buffer.writeInt32($do._id);
			$do._objectIndex = index;
			$do.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize($do_startPos);
	buffer.writeString("from");
	let from_startPos = buffer.reserveSize();
	let from = this.from
	if(from) {
		var index = _objectCacheIndex.get(from);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(from, index = _objectCache.length);
			_objectCache.push(from);
			buffer.writeInt32(-index);
			from._objectIndex = index;
			from.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(from_startPos);
	buffer.writeString("to");
	let to_startPos = buffer.reserveSize();
	let to = this.to
	if(to) {
		var index = _objectCacheIndex.get(to);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(to, index = _objectCache.length);
			_objectCache.push(to);
			buffer.writeInt32(-index);
			to._objectIndex = index;
			to.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(to_startPos);
	buffer.writeString("");
}
Lambda4.prototype.deserialize_external = function(buffer) {
	let do_is_set = false, from_is_set = false, to_is_set = false;
	for(;;) {
		switch(buffer.readString()) {
			case "do":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.do = _objectCache[index];
				} else {
					let $do = this.do
					let _id = buffer.readInt32();
					if(!$do || $do._id != _id || $do._objectIndex != -index)
						this.do = $do = new _lambdaContructors[_id]();
					$do._id = _id;
					(_objectCache[-index] = $do).deserialize_external(buffer);
				}
				do_is_set = true;
				break;
			case "from":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.from = _objectCache[index];
				} else {
					let from = this.from
					if(!from || from._objectIndex != -index)
						this.from = from = new _Color();
					(_objectCache[-index] = from).deserialize_external(buffer);
				}
				from_is_set = true;
				break;
			case "to":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.to = _objectCache[index];
				} else {
					let to = this.to
					if(!to || to._objectIndex != -index)
						this.to = to = new _Color();
					(_objectCache[-index] = to).deserialize_external(buffer);
				}
				to_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				if(!do_is_set) this.do = null;
				if(!from_is_set) this.from = null;
				if(!to_is_set) this.to = null;
				return;
		}
	}
}
function _Lambda4() {
	this._id = 4;
};
_Lambda4.prototype = Lambda4.prototype;
fx.interpolate5 = function(from, to, $do, delay, duration) {
	fx.add(new InterpolateAnimation(Time.now + delay, duration, null, new Lambda4($do, from, to)));
}
fx.defer = function($do) {
	fx.add(new DelayAnimation(Time.now, 0.0, null, $do));
}
function fx_serialize_internal(buffer) {
	let _animations = fx.animations
	if(_animations) {
		var index = _objectCacheIndex.get(_animations);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_animations, index = _objectCache.length);
			_objectCache.push(_animations);
			buffer.writeInt32(-index);
			_animations._objectIndex = index;
			buffer.writeInt32(_animations.length);
			for(let i=0, len=_animations.length; i<len; ++i) {
				let _animations_item = _animations[i]
				if(_animations_item) {
					var index = _objectCacheIndex.get(_animations_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_animations_item, index = _objectCache.length);
						_objectCache.push(_animations_item);
						buffer.writeInt32(-index);
						buffer.writeString(_animations_item.type);
						_animations_item._objectIndex = index;
						_animations_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
function fx_deserialize_internal(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		fx.animations = _objectCache[index];
	} else {
		let _animations = fx.animations
		if(!_animations || _animations._objectIndex != -index) fx.animations = _animations = [];
		_objectCache[-index] = _animations;
		for(let i=0, len = _animations.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_animations[i] = _objectCache[index];
				} else {
					let _animations_item = _animations[i]
					let type = buffer.readString();
					if(!_animations_item || _animations_item._objectIndex != -index)
						_animations[i] = _animations_item = new_Animation_of_type(type);
					_animations_item.type = type;
					(_objectCache[-index] = _animations_item).deserialize_internal(buffer);
				}
		}
	}
}
function fx_serialize_external(buffer) {
	buffer.writeString("animations");
	let _animations = fx.animations
	let _animations_startPos = buffer.reserveSize();
	if(_animations) {
		var index = _objectCacheIndex.get(_animations);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_animations, index = _objectCache.length);
			_objectCache.push(_animations);
			buffer.writeInt32(-index);
			_animations._objectIndex = index;
			buffer.writeInt32(_animations.length);
			for(let i=0, len=_animations.length; i<len; ++i) {
				let _animations_item = _animations[i]
				if(_animations_item) {
					var index = _objectCacheIndex.get(_animations_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_animations_item, index = _objectCache.length);
						_objectCache.push(_animations_item);
						buffer.writeInt32(-index);
						buffer.writeString(_animations_item.type);
						_animations_item._objectIndex = index;
						_animations_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_animations_startPos);
	buffer.writeString("");
}
function fx_deserialize_external(buffer) {
	let animations_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "animations":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					fx.animations = _objectCache[index];
				} else {
					let _animations = fx.animations
					if(!_animations || _animations._objectIndex != -index) fx.animations = _animations = [];
					_objectCache[-index] = _animations;
					for(let i=0, len = _animations.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_animations[i] = _objectCache[index];
							} else {
								let _animations_item = _animations[i]
								let type = buffer.readString();
								if(!_animations_item || _animations_item._objectIndex != -index)
									_animations[i] = _animations_item = new_Animation_of_type(type);
								_animations_item.type = type;
								(_objectCache[-index] = _animations_item).deserialize_external(buffer);
							}
					}
				}
				animations_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!animations_is_set) fx.animations = [];
				return;
		}
	}
}
function Vector2(x, y, location) {
	this.x = x;
	this.y = y;
	this.location = location;
}
Vector2.prototype.toString = function() {
	return ""+this.x.toString()+" "+this.y.toString();
}
Vector2.prototype.toBool = function() {
	return (this.x != Number.POSITIVE_INFINITY || this.y != Number.POSITIVE_INFINITY);
}
Vector2.prototype.clone = function() {
	return new Vector2(this.x, this.y, this.location);
}
Vector2.prototype.assign = function(other) {
	this.x = other.x;
	this.y = other.y;
	this.location = other.location;
	return this;
}
Vector2.prototype.plus = function(other) {
	return new Vector2(this.x + other.x, this.y + other.y, (((this.location || other.location) != null) ? new SourceCodeLocation(null, 0, 0, this.location, other.location) : null));
}
Vector2.prototype.minus = function(other) {
	return new Vector2(this.x - other.x, this.y - other.y, (((this.location || other.location) != null) ? new SourceCodeLocation(null, 0, 0, this.location, other.location) : null));
}
Vector2.prototype.multiply = function(other) {
	return new Vector2(this.x * other.x, this.y * other.y, (((this.location || other.location) != null) ? new SourceCodeLocation(null, 0, 0, this.location, other.location) : null));
}
Vector2.prototype.multiply2 = function(other) {
	return new Vector2(this.x * other, this.y * other, this.location);
}
Vector2.prototype.multiply3 = function(matrix) {
	return new Vector2(matrix.m0 * this.x + matrix.m2 * this.y + matrix.m4, matrix.m1 * this.x + matrix.m3 * this.y + matrix.m5, this.location);
}
Vector2.prototype.divide = function(other) {
	return new Vector2(this.x / other.x, this.y / other.y, (((this.location || other.location) != null) ? new SourceCodeLocation(null, 0, 0, this.location, other.location) : null));
}
Vector2.prototype.divide2 = function(other) {
	return new Vector2(this.x / other, this.y / other, this.location);
}
Vector2.prototype.divide3 = function(matrix) {
	let aa = matrix.m0, ab = matrix.m1, ac = matrix.m2, ad = matrix.m3, atx = matrix.m4, aty = matrix.m5;
	let det = aa * ad - ab * ac;
	if(det == 0) {
		return new Vector2(0, 0, null);
	}
	det = 1.0 / det;
	return new Vector2((ad * det) * this.x + (-ac * det) * this.y + ((ac * aty - ad * atx) * det), (-ab * det) * this.x + (aa * det) * this.y + ((ab * atx - aa * aty) * det), this.location);
}
Vector2.prototype.modulo = function(other) {
	var _value, _value2;
	return new Vector2((_value = other.x, ((this.x % _value) + _value) % _value), (_value2 = other.y, ((this.y % _value2) + _value2) % _value2), (((this.location || other.location) != null) ? new SourceCodeLocation(null, 0, 0, this.location, other.location) : null));
}

Vector2.prototype.modulo2 = function(other) {
	return new Vector2((((this.x % other) + other) % other), (((this.y % other) + other) % other), this.location);
}
Vector2.prototype.plusAssign = function(other) {
	this.x += other.x;
	this.y += other.y;
	if((this.location != null) || (other.location != null)) {
		this.location = new SourceCodeLocation(null, 0, 0, this.location, other.location);
	}
	return this;
}
Vector2.prototype.minusAssign = function(other) {
	this.x -= other.x;
	this.y -= other.y;
	if((this.location != null) || (other.location != null)) {
		this.location = new SourceCodeLocation(null, 0, 0, this.location, other.location);
	}
	return this;
}
Vector2.prototype.multiplyAssign = function(other) {
	this.x *= other.x;
	this.y *= other.y;
	if((this.location != null) || (other.location != null)) {
		this.location = new SourceCodeLocation(null, 0, 0, this.location, other.location);
	}
	return this;
}
Vector2.prototype.multiplyAssign2 = function(other) {
	this.x *= other;
	this.y *= other;
	return this;
}
Vector2.prototype.divideAssign = function(other) {
	this.x /= other.x;
	this.y /= other.y;
	if((this.location != null) || (other.location != null)) {
		this.location = new SourceCodeLocation(null, 0, 0, this.location, other.location);
	}
	return this;
}
Vector2.prototype.divideAssign2 = function(other) {
	this.x /= other;
	this.y /= other;
	return this;
}
Vector2.prototype.equal = function(other) {
	return this.x == other.x && this.y == other.y;
}
Vector2.prototype.equal2 = function(other) {
	return this.x == other.x && this.y == other.y;
}
Vector2.prototype.notEqual = function(other) {
	return this.x != other.x || this.y != other.y;
}
Vector2.prototype.notEqual2 = function(other) {
	return this.x != other.x || this.y != other.y;
}
Vector2.prototype.less = function(other) {
	return this.x < other.x && this.y < other.y;
}
Vector2.prototype.less2 = function(length) {
	return Math.sqrt(this.x * this.x + this.y * this.y) < length;
}
Vector2.prototype.lessOrEqual = function(other) {
	return this.x <= other.x && this.y <= other.y;
}
Vector2.prototype.lessOrEqual2 = function(length) {
	return Math.sqrt(this.x * this.x + this.y * this.y) <= length;
}
Vector2.prototype.greater = function(other) {
	return this.x > other.x && this.y > other.y;
}
Vector2.prototype.greater2 = function(length) {
	return Math.sqrt(this.x * this.x + this.y * this.y) > length;
}
Vector2.prototype.greaterOrEqual = function(other) {
	return this.x >= other.x && this.y >= other.y;
}
Vector2.prototype.greaterOrEqual2 = function(length) {
	return Math.sqrt(this.x * this.x + this.y * this.y) >= length;
}
Vector2.Vector2_minus = function(a) {
	return new Vector2(-a.x, -a.y, a.location);
}
Vector2.prototype.length = function() {
	return Math.sqrt(this.x * this.x + this.y * this.y);
}
Vector2.prototype.sign = function() {
	return new Vector2(Math.sign(this.x), Math.sign(this.y), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 9332, 9367, null, null));
}
Vector2.prototype.lengthSquared = function() {
	return this.x * this.x + this.y * this.y;
}
Vector2.prototype.orthogonal = function() {
	this.x = -this.y;
	this.y = this.x;
	return this;
}
Vector2.prototype.invert = function() {
	this.x = -this.x;
	this.y = -this.y;
	return this;
}
Vector2.prototype.round = function() {
	return new IntVector2(Math.round(this.x), Math.round(this.y), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 9694, 9734, null, null));
}
Vector2.prototype.floor = function() {
	return new IntVector2(Math.floor(this.x), Math.floor(this.y), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 9798, 9838, null, null));
}
Vector2.prototype.ceil = function() {
	return new IntVector2(Math.ceil(this.x), Math.ceil(this.y), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 9900, 9938, null, null));
}
Vector2.prototype.abs = function() {
	this.x = Math.abs(this.x);
	this.y = Math.abs(this.y);
	return this;
}
Vector2.prototype.max = function() {
	return (this.x > this.y ? this.x : this.y);
}
Vector2.prototype.min = function() {
	return (this.x < this.y ? this.x : this.y);
}
Vector2.prototype.move = function(delta) {
	this.x += delta.x;
	this.y += delta.y;
	return this;
}
Vector2.prototype.move2 = function(x, y) {
	this.x += x;
	this.y += y;
	return this;
}
Vector2.prototype.rotate = function(angle) {
	let x = this.x, y = this.y;
	let sn = math.sin(angle);
	let cs = math.cos(angle);
	this.x = x * cs - y * sn;
	this.y = x * sn + y * cs;
	return this;
}
Vector2.prototype.distanceTo = function(value) {
	let x = this.x - value.x;
	let y = this.y - value.y;
	return Math.sqrt(x * x + y * y);
}
Vector2.prototype.manhattanDistanceTo = function(value) {
	return Math.abs(this.x - value.x) + Math.abs(this.y - value.y);
}
Vector2.prototype.angleTo = function(value) {
	return math.getAngleForVector(value.minus(this));
}
Vector2.prototype.normalize = function() {
	let len = Math.sqrt(this.x * this.x + this.y * this.y);
	if(len != 0) {
		this.x = this.x / len;
		this.y = this.y / len;
	}
	return this;
}
Vector2.prototype.normalized = function() {
	return this.clone().normalize();
}
Vector2.prototype.moveTowards = function(targetPosition, speed, onReachedTarget) {
	let delta = targetPosition.minus(this);
	if(delta.x != 0 || delta.y != 0) {
		delta.assign(delta.normalize().multiply2(speed));
		if(delta.x > 0) {
			this.x = Math.min(this.x + delta.x, targetPosition.x);
		} else {
			this.x = Math.max(this.x + delta.x, targetPosition.x);
		}
		if(delta.y > 0) {
			this.y = Math.min(this.y + delta.y, targetPosition.y);
		} else {
			this.y = Math.max(this.y + delta.y, targetPosition.y);
		}
	} else {
		if(onReachedTarget != null) {
			onReachedTarget?.();
		}
	}
}
Vector2.prototype.transform = function(matrix) {
	let ax = this.x, ay = this.y;
	this.x = matrix.m0 * ax + matrix.m2 * ay + matrix.m4;
	this.y = matrix.m1 * ax + matrix.m3 * ay + matrix.m5;
	return this;
}
Vector2.prototype.transformed = function(matrix) {
	return this.clone().transform(matrix);
}
Vector2.prototype.getRelativeTo = function(matrix) {
	let aa = matrix.m0, ab = matrix.m1, ac = matrix.m2, ad = matrix.m3, atx = matrix.m4, aty = matrix.m5;
	let det = aa * ad - ab * ac;
	if(det == 0) {
		return new Vector2(0.0, 0.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 12841, 12850, null, null));
	}
	det = 1.0 / det;
	return new Vector2((ad * det) * this.x + (-ac * det) * this.y + ((ac * aty - ad * atx) * det), (-ab * det) * this.x + (aa * det) * this.y + ((ab * atx - aa * aty) * det), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 12881, 13032, null, null));
}
Vector2.prototype.isInsideRectangle = function(center, size) {
	let halfSizeX = size.x / 2, halfSizeY = size.y / 2;
	return this.x >= center.x - halfSizeX && this.x < center.x + halfSizeX && this.y >= center.y - halfSizeY && this.y < center.y + halfSizeY;
}
Vector2.prototype.isInsidePolygon = function(poly) {
	let c = false, i = -1, l = poly.length, j = l - 1;
	while(++i < l) {
		((poly[i].y <= this.y && this.y < poly[j].y) || (poly[j].y <= this.y && this.y < poly[i].y)) && (this.x < (poly[j].x - poly[i].x) * (this.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x) && (c = !c);
		j = i;
	}
	return c;
}
Vector2.prototype.in = function(rectangle) {
	return this.x >= rectangle.position.x - rectangle.size.x / 2 && this.x < rectangle.position.x + rectangle.size.x / 2 && this.y >= rectangle.position.y - rectangle.size.y / 2 && this.y < rectangle.position.y + rectangle.size.y / 2;
}
Vector2.prototype.dot = function(value) {
	return this.x * value.x + this.y * value.y;
}
Vector2.prototype.cross = function(value) {
	return this.x * value.y - this.y * value.x;
}
Vector2.prototype.serialize = function(buffer) {
	buffer.writeFloat64(this.x);
	buffer.writeFloat64(this.y);
}
Vector2.prototype.deserialize = function(buffer) {
	this.x = buffer.readFloat64();
	this.y = buffer.readFloat64();
}
Vector2.getPathLength = function(path) {
	let length = 0.0;
	for(let i=0, _subject=path, _len=_subject.length-1; i<_len; ++i) { let it = _subject[i], next = _subject[i+1]; {
		length += it.distanceTo(next);
	}}
	return length;
}
Vector2.getPositionAlongPath = function(path, distance) {
	let traveledSoFar = 0.0;
	for(let i=0, _subject=path, _len=_subject.length-1; i<_len; ++i) { let it = _subject[i], next = _subject[i+1]; {
		let segmentLength = it.distanceTo(next);
		let traveledAfterSegment = traveledSoFar + segmentLength;
		if(traveledAfterSegment > distance) {
			return it.interpolateTo5(next, distance, traveledSoFar, traveledAfterSegment);
		}
		traveledSoFar = traveledAfterSegment;
	}}
	return path[path.length-1];
}
Vector2.getPositionAndVectorAlongPath = function(path, distance) {
	let traveledSoFar = 0.0;
	for(let i=0, _subject=path, _len=_subject.length-1; i<_len; ++i) { let it = _subject[i], next = _subject[i+1]; {
		let segmentLength = it.distanceTo(next);
		let traveledAfterSegment = traveledSoFar + segmentLength;
		if(traveledAfterSegment > distance) {
			return new PositionAndVector(it.interpolateTo5(next, distance, traveledSoFar, traveledAfterSegment), next.minus(it));
		}
		traveledSoFar = traveledAfterSegment;
	}}
	let lastPos = path[path.length-1];
	return new PositionAndVector(lastPos, lastPos.minus(path[path.length - 2]));
}
Vector2.prototype.interpolateTo = function(target, progress) {
	if(progress <= 0) {
		return this;
	}
	if(progress >= 1) {
		return target;
	}
	let iprogress = 1 - progress;
	return new Vector2(this.x * iprogress + target.x * progress, this.y * iprogress + target.y * progress, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/interpolate.l", 3618, 3699, null, null));
}
Vector2.prototype.interpolateTo2 = function(target, startTime, duration) {
	let progress = (Time.now - startTime) / duration;
	if(progress <= 0) {
		return this;
	}
	if(progress >= 1) {
		return target;
	}
	let iprogress = 1 - progress;
	return new Vector2(this.x * iprogress + target.x * progress, this.y * iprogress + target.y * progress, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/interpolate.l", 4031, 4112, null, null));
}
Vector2.prototype.interpolateTo3 = function(target, progress, ease) {
	if(progress <= 0) {
		return this;
	}
	if(progress >= 1) {
		return target;
	}
	progress = ease.function?.invoke(progress);
	let iprogress = 1 - progress;
	return new Vector2(this.x * iprogress + target.x * progress, this.y * iprogress + target.y * progress, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/interpolate.l", 4525, 4606, null, null));
}
Vector2.prototype.interpolateTo4 = function(target, startTime, duration, ease) {
	let progress = (Time.now - startTime) / duration;
	if(progress <= 0) {
		return this;
	}
	if(progress >= 1) {
		return target;
	}
	progress = ease.function?.invoke(progress);
	let iprogress = 1 - progress;
	return new Vector2(this.x * iprogress + target.x * progress, this.y * iprogress + target.y * progress, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/interpolate.l", 5006, 5087, null, null));
}
Vector2.prototype.interpolateTo5 = function(target, progress, from, to) {
	if(progress <= from) {
		return this;
	}
	if(progress >= to) {
		return target;
	}
	let factor = (progress - from) / (to - from);
	return new Vector2(this.x + (target.x - this.x) * factor, this.y + (target.y - this.y) * factor, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/interpolate.l", 5689, 5746, null, null));
}
Vector2.prototype.interpolateTo6 = function(target, progress, from, to, ease) {
	if(progress <= from) {
		return this;
	}
	if(progress >= to) {
		return target;
	}
	let factor = ease.function?.invoke((progress - from) / (to - from));
	return new Vector2(this.x + (target.x - this.x) * factor, this.y + (target.y - this.y) * factor, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/interpolate.l", 6438, 6495, null, null));
}
function _Vector2() {};
_Vector2.prototype = Vector2.prototype;
Vector2.prototype.serialize_internal = function(buffer) {
	buffer.writeFloat64(this.x);
	buffer.writeFloat64(this.y);
}
Vector2.prototype.deserialize_internal = function(buffer) {
	this.x = buffer.readFloat64();
	this.y = buffer.readFloat64();
}
Vector2.prototype.serialize_external = function(buffer) {
	buffer.writeString("x");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.x);
	buffer.writeString("y");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.y);
	buffer.writeString("");
}
Vector2.prototype.deserialize_external = function(buffer) {
	let x_is_set = false, y_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "x":
				buffer.readInt32();
				this.x = buffer.readFloat64();
				x_is_set = true;
				break;
			case "y":
				buffer.readInt32();
				this.y = buffer.readFloat64();
				y_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!x_is_set) this.x = 0.0;
				if(!y_is_set) this.y = 0.0;
				return;
		}
	}
}
function Color(hex, name) {
	this.hex = hex;
	this.name = name;
	this.hex = (hex[0] == "#" ? hex : "#" + hex);
}
function Color2(red, green, blue, hex, name) {
	this.hex = hex;
	this.name = name;
	this.hex = "#" + Color.componentToHex(red) + Color.componentToHex(green) + Color.componentToHex(blue);
}
Color2.prototype = Color.prototype;
function Color3(red, green, blue, alpha, hex, name) {
	this.hex = hex;
	this.name = name;
	this.hex = "#" + Color.componentToHex(red) + Color.componentToHex(green) + Color.componentToHex(blue) + Color.componentToHex(alpha);
}
Color3.prototype = Color.prototype;
Color.init = function() {
	Color.White = new Color("#ffffff", "White");
	_constCache.push(Color.White);
	Color.Black = new Color("#000000", "Black");
	_constCache.push(Color.Black);
	Color.Red = new Color("#ef476f", "Red");
	_constCache.push(Color.Red);
	Color.Yellow = new Color("#ffd166", "Yellow");
	_constCache.push(Color.Yellow);
	Color.Green = new Color("#06d6a0", "Green");
	_constCache.push(Color.Green);
	Color.Blue = new Color("#118ab2", "Blue");
	_constCache.push(Color.Blue);
	Color.Gray = new Color("#3d3d3d", "Gray");
	_constCache.push(Color.Gray);
	Color.TransparentRed = new Color("#ff000080", "Transparent Red");
	_constCache.push(Color.TransparentRed);
}
Color.prototype.toString = function() {
	return this.name || this.hex;
}
Color.prototype.red = function() {
	return parseInt(this.hex.substring(1, 3), 16);
}
Color.prototype.green = function() {
	return parseInt(this.hex.substring(3, 5), 16);
}
Color.prototype.blue = function() {
	return parseInt(this.hex.substring(5, 7), 16);
}
Color.prototype.multiply = function(other) {
	return new Color2(Math.floor(this.red() * other), Math.floor(this.green() * other), Math.floor(this.blue() * other), "", "");
}
Color.componentToHex = function(c) {
	var hex = c.toString(16);
	return hex.length == 1 ? "0" + hex : hex;
}
Color.prototype.withAlpha = function(alpha) {
	return new Color(this.hex.substring(1, 7) + Color.componentToHex(Math.floor(alpha * 255)), "");
}
Color.prototype.interpolateTo = function(target, progress) {
	if(progress <= 0) {
		return this;
	}
	if(progress >= 1) {
		return target;
	}
	let iprogress = 1 - progress;
	return new Color2(Math.floor(this.red() * iprogress + target.red() * progress), Math.floor(this.green() * iprogress + target.green() * progress), Math.floor(this.blue() * iprogress + target.blue() * progress), "", "");
}
Color.prototype.clone = function() {
	let clone = new _Color();
	clone.hex = this.hex;
	clone.name = this.name;
	return clone;
}
function _Color() {};
_Color.prototype = Color.prototype;
function Color_serialize_internal(buffer) {
}
function Color_deserialize_internal(buffer) {
}
Color.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.hex);
	buffer.writeString(this.name);
}
Color.prototype.deserialize_internal = function(buffer) {
	this.hex = buffer.readString();
	this.name = buffer.readString();
}
function Color_serialize_external(buffer) {
	buffer.writeString("");
}
function Color_deserialize_external(buffer) {
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				return;
		}
	}
}
Color.prototype.serialize_external = function(buffer) {
	buffer.writeString("hex");
	buffer.writeString(this.hex);
	buffer.writeString("name");
	buffer.writeString(this.name);
	buffer.writeString("");
}
Color.prototype.deserialize_external = function(buffer) {
	let hex_is_set = false, name_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "hex":
				this.hex = buffer.readString();
				hex_is_set = true;
				break;
			case "name":
				this.name = buffer.readString();
				name_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!hex_is_set) this.hex = "";
				if(!name_is_set) this.name = "";
				return;
		}
	}
}
var audio; if(!audio) audio = {};
audio.init = function() {
	audio.volumeLevels = [0, 0.0001, 0.0002, 0.0005, 0.001, 0.002, 0.005, .01, .02, .04, .08, .16, .32, .64, 1];
	audio.volumeLevel = 10;
	audio.volume = audio.volumeLevels[audio.volumeLevel];
	audio.playingSounds = [];
	audio.sounds = [];
}
audio.playSound = function(sound, delay, needsToBeCertain) {
	if(needsToBeCertain && !input.isCertain) {
		return;
	}
	if(core.frame == 0) {
		fx.add(new PlaySoundAnimation((Math.ceil((Time.now + core.frameTime)) + delay), 0.0, null, sound));
	} else {
		if(delay) {
			fx.add(new PlaySoundAnimation(Time.now + delay, 0.0, null, sound));
		} else {
			sound.play(false);
		}
	}
}
audio.playSound2 = function(sound, at, needsToBeCertain) {
	if(needsToBeCertain && !input.isCertain) {
		return;
	}
	if(Time.now >= at && Time.now < Math.floor((at + core.frameTime))) {
		sound.play(false);
	}
}
audio.startFrame = function() {
	for(let i=0, _subject=audio.playingSounds, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		it.isConfirmed = false;
	}}
}
audio.finishFrame = function() {
	for(let i=0, _subject=audio.playingSounds, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(it.frame == core.frame && !it.isConfirmed) {
			it.sound.stop();
		}
	}}
}
audio.reload = function() {
	for(let i=0, _subject=audio.sounds, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		it.preloadForNextPlayback();
	}}
}
audio.stop = function() {
	for(let i=0, _subject=audio.playingSounds, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		it.sound.stop();
	}}
	audio.playingSounds.length = 0;
}
audio.mute = function(forPlayer) {
	if(!(forPlayer != null) || forPlayer.id == input.localUser.id) {
		audio.volumeLevel = 0;
		audio.volume = audio.volumeLevels[audio.volumeLevel];
		for(let i=0, _subject=audio.playingSounds, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			it.sound.updateVolume();
		}}
	}
}
audio.adjustVolume = function(delta, forPlayer) {
	if(!(forPlayer != null) || forPlayer.id == input.localUser.id) {
		audio.volumeLevel = math.limit(audio.volumeLevel + delta, 0, audio.volumeLevels.length - 1);
		audio.volume = audio.volumeLevels[audio.volumeLevel];
		for(let i=0, _subject=audio.playingSounds, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			it.sound.updateVolume();
		}}
	}
}
function Animation(startTime, duration, object) {
	this.type = "Animation";
	this.startTime = startTime;
	this.duration = duration;
	this.object = object;
}
function new_Animation_of_type(type) {
	switch(type) {
		case "Animation": return new _Animation();
		case "FadeAnimation": return new _FadeAnimation();
		case "MoveAnimation": return new _MoveAnimation();
		case "ScaleAnimation": return new _ScaleAnimation();
		case "RotateAnimation": return new _RotateAnimation();
		case "FadeSoundAnimation": return new _FadeSoundAnimation();
		case "PlaySoundAnimation": return new _PlaySoundAnimation();
		case "DelayAnimation": return new _DelayAnimation();
		case "InterpolateAnimation": return new _InterpolateAnimation();
	}
}
Animation.prototype.tick = function(progress) {
}
Animation.prototype.clone = function() {
	let clone = new _Animation();
	clone.type = this.type;
	clone.startTime = this.startTime;
	clone.duration = this.duration;
	clone.object = this.object;
	return clone;
}
function _Animation() {};
_Animation.prototype = Animation.prototype;
Animation.prototype.serialize_internal = function(buffer) {
	buffer.writeFloat64(this.startTime);
	buffer.writeFloat64(this.duration);
	let object = this.object
	if(object) {
		var index = _objectCacheIndex.get(object);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(object, index = _objectCache.length);
			_objectCache.push(object);
			buffer.writeInt32(-index);
			buffer.writeString(object.type);
			object._objectIndex = index;
			object.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
Animation.prototype.deserialize_internal = function(buffer) {
	this.startTime = buffer.readFloat64();
	this.duration = buffer.readFloat64();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.object = _objectCache[index];
	} else {
		let object = this.object
		let type = buffer.readString();
		if(!object || object._objectIndex != -index)
			this.object = object = new_Object_of_type(type);
		object.type = type;
		(_objectCache[-index] = object).deserialize_internal(buffer);
	}
}
Animation.prototype.serialize_external = function(buffer) {
	buffer.writeString("startTime");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.startTime);
	buffer.writeString("duration");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.duration);
	buffer.writeString("object");
	let object_startPos = buffer.reserveSize();
	let object = this.object
	if(object) {
		var index = _objectCacheIndex.get(object);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(object, index = _objectCache.length);
			_objectCache.push(object);
			buffer.writeInt32(-index);
			buffer.writeString(object.type);
			object._objectIndex = index;
			object.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(object_startPos);
	buffer.writeString("");
}
Animation.prototype.deserialize_external = function(buffer) {
	let startTime_is_set = false, duration_is_set = false, object_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "startTime":
				buffer.readInt32();
				this.startTime = buffer.readFloat64();
				startTime_is_set = true;
				break;
			case "duration":
				buffer.readInt32();
				this.duration = buffer.readFloat64();
				duration_is_set = true;
				break;
			case "object":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.object = _objectCache[index];
				} else {
					let object = this.object
					let type = buffer.readString();
					if(!object || object._objectIndex != -index)
						this.object = object = new_Object_of_type(type);
					object.type = type;
					(_objectCache[-index] = object).deserialize_external(buffer);
				}
				object_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!startTime_is_set) this.startTime = 0.0;
				if(!duration_is_set) this.duration = 0.0;
				if(!object_is_set) this.object = null;
				return;
		}
	}
}
function PositionAndVector(position, vector) {
	this.position = position?.clone();
	this.vector = vector?.clone();
}
PositionAndVector.prototype.clone = function() {
	let clone = new _PositionAndVector();
	clone.position = this.position.clone();
	clone.vector = this.vector.clone();
	return clone;
}
function _PositionAndVector() {};
_PositionAndVector.prototype = PositionAndVector.prototype;
PositionAndVector.prototype.serialize_internal = function(buffer) {
	(this.position || new _Vector2()).serialize_internal(buffer);
	(this.vector || new _Vector2()).serialize_internal(buffer);
}
PositionAndVector.prototype.deserialize_internal = function(buffer) {
	(this.position || (this.position = new _Vector2())).deserialize_internal(buffer);
	(this.vector || (this.vector = new _Vector2())).deserialize_internal(buffer);
}
PositionAndVector.prototype.serialize_external = function(buffer) {
	buffer.writeString("position");
	let position_startPos = buffer.reserveSize();
	(this.position || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(position_startPos);
	buffer.writeString("vector");
	let vector_startPos = buffer.reserveSize();
	(this.vector || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(vector_startPos);
	buffer.writeString("");
}
PositionAndVector.prototype.deserialize_external = function(buffer) {
	let position_is_set = false, vector_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "position":
				buffer.readInt32();
				(this.position || (this.position = new _Vector2())).deserialize_external(buffer);
				position_is_set = true;
				break;
			case "vector":
				buffer.readInt32();
				(this.vector || (this.vector = new _Vector2())).deserialize_external(buffer);
				vector_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!position_is_set) this.position = new Vector2(0.0, 0.0, null);
				if(!vector_is_set) this.vector = new Vector2(0.0, 0.0, null);
				return;
		}
	}
}
function Path(nodes, segmentLengths, length) {
	this.nodes = nodes;
	this.segmentLengths = segmentLengths;
	this.length = length;
	this.update();
}
Path.prototype.first = function() {
	return ((this.nodes != null && this.nodes.length != 0)  ? this.nodes[0] : new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null));
}
Path.prototype.last = function() {
	return ((this.nodes != null && this.nodes.length != 0)  ? this.nodes[this.nodes.length-1] : new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null));
}
Path.prototype.count = function() {
	return this.nodes.length;
}
Path.prototype.update = function() {
	this.length = 0;
	for(let i=0, _subject=this.nodes, _len=_subject.length-1; i<_len; ++i) { let it = _subject[i], next = _subject[i+1]; {
		let x = next.x - it.x;
		let y = next.y - it.y;
		this.length += this.segmentLengths[i] = Math.sqrt(x * x + y * y);
	}}
}
Path.prototype.getPosition = function(distance) {
	if(this.nodes.length == 0) {
		return new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null);
	}
	if(this.nodes.length == 1) {
		return this.nodes[0];
	}
	let travelledSoFar = 0.0;
	for(let i=0, _subject=this.nodes, _len=_subject.length-1; i<_len; ++i) { let it = _subject[i], next = _subject[i+1]; {
		let segmentLength = this.segmentLengths[i];
		let travelledAfterSegment = travelledSoFar + segmentLength;
		if(travelledAfterSegment >= distance) {
			let factor = (distance - travelledSoFar) / segmentLength;
			return new Vector2(it.x + (next.x - it.x) * factor, it.y + (next.y - it.y) * factor, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 16505, 16559, null, null));
		}
		travelledSoFar = travelledAfterSegment;
	}}
	return this.nodes[this.nodes.length-1];
}
Path.prototype.getPositionAndVector = function(distance) {
	if(this.nodes.length == 0) {
		return new PositionAndVector(new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null), new Vector2(0.0, 0.0, null));
	}
	if(this.nodes.length == 1) {
		return new PositionAndVector(this.nodes[0], new Vector2(0.0, 0.0, null));
	}
	let travelledSoFar = 0.0;
	for(let i=0, _subject=this.nodes, _len=_subject.length-1; i<_len; ++i) { let it = _subject[i], next = _subject[i+1]; {
		let segmentLength = this.segmentLengths[i];
		let travelledAfterSegment = travelledSoFar + segmentLength;
		if(travelledAfterSegment >= distance) {
			let factor = (distance - travelledSoFar) / segmentLength;
			return new PositionAndVector(new Vector2(it.x + (next.x - it.x) * factor, it.y + (next.y - it.y) * factor, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 17157, 17211, null, null)), next.minus(it));
		}
		travelledSoFar = travelledAfterSegment;
	}}
	let lastPos = this.nodes[this.nodes.length-1];
	return new PositionAndVector(lastPos, lastPos.minus(this.nodes[this.nodes.length - 2]));
}
Path.prototype.clone = function() {
	let clone = new _Path();
	clone.nodes = this.nodes;
	clone.segmentLengths = this.segmentLengths;
	clone.length = this.length;
	return clone;
}
function _Path() {};
_Path.prototype = Path.prototype;
Path.prototype.serialize_internal = function(buffer) {
	let nodes = this.nodes
	if(nodes) {
		var index = _objectCacheIndex.get(nodes);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(nodes, index = _objectCache.length);
			_objectCache.push(nodes);
			buffer.writeInt32(-index);
			nodes._objectIndex = index;
			buffer.writeInt32(nodes.length);
			for(let i=0, len=nodes.length; i<len; ++i) {
				(nodes[i] || new _Vector2()).serialize_internal(buffer);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let segmentLengths = this.segmentLengths
	if(segmentLengths) {
		var index = _objectCacheIndex.get(segmentLengths);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(segmentLengths, index = _objectCache.length);
			_objectCache.push(segmentLengths);
			buffer.writeInt32(-index);
			segmentLengths._objectIndex = index;
			buffer.writeInt32(segmentLengths.length);
			for(let i=0, len=segmentLengths.length; i<len; ++i) {
				buffer.writeFloat64(segmentLengths[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeFloat64(this.length);
}
Path.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this.nodes = _objectCache[index];
	} else {
		let nodes = this.nodes
		if(!nodes || nodes._objectIndex != -index) this.nodes = nodes = [];
		_objectCache[-index] = nodes;
		for(let i=0, len = nodes.length = buffer.readInt32(); i<len; ++i) {
				(nodes[i] || (nodes[i] = new _Vector2())).deserialize_internal(buffer);
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.segmentLengths = _objectCache[index];
	} else {
		let segmentLengths = this.segmentLengths
		if(!segmentLengths || segmentLengths._objectIndex != -index) this.segmentLengths = segmentLengths = [];
		_objectCache[-index] = segmentLengths;
		for(let i=0, len = segmentLengths.length = buffer.readInt32(); i<len; ++i) {
				segmentLengths[i] = buffer.readFloat64();
		}
	}
	this.length = buffer.readFloat64();
}
Path.prototype.serialize_external = function(buffer) {
	buffer.writeString("nodes");
	let nodes = this.nodes
	let nodes_startPos = buffer.reserveSize();
	if(nodes) {
		var index = _objectCacheIndex.get(nodes);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(nodes, index = _objectCache.length);
			_objectCache.push(nodes);
			buffer.writeInt32(-index);
			nodes._objectIndex = index;
			buffer.writeInt32(nodes.length);
			for(let i=0, len=nodes.length; i<len; ++i) {
				(nodes[i] || new _Vector2()).serialize_external(buffer);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(nodes_startPos);
	buffer.writeString("segmentLengths");
	let segmentLengths = this.segmentLengths
	let segmentLengths_startPos = buffer.reserveSize();
	if(segmentLengths) {
		var index = _objectCacheIndex.get(segmentLengths);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(segmentLengths, index = _objectCache.length);
			_objectCache.push(segmentLengths);
			buffer.writeInt32(-index);
			segmentLengths._objectIndex = index;
			buffer.writeInt32(segmentLengths.length);
			for(let i=0, len=segmentLengths.length; i<len; ++i) {
				buffer.writeFloat64(segmentLengths[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(segmentLengths_startPos);
	buffer.writeString("length");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.length);
	buffer.writeString("");
}
Path.prototype.deserialize_external = function(buffer) {
	let nodes_is_set = false, segmentLengths_is_set = false, length_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "nodes":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.nodes = _objectCache[index];
				} else {
					let nodes = this.nodes
					if(!nodes || nodes._objectIndex != -index) this.nodes = nodes = [];
					_objectCache[-index] = nodes;
					for(let i=0, len = nodes.length = buffer.readInt32(); i<len; ++i) {
							(nodes[i] || (nodes[i] = new _Vector2())).deserialize_external(buffer);
					}
				}
				nodes_is_set = true;
				break;
			case "segmentLengths":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.segmentLengths = _objectCache[index];
				} else {
					let segmentLengths = this.segmentLengths
					if(!segmentLengths || segmentLengths._objectIndex != -index) this.segmentLengths = segmentLengths = [];
					_objectCache[-index] = segmentLengths;
					for(let i=0, len = segmentLengths.length = buffer.readInt32(); i<len; ++i) {
							segmentLengths[i] = buffer.readFloat64();
					}
				}
				segmentLengths_is_set = true;
				break;
			case "length":
				buffer.readInt32();
				this.length = buffer.readFloat64();
				length_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!nodes_is_set) this.nodes = [];
				if(!segmentLengths_is_set) this.segmentLengths = [];
				if(!length_is_set) this.length = 0.0;
				return;
		}
	}
}
function IntVector2(x, y, location) {
	this.x = x;
	this.y = y;
	this.location = location;
}
IntVector2.prototype.clone = function() {
	return new IntVector2(this.x, this.y, this.location);
}
IntVector2.prototype.toString = function() {
	return "("+this.x?.toString()+" "+this.y?.toString()+")";
}
IntVector2.prototype.toBool = function() {
	return (this.x != int.minValue || this.y != int.minValue);
}
IntVector2.prototype.toVector2 = function() {
	return new Vector2(this.x, this.y, this.location);
}
IntVector2.prototype.assign = function(other) {
	this.x = other.x;
	this.y = other.y;
	this.location = other.location;
	return this;
}
IntVector2.prototype.plus = function(other) {
	return new IntVector2(this.x + other.x, this.y + other.y, (((this.location || other.location) != null) ? new SourceCodeLocation(null, 0, 0, this.location, other.location) : null));
}
IntVector2.prototype.plus2 = function(other) {
	return new Vector2(this.x + other.x, this.y + other.y, (((this.location || other.location) != null) ? new SourceCodeLocation(null, 0, 0, this.location, other.location) : null));
}
IntVector2.prototype.minus = function(other) {
	return new IntVector2(this.x - other.x, this.y - other.y, (((this.location || other.location) != null) ? new SourceCodeLocation(null, 0, 0, this.location, other.location) : null));
}
IntVector2.prototype.minus2 = function(other) {
	return new Vector2(this.x - other.x, this.y - other.y, (((this.location || other.location) != null) ? new SourceCodeLocation(null, 0, 0, this.location, other.location) : null));
}
IntVector2.prototype.multiply = function(other) {
	return new IntVector2(this.x * other.x, this.y * other.y, (((this.location || other.location) != null) ? new SourceCodeLocation(null, 0, 0, this.location, other.location) : null));
}
IntVector2.prototype.multiply2 = function(other) {
	return new Vector2(this.x * other.x, this.y * other.y, (((this.location || other.location) != null) ? new SourceCodeLocation(null, 0, 0, this.location, other.location) : null));
}
IntVector2.prototype.multiply3 = function(other) {
	return new IntVector2(this.x * other, this.y * other, this.location);
}
IntVector2.prototype.multiply4 = function(other) {
	return new Vector2(this.x * other, this.y * other, this.location);
}
IntVector2.prototype.divide = function(other) {
	return new Vector2(this.x / other.x, this.y / other.y, (((this.location || other.location) != null) ? new SourceCodeLocation(null, 0, 0, this.location, other.location) : null));
}
IntVector2.prototype.divide2 = function(other) {
	return new Vector2(this.x / other, this.y / other, this.location);
}
IntVector2.prototype.modulo = function(other) {
	var _value, _value2;
	return new IntVector2((_value = other.x, ((this.x % _value) + _value) % _value), (_value2 = other.y, ((this.y % _value2) + _value2) % _value2), (((this.location || other.location) != null) ? new SourceCodeLocation(null, 0, 0, this.location, other.location) : null));
}

IntVector2.prototype.modulo2 = function(other) {
	return new IntVector2((((this.x % other) + other) % other), (((this.y % other) + other) % other), this.location);
}
IntVector2.prototype.plusAssign = function(other) {
	this.x += other.x;
	this.y += other.y;
	if((this.location != null) || (other.location != null)) {
		this.location = new SourceCodeLocation(null, 0, 0, this.location, other.location);
	}
	return this;
}
IntVector2.prototype.minusAssign = function(other) {
	this.x -= other.x;
	this.y -= other.y;
	if((this.location != null) || (other.location != null)) {
		this.location = new SourceCodeLocation(null, 0, 0, this.location, other.location);
	}
	return this;
}
IntVector2.prototype.multiplyAssign = function(other) {
	this.x *= other.x;
	this.y *= other.y;
	if((this.location != null) || (other.location != null)) {
		this.location = new SourceCodeLocation(null, 0, 0, this.location, other.location);
	}
	return this;
}
IntVector2.prototype.multiplyAssign2 = function(other) {
	this.x *= other;
	this.y *= other;
	return this;
}
IntVector2.prototype.divideAssign = function(other) {
	this.x /= other.x;
	this.y /= other.y;
	if((this.location != null) || (other.location != null)) {
		this.location = new SourceCodeLocation(null, 0, 0, this.location, other.location);
	}
	return this?.toVector2();
}
IntVector2.prototype.divideAssign2 = function(other) {
	this.x /= other;
	this.y /= other;
	return this?.toVector2();
}
IntVector2.prototype.equal = function(other) {
	return this.x == other.x && this.y == other.y;
}
IntVector2.prototype.notEqual = function(other) {
	return this.x != other.x || this.y != other.y;
}
IntVector2.prototype.less = function(other) {
	return this.x < other.x && this.y < other.y;
}
IntVector2.prototype.less2 = function(length) {
	return Math.sqrt(this.x * this.x + this.y * this.y) < length;
}
IntVector2.prototype.lessOrEqual = function(other) {
	return this.x <= other.x && this.y <= other.y;
}
IntVector2.prototype.lessOrEqual2 = function(length) {
	return Math.sqrt(this.x * this.x + this.y * this.y) <= length;
}
IntVector2.prototype.greater = function(other) {
	return this.x > other.x && this.y > other.y;
}
IntVector2.prototype.greater2 = function(length) {
	return Math.sqrt(this.x * this.x + this.y * this.y) > length;
}
IntVector2.prototype.greaterOrEqual = function(other) {
	return this.x >= other.x && this.y >= other.y;
}
IntVector2.prototype.greaterOrEqual2 = function(length) {
	return Math.sqrt(this.x * this.x + this.y * this.y) >= length;
}
IntVector2.prototype.length = function() {
	return Math.sqrt(this.x * this.x + this.y * this.y);
}
IntVector2.prototype.orthogonal = function() {
	return new IntVector2(-this.y, this.x, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 24245, 24266, null, null));
}
IntVector2.prototype.inverse = function() {
	return new IntVector2(-this.x, -this.y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 24336, 24354, null, null));
}
IntVector2.prototype.abs = function() {
	return new IntVector2(Math.abs(this.x), Math.abs(this.y), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 24422, 24458, null, null));
}
IntVector2.prototype.max = function() {
	return (this.x > this.y ? this.x : this.y);
}
IntVector2.prototype.min = function() {
	return (this.x < this.y ? this.x : this.y);
}
IntVector2.prototype.limit = function(min, max) {
	return new IntVector2(math.limit(this.x, min.x, max.x), math.limit(this.y, min.y, max.y), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 24639, 24730, null, null));
}
IntVector2.prototype.limit2 = function(max) {
	return new IntVector2(math.limit2(this.x, max.x), math.limit2(this.y, max.y), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 24766, 24835, null, null));
}
IntVector2.prototype.limit3 = function(min) {
	return new IntVector2(math.limit3(this.x, min.x), math.limit3(this.y, min.y), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 24871, 24940, null, null));
}
IntVector2.prototype.distanceTo = function(value) {
	let x = this.x - value.x;
	let y = this.y - value.y;
	return Math.sqrt(x * x + y * y);
}
IntVector2.prototype.distanceTo2 = function(value) {
	let x = this.x - value.x;
	let y = this.y - value.y;
	return Math.sqrt(x * x + y * y);
}
IntVector2.prototype.manhattanDistanceTo = function(value) {
	return Math.abs(this.x - value.x) + Math.abs(this.y - value.y);
}
IntVector2.prototype.isInsideRectangle = function(center, size) {
	return this.x >= center.x - size.x / 2 && this.x < center.x + size.x / 2 && this.y >= center.y - size.y / 2 && this.y < center.y + size.y / 2;
}
IntVector2.prototype.angleTo = function(value) {
	return math.getAngleForVector(value.minus(this)?.toVector2());
}
IntVector2.prototype.normalized = function() {
	let len = Math.sqrt(this.x * this.x + this.y * this.y);
	return (len != 0 ? new Vector2(this.x / len, this.y / len, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 26072, 26097, null, null)) : new Vector2(0, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 26100, 26113, null, null)));
}
IntVector2.enumerate = function(from, to, selector) {
	let result = []
	for(let y=from.y; y < to.y; ++y)
		for(let x=from.x; x < to.x; ++x)
			result.push(selector(new IntVector2(x,y)))
	return result
}
function _IntVector2() {};
_IntVector2.prototype = IntVector2.prototype;
IntVector2.prototype.serialize_internal = function(buffer) {
	buffer.writeInt32(this.x);
	buffer.writeInt32(this.y);
}
IntVector2.prototype.deserialize_internal = function(buffer) {
	this.x = buffer.readInt32();
	this.y = buffer.readInt32();
}
IntVector2.prototype.serialize_external = function(buffer) {
	buffer.writeString("x");
	buffer.writeInt32(4);
	buffer.writeInt32(this.x);
	buffer.writeString("y");
	buffer.writeInt32(4);
	buffer.writeInt32(this.y);
	buffer.writeString("");
}
IntVector2.prototype.deserialize_external = function(buffer) {
	let x_is_set = false, y_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "x":
				buffer.readInt32();
				this.x = buffer.readInt32();
				x_is_set = true;
				break;
			case "y":
				buffer.readInt32();
				this.y = buffer.readInt32();
				y_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!x_is_set) this.x = 0;
				if(!y_is_set) this.y = 0;
				return;
		}
	}
}
function Matrix2D(m0, m1, m2, m3, m4, m5) {
	this.m0 = m0;
	this.m1 = m1;
	this.m2 = m2;
	this.m3 = m3;
	this.m4 = m4;
	this.m5 = m5;
}
Matrix2D.prototype.clear = function() {
	this.m0 = 1.0;
	this.m1 = 0.0;
	this.m2 = 0.0;
	this.m3 = 1.0;
	this.m4 = 0.0;
	this.m5 = 0.0;
}
Matrix2D.prototype.set = function(m0, m1, m2, m3, m4, m5) {
	this.m0 = m0;
	this.m1 = m1;
	this.m2 = m2;
	this.m3 = m3;
	this.m4 = m4;
	this.m5 = m5;
}
Matrix2D.prototype.clone = function() {
	return new Matrix2D(this.m0, this.m1, this.m2, this.m3, this.m4, this.m5);
}
Matrix2D.prototype.assign = function(other) {
	this.m0 = other.m0;
	this.m1 = other.m1;
	this.m2 = other.m2;
	this.m3 = other.m3;
	this.m4 = other.m4;
	this.m5 = other.m5;
	return this;
}
Matrix2D.prototype.multiply = function(other) {
	let c = new Matrix2D(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
	return Matrix2D.multiply(this, other, c);
}
Matrix2D.prototype.multiplyAssign = function(other) {
	return Matrix2D.multiply(this, other, this);
}
Matrix2D.prototype.translationVector = function() {
	return new Vector2(this.m4, this.m5, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 27565, 27573, null, null));
}
Matrix2D.prototype.scaleVector = function() {
	return new Vector2(this.m0, this.m3, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 27645, 27653, null, null));
}
Matrix2D.prototype.toString = function() {
	return "(" + this.m0.toLocaleString("en-US", {maximumFractionDigits:1, minimumFractionDigits:1, minimumIntegerDigits:1, useGrouping:false}) + " " + this.m1.toLocaleString("en-US", {maximumFractionDigits:1, minimumFractionDigits:1, minimumIntegerDigits:1, useGrouping:false}) + " " + this.m2.toLocaleString("en-US", {maximumFractionDigits:1, minimumFractionDigits:1, minimumIntegerDigits:1, useGrouping:false}) + " " + this.m3.toLocaleString("en-US", {maximumFractionDigits:1, minimumFractionDigits:1, minimumIntegerDigits:1, useGrouping:false}) + " " + this.m4.toLocaleString("en-US", {maximumFractionDigits:1, minimumFractionDigits:1, minimumIntegerDigits:1, useGrouping:false}) + " " + this.m5.toLocaleString("en-US", {maximumFractionDigits:1, minimumFractionDigits:1, minimumIntegerDigits:1, useGrouping:false}) + ")";
}
Matrix2D.prototype.toBool = function() {
	return (this.m0 != 1 || this.m1 != 0 || this.m2 != 0 || this.m3 != 1 || this.m4 != 0 || this.m5 != 0);
}
Matrix2D.prototype.move = function(vector) {
	let x = vector.x, y = vector.y;
	this.m4 += this.m0 * x + this.m2 * y;
	this.m5 += this.m1 * x + this.m3 * y;
	return this;
}
Matrix2D.prototype.rotate = function(angle) {
	let a0 = this.m0, a1 = this.m1, a2 = this.m2, a3 = this.m3;
	let sin = math.sin(angle), cos = math.cos(angle);
	this.m0 = a0 * cos + a2 * sin;
	this.m1 = a1 * cos + a3 * sin;
	this.m2 = a0 * -sin + a2 * cos;
	this.m3 = a1 * -sin + a3 * cos;
	return this;
}
Matrix2D.prototype.scale = function(vector) {
	let x = vector.x, y = vector.y;
	this.m0 *= x;
	this.m1 *= x;
	this.m2 *= y;
	this.m3 *= y;
	return this;
}
Matrix2D.prototype.multiplyRight = function(value) {
	return Matrix2D.multiply(this, value, this);
}
Matrix2D.prototype.multiplyLeft = function(value) {
	return Matrix2D.multiply(value, this, this);
}
Matrix2D.multiply = function(left, right, result) {
	let a0 = left.m0, a2 = left.m2, a4 = left.m4;
	let a1 = left.m1, a3 = left.m3, a5 = left.m5;
	let b0 = right.m0, b2 = right.m2, b4 = right.m4;
	let b1 = right.m1, b3 = right.m3, b5 = right.m5;
	result.m0 = b0 * a0 + b2 * a1;
	result.m2 = b0 * a2 + b2 * a3;
	result.m4 = b0 * a4 + b2 * a5 + b4;
	result.m1 = b1 * a0 + b3 * a1;
	result.m3 = b1 * a2 + b3 * a3;
	result.m5 = b1 * a4 + b3 * a5 + b5;
	return result;
}
function _Matrix2D() {};
_Matrix2D.prototype = Matrix2D.prototype;
Matrix2D.prototype.serialize_internal = function(buffer) {
	buffer.writeFloat64(this.m0);
	buffer.writeFloat64(this.m1);
	buffer.writeFloat64(this.m2);
	buffer.writeFloat64(this.m3);
	buffer.writeFloat64(this.m4);
	buffer.writeFloat64(this.m5);
}
Matrix2D.prototype.deserialize_internal = function(buffer) {
	this.m0 = buffer.readFloat64();
	this.m1 = buffer.readFloat64();
	this.m2 = buffer.readFloat64();
	this.m3 = buffer.readFloat64();
	this.m4 = buffer.readFloat64();
	this.m5 = buffer.readFloat64();
}
Matrix2D.prototype.serialize_external = function(buffer) {
	buffer.writeString("m0");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.m0);
	buffer.writeString("m1");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.m1);
	buffer.writeString("m2");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.m2);
	buffer.writeString("m3");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.m3);
	buffer.writeString("m4");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.m4);
	buffer.writeString("m5");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.m5);
	buffer.writeString("");
}
Matrix2D.prototype.deserialize_external = function(buffer) {
	let m0_is_set = false, m1_is_set = false, m2_is_set = false, m3_is_set = false, m4_is_set = false, m5_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "m0":
				buffer.readInt32();
				this.m0 = buffer.readFloat64();
				m0_is_set = true;
				break;
			case "m1":
				buffer.readInt32();
				this.m1 = buffer.readFloat64();
				m1_is_set = true;
				break;
			case "m2":
				buffer.readInt32();
				this.m2 = buffer.readFloat64();
				m2_is_set = true;
				break;
			case "m3":
				buffer.readInt32();
				this.m3 = buffer.readFloat64();
				m3_is_set = true;
				break;
			case "m4":
				buffer.readInt32();
				this.m4 = buffer.readFloat64();
				m4_is_set = true;
				break;
			case "m5":
				buffer.readInt32();
				this.m5 = buffer.readFloat64();
				m5_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!m0_is_set) this.m0 = 1.0;
				if(!m1_is_set) this.m1 = 0.0;
				if(!m2_is_set) this.m2 = 0.0;
				if(!m3_is_set) this.m3 = 1.0;
				if(!m4_is_set) this.m4 = 0.0;
				if(!m5_is_set) this.m5 = 0.0;
				return;
		}
	}
}
function Angle() {
}
Angle.rotatedTowards = function(value, target, speed) {
	var _value, _value2;
	let delta = (_value2 = 1, ((((_value = 1, ((target - value + .5) % _value) + _value) % _value) + 1) % _value2) + _value2) % _value2 - .5;
	let valuePlusDelta = value + delta;
	if(delta > 0) {
		value += speed;
		return (value < valuePlusDelta ? value : target);
	} else {
		value -= speed;
		return (value > valuePlusDelta ? value : target);
	}
}

function _Angle() {};
_Angle.prototype = Angle.prototype;
function IsometicGrid(size, cellSize, topFaceOffset) {
	this.size = size?.clone();
	this.cellSize = cellSize?.clone();
	this.topFaceOffset = topFaceOffset?.clone();
	this.xOffset = this.cellSize.divide2(2)?.clone();
	this.yOffset = new Vector2(-this.xOffset.x, this.xOffset.y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 47937, 47960, null, null));
	this.basePos = new Vector2(0, -this.yOffset.y * (this.size.y - 1), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 47988, 48013, null, null));
}
IsometicGrid.prototype.getScreenPosition = function(worldPos) {
	return this.basePos.plus(this.xOffset.multiply2(worldPos.x)).plus(this.yOffset.multiply2(worldPos.y));
}
IsometicGrid.prototype.getWorldPosition = function(screenPos, allowOutside) {
	let t = screenPos.minus(this.basePos).plus(this.topFaceOffset);
	let x = (this.xOffset.x * t.y + this.xOffset.y * t.x) / (2 * this.xOffset.x * this.xOffset.y);
	let y = (this.xOffset.x * t.y - this.xOffset.y * t.x) / (2 * this.xOffset.x * this.xOffset.y);
	if(allowOutside || (x >= 0 && x < this.size.x && y >= 0 && y < this.size.y)) {
		return new Vector2(x, y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 48660, 48672, null, null));
	} else {
		return new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null);
	}
}
IsometicGrid.prototype.getGridPosition = function(screenPos, allowOutside) {
	let t = screenPos.minus(this.basePos).plus(this.topFaceOffset);
	let x = Math.round((this.xOffset.x * t.y + this.xOffset.y * t.x) / (2 * this.xOffset.x * this.xOffset.y));
	let y = Math.round((this.xOffset.x * t.y - this.xOffset.y * t.x) / (2 * this.xOffset.x * this.xOffset.y));
	if(allowOutside || (x >= 0 && x < this.size.x && y >= 0 && y < this.size.y)) {
		return new IntVector2(x, y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 49233, 49248, null, null));
	} else {
		return new IntVector2(int.minValue, int.minValue, null);
	}
}
IsometicGrid.prototype.isValid = function(pos) {
	return pos.greaterOrEqual(new IntVector2(0, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 49388, 49393, null, null))) && pos.less(this.size);
}
IsometicGrid.prototype.limitToInside = function(position) {
	return new IntVector2(math.limit(position.x, 0, this.size.x - 1), math.limit(position.y, 0, this.size.y - 1), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 49457, 49564, null, null));
}
IsometicGrid.prototype.getScreenVector = function(worldVector) {
	return this.xOffset.multiply2(worldVector.x).plus(this.yOffset.multiply2(worldVector.y));
}
IsometicGrid.prototype.clone = function() {
	let clone = new _IsometicGrid();
	clone.size = this.size.clone();
	clone.cellSize = this.cellSize.clone();
	clone.topFaceOffset = this.topFaceOffset.clone();
	clone.xOffset = this.xOffset.clone();
	clone.yOffset = this.yOffset.clone();
	clone.basePos = this.basePos.clone();
	return clone;
}
function _IsometicGrid() {};
_IsometicGrid.prototype = IsometicGrid.prototype;
IsometicGrid.prototype.serialize_internal = function(buffer) {
	(this.size || new _IntVector2()).serialize_internal(buffer);
	(this.cellSize || new _Vector2()).serialize_internal(buffer);
	(this.topFaceOffset || new _Vector2()).serialize_internal(buffer);
	(this.xOffset || new _Vector2()).serialize_internal(buffer);
	(this.yOffset || new _Vector2()).serialize_internal(buffer);
	(this.basePos || new _Vector2()).serialize_internal(buffer);
}
IsometicGrid.prototype.deserialize_internal = function(buffer) {
	(this.size || (this.size = new _IntVector2())).deserialize_internal(buffer);
	(this.cellSize || (this.cellSize = new _Vector2())).deserialize_internal(buffer);
	(this.topFaceOffset || (this.topFaceOffset = new _Vector2())).deserialize_internal(buffer);
	(this.xOffset || (this.xOffset = new _Vector2())).deserialize_internal(buffer);
	(this.yOffset || (this.yOffset = new _Vector2())).deserialize_internal(buffer);
	(this.basePos || (this.basePos = new _Vector2())).deserialize_internal(buffer);
}
IsometicGrid.prototype.serialize_external = function(buffer) {
	buffer.writeString("size");
	let size_startPos = buffer.reserveSize();
	(this.size || new _IntVector2()).serialize_external(buffer);
	buffer.writeSize(size_startPos);
	buffer.writeString("cellSize");
	let cellSize_startPos = buffer.reserveSize();
	(this.cellSize || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(cellSize_startPos);
	buffer.writeString("topFaceOffset");
	let topFaceOffset_startPos = buffer.reserveSize();
	(this.topFaceOffset || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(topFaceOffset_startPos);
	buffer.writeString("xOffset");
	let xOffset_startPos = buffer.reserveSize();
	(this.xOffset || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(xOffset_startPos);
	buffer.writeString("yOffset");
	let yOffset_startPos = buffer.reserveSize();
	(this.yOffset || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(yOffset_startPos);
	buffer.writeString("basePos");
	let basePos_startPos = buffer.reserveSize();
	(this.basePos || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(basePos_startPos);
	buffer.writeString("");
}
IsometicGrid.prototype.deserialize_external = function(buffer) {
	let size_is_set = false, cellSize_is_set = false, topFaceOffset_is_set = false, xOffset_is_set = false, yOffset_is_set = false, basePos_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "size":
				buffer.readInt32();
				(this.size || (this.size = new _IntVector2())).deserialize_external(buffer);
				size_is_set = true;
				break;
			case "cellSize":
				buffer.readInt32();
				(this.cellSize || (this.cellSize = new _Vector2())).deserialize_external(buffer);
				cellSize_is_set = true;
				break;
			case "topFaceOffset":
				buffer.readInt32();
				(this.topFaceOffset || (this.topFaceOffset = new _Vector2())).deserialize_external(buffer);
				topFaceOffset_is_set = true;
				break;
			case "xOffset":
				buffer.readInt32();
				(this.xOffset || (this.xOffset = new _Vector2())).deserialize_external(buffer);
				xOffset_is_set = true;
				break;
			case "yOffset":
				buffer.readInt32();
				(this.yOffset || (this.yOffset = new _Vector2())).deserialize_external(buffer);
				yOffset_is_set = true;
				break;
			case "basePos":
				buffer.readInt32();
				(this.basePos || (this.basePos = new _Vector2())).deserialize_external(buffer);
				basePos_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!size_is_set) this.size = new IntVector2(0, 0, null);
				if(!cellSize_is_set) this.cellSize = new Vector2(0.0, 0.0, null);
				if(!topFaceOffset_is_set) this.topFaceOffset = new Vector2(0.0, 0.0, null);
				if(!xOffset_is_set) this.xOffset = this.cellSize.divide2(2);
				if(!yOffset_is_set) this.yOffset = new Vector2(-this.xOffset.x, this.xOffset.y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 47937, 47960, null, null));
				if(!basePos_is_set) this.basePos = new Vector2(0, -this.yOffset.y * (this.size.y - 1), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 47988, 48013, null, null));
				return;
		}
	}
}
function Direction(name, index, vector, angle, isoAngle) {
	this.name = name;
	this.index = index;
	this.vector = vector?.clone();
	this.angle = angle;
	this.isoAngle = isoAngle;
}
Direction.init = function() {
	Direction.Up = new Direction("Up", 0, new IntVector2(0, -1, null), 0, (210/360));
	_constCache.push(Direction.Up);
	Direction.Right = new Direction("Right", 1, new IntVector2(1, 0, null), .25, (330/360));
	_constCache.push(Direction.Right);
	Direction.Down = new Direction("Down", 2, new IntVector2(0, 1, null), .50, (30/360));
	_constCache.push(Direction.Down);
	Direction.Left = new Direction("Left", 3, new IntVector2(-1, 0, null), .75, (150/360));
	_constCache.push(Direction.Left);
	Direction.None = new Direction("None", -1, new IntVector2(0, 0, null), 0, (0/360));
	_constCache.push(Direction.None);
	Direction.UpLeft = new Direction("UpLeft", 0, new IntVector2(-1, -1, null), (-.125), 0.0);
	_constCache.push(Direction.UpLeft);
	Direction.UpRight = new Direction("UpRight", 1, new IntVector2(1, -1, null), .125, 0.0);
	_constCache.push(Direction.UpRight);
	Direction.DownRight = new Direction("DownRight", 2, new IntVector2(1, 1, null), .375, 0.0);
	_constCache.push(Direction.DownRight);
	Direction.DownLeft = new Direction("DownLeft", 3, new IntVector2(-1, 1, null), .625, 0.0);
	_constCache.push(Direction.DownLeft);
	Direction.primaryDirections = [Direction.Up, Direction.Right, Direction.Down, Direction.Left];
	Direction.diagonalDirections = [Direction.UpLeft, Direction.UpRight, Direction.DownRight, Direction.DownLeft];
	Direction.horizontalDirections = [Direction.Left, Direction.Right];
	Direction.verticalDirections = [Direction.Up, Direction.Down];
	Direction.trianglePointingUp = [Direction.Up, Direction.DownRight, Direction.DownLeft];
	Direction.trianglePointingRight = [Direction.UpLeft, Direction.Right, Direction.DownLeft];
	Direction.trianglePointingDown = [Direction.UpLeft, Direction.UpRight, Direction.Down];
	Direction.trianglePointingLeft = [Direction.Left, Direction.UpRight, Direction.DownRight];
	Direction.allDirections = [Direction.Up, Direction.UpRight, Direction.Right, Direction.DownRight, Direction.Down, Direction.DownLeft, Direction.Left, Direction.UpLeft];
	Direction.centerAndAllDirections = [Direction.None, Direction.Up, Direction.UpRight, Direction.Right, Direction.DownRight, Direction.Down, Direction.DownLeft, Direction.Left, Direction.UpLeft];
	Direction.centerAndPrimaryDirections = [Direction.None, Direction.Up, Direction.Right, Direction.Down, Direction.Left];
}
Direction.prototype.toString = function() {
	return this.name;
}
Direction.prototype.equal = function(value) {
	this.angle == value.angle;
}
Direction.prototype.rotated = function(direction) {
	return Direction.primaryDirections[((((this.index + ((direction == 0/*Clockwise*/ ? 1 : 3))) % 4) + 4) % 4)];
}
Direction.prototype.inverted = function() {
	return Direction.primaryDirections[((((this.index + 2) % 4) + 4) % 4)];
}
Direction.prototype.isOrthogonalTo = function(value) {
	return (((this.index % 2) + 2) % 2) != (((value.index % 2) + 2) % 2);
}
Direction.prototype.isParallelTo = function(value) {
	return (((this.index % 2) + 2) % 2) == (((value.index % 2) + 2) % 2);
}
Direction.prototype.clone = function() {
	let clone = new _Direction();
	clone.name = this.name;
	clone.index = this.index;
	clone.vector = this.vector.clone();
	clone.angle = this.angle;
	clone.isoAngle = this.isoAngle;
	return clone;
}
function _Direction() {};
_Direction.prototype = Direction.prototype;
function Direction_serialize_internal(buffer) {
	let _primaryDirections = Direction.primaryDirections
	if(_primaryDirections) {
		var index = _objectCacheIndex.get(_primaryDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_primaryDirections, index = _objectCache.length);
			_objectCache.push(_primaryDirections);
			buffer.writeInt32(-index);
			_primaryDirections._objectIndex = index;
			buffer.writeInt32(_primaryDirections.length);
			for(let i=0, len=_primaryDirections.length; i<len; ++i) {
				let _primaryDirections_item = _primaryDirections[i]
				if(_primaryDirections_item) {
					var index = _objectCacheIndex.get(_primaryDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_primaryDirections_item, index = _objectCache.length);
						_objectCache.push(_primaryDirections_item);
						buffer.writeInt32(-index);
						_primaryDirections_item._objectIndex = index;
						_primaryDirections_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let _diagonalDirections = Direction.diagonalDirections
	if(_diagonalDirections) {
		var index = _objectCacheIndex.get(_diagonalDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_diagonalDirections, index = _objectCache.length);
			_objectCache.push(_diagonalDirections);
			buffer.writeInt32(-index);
			_diagonalDirections._objectIndex = index;
			buffer.writeInt32(_diagonalDirections.length);
			for(let i=0, len=_diagonalDirections.length; i<len; ++i) {
				let _diagonalDirections_item = _diagonalDirections[i]
				if(_diagonalDirections_item) {
					var index = _objectCacheIndex.get(_diagonalDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_diagonalDirections_item, index = _objectCache.length);
						_objectCache.push(_diagonalDirections_item);
						buffer.writeInt32(-index);
						_diagonalDirections_item._objectIndex = index;
						_diagonalDirections_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let _horizontalDirections = Direction.horizontalDirections
	if(_horizontalDirections) {
		var index = _objectCacheIndex.get(_horizontalDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_horizontalDirections, index = _objectCache.length);
			_objectCache.push(_horizontalDirections);
			buffer.writeInt32(-index);
			_horizontalDirections._objectIndex = index;
			buffer.writeInt32(_horizontalDirections.length);
			for(let i=0, len=_horizontalDirections.length; i<len; ++i) {
				let _horizontalDirections_item = _horizontalDirections[i]
				if(_horizontalDirections_item) {
					var index = _objectCacheIndex.get(_horizontalDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_horizontalDirections_item, index = _objectCache.length);
						_objectCache.push(_horizontalDirections_item);
						buffer.writeInt32(-index);
						_horizontalDirections_item._objectIndex = index;
						_horizontalDirections_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let _verticalDirections = Direction.verticalDirections
	if(_verticalDirections) {
		var index = _objectCacheIndex.get(_verticalDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_verticalDirections, index = _objectCache.length);
			_objectCache.push(_verticalDirections);
			buffer.writeInt32(-index);
			_verticalDirections._objectIndex = index;
			buffer.writeInt32(_verticalDirections.length);
			for(let i=0, len=_verticalDirections.length; i<len; ++i) {
				let _verticalDirections_item = _verticalDirections[i]
				if(_verticalDirections_item) {
					var index = _objectCacheIndex.get(_verticalDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_verticalDirections_item, index = _objectCache.length);
						_objectCache.push(_verticalDirections_item);
						buffer.writeInt32(-index);
						_verticalDirections_item._objectIndex = index;
						_verticalDirections_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let _trianglePointingUp = Direction.trianglePointingUp
	if(_trianglePointingUp) {
		var index = _objectCacheIndex.get(_trianglePointingUp);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_trianglePointingUp, index = _objectCache.length);
			_objectCache.push(_trianglePointingUp);
			buffer.writeInt32(-index);
			_trianglePointingUp._objectIndex = index;
			buffer.writeInt32(_trianglePointingUp.length);
			for(let i=0, len=_trianglePointingUp.length; i<len; ++i) {
				let _trianglePointingUp_item = _trianglePointingUp[i]
				if(_trianglePointingUp_item) {
					var index = _objectCacheIndex.get(_trianglePointingUp_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_trianglePointingUp_item, index = _objectCache.length);
						_objectCache.push(_trianglePointingUp_item);
						buffer.writeInt32(-index);
						_trianglePointingUp_item._objectIndex = index;
						_trianglePointingUp_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let _trianglePointingRight = Direction.trianglePointingRight
	if(_trianglePointingRight) {
		var index = _objectCacheIndex.get(_trianglePointingRight);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_trianglePointingRight, index = _objectCache.length);
			_objectCache.push(_trianglePointingRight);
			buffer.writeInt32(-index);
			_trianglePointingRight._objectIndex = index;
			buffer.writeInt32(_trianglePointingRight.length);
			for(let i=0, len=_trianglePointingRight.length; i<len; ++i) {
				let _trianglePointingRight_item = _trianglePointingRight[i]
				if(_trianglePointingRight_item) {
					var index = _objectCacheIndex.get(_trianglePointingRight_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_trianglePointingRight_item, index = _objectCache.length);
						_objectCache.push(_trianglePointingRight_item);
						buffer.writeInt32(-index);
						_trianglePointingRight_item._objectIndex = index;
						_trianglePointingRight_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let _trianglePointingDown = Direction.trianglePointingDown
	if(_trianglePointingDown) {
		var index = _objectCacheIndex.get(_trianglePointingDown);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_trianglePointingDown, index = _objectCache.length);
			_objectCache.push(_trianglePointingDown);
			buffer.writeInt32(-index);
			_trianglePointingDown._objectIndex = index;
			buffer.writeInt32(_trianglePointingDown.length);
			for(let i=0, len=_trianglePointingDown.length; i<len; ++i) {
				let _trianglePointingDown_item = _trianglePointingDown[i]
				if(_trianglePointingDown_item) {
					var index = _objectCacheIndex.get(_trianglePointingDown_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_trianglePointingDown_item, index = _objectCache.length);
						_objectCache.push(_trianglePointingDown_item);
						buffer.writeInt32(-index);
						_trianglePointingDown_item._objectIndex = index;
						_trianglePointingDown_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let _trianglePointingLeft = Direction.trianglePointingLeft
	if(_trianglePointingLeft) {
		var index = _objectCacheIndex.get(_trianglePointingLeft);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_trianglePointingLeft, index = _objectCache.length);
			_objectCache.push(_trianglePointingLeft);
			buffer.writeInt32(-index);
			_trianglePointingLeft._objectIndex = index;
			buffer.writeInt32(_trianglePointingLeft.length);
			for(let i=0, len=_trianglePointingLeft.length; i<len; ++i) {
				let _trianglePointingLeft_item = _trianglePointingLeft[i]
				if(_trianglePointingLeft_item) {
					var index = _objectCacheIndex.get(_trianglePointingLeft_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_trianglePointingLeft_item, index = _objectCache.length);
						_objectCache.push(_trianglePointingLeft_item);
						buffer.writeInt32(-index);
						_trianglePointingLeft_item._objectIndex = index;
						_trianglePointingLeft_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let _allDirections = Direction.allDirections
	if(_allDirections) {
		var index = _objectCacheIndex.get(_allDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_allDirections, index = _objectCache.length);
			_objectCache.push(_allDirections);
			buffer.writeInt32(-index);
			_allDirections._objectIndex = index;
			buffer.writeInt32(_allDirections.length);
			for(let i=0, len=_allDirections.length; i<len; ++i) {
				let _allDirections_item = _allDirections[i]
				if(_allDirections_item) {
					var index = _objectCacheIndex.get(_allDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_allDirections_item, index = _objectCache.length);
						_objectCache.push(_allDirections_item);
						buffer.writeInt32(-index);
						_allDirections_item._objectIndex = index;
						_allDirections_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let _centerAndAllDirections = Direction.centerAndAllDirections
	if(_centerAndAllDirections) {
		var index = _objectCacheIndex.get(_centerAndAllDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_centerAndAllDirections, index = _objectCache.length);
			_objectCache.push(_centerAndAllDirections);
			buffer.writeInt32(-index);
			_centerAndAllDirections._objectIndex = index;
			buffer.writeInt32(_centerAndAllDirections.length);
			for(let i=0, len=_centerAndAllDirections.length; i<len; ++i) {
				let _centerAndAllDirections_item = _centerAndAllDirections[i]
				if(_centerAndAllDirections_item) {
					var index = _objectCacheIndex.get(_centerAndAllDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_centerAndAllDirections_item, index = _objectCache.length);
						_objectCache.push(_centerAndAllDirections_item);
						buffer.writeInt32(-index);
						_centerAndAllDirections_item._objectIndex = index;
						_centerAndAllDirections_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let _centerAndPrimaryDirections = Direction.centerAndPrimaryDirections
	if(_centerAndPrimaryDirections) {
		var index = _objectCacheIndex.get(_centerAndPrimaryDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_centerAndPrimaryDirections, index = _objectCache.length);
			_objectCache.push(_centerAndPrimaryDirections);
			buffer.writeInt32(-index);
			_centerAndPrimaryDirections._objectIndex = index;
			buffer.writeInt32(_centerAndPrimaryDirections.length);
			for(let i=0, len=_centerAndPrimaryDirections.length; i<len; ++i) {
				let _centerAndPrimaryDirections_item = _centerAndPrimaryDirections[i]
				if(_centerAndPrimaryDirections_item) {
					var index = _objectCacheIndex.get(_centerAndPrimaryDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_centerAndPrimaryDirections_item, index = _objectCache.length);
						_objectCache.push(_centerAndPrimaryDirections_item);
						buffer.writeInt32(-index);
						_centerAndPrimaryDirections_item._objectIndex = index;
						_centerAndPrimaryDirections_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
function Direction_deserialize_internal(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction.primaryDirections = _objectCache[index];
	} else {
		let _primaryDirections = Direction.primaryDirections
		if(!_primaryDirections || _primaryDirections._objectIndex != -index) Direction.primaryDirections = _primaryDirections = [];
		_objectCache[-index] = _primaryDirections;
		for(let i=0, len = _primaryDirections.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_primaryDirections[i] = _objectCache[index];
				} else {
					let _primaryDirections_item = _primaryDirections[i]
					if(!_primaryDirections_item || _primaryDirections_item._objectIndex != -index)
						_primaryDirections[i] = _primaryDirections_item = new _Direction();
					(_objectCache[-index] = _primaryDirections_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction.diagonalDirections = _objectCache[index];
	} else {
		let _diagonalDirections = Direction.diagonalDirections
		if(!_diagonalDirections || _diagonalDirections._objectIndex != -index) Direction.diagonalDirections = _diagonalDirections = [];
		_objectCache[-index] = _diagonalDirections;
		for(let i=0, len = _diagonalDirections.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_diagonalDirections[i] = _objectCache[index];
				} else {
					let _diagonalDirections_item = _diagonalDirections[i]
					if(!_diagonalDirections_item || _diagonalDirections_item._objectIndex != -index)
						_diagonalDirections[i] = _diagonalDirections_item = new _Direction();
					(_objectCache[-index] = _diagonalDirections_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction.horizontalDirections = _objectCache[index];
	} else {
		let _horizontalDirections = Direction.horizontalDirections
		if(!_horizontalDirections || _horizontalDirections._objectIndex != -index) Direction.horizontalDirections = _horizontalDirections = [];
		_objectCache[-index] = _horizontalDirections;
		for(let i=0, len = _horizontalDirections.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_horizontalDirections[i] = _objectCache[index];
				} else {
					let _horizontalDirections_item = _horizontalDirections[i]
					if(!_horizontalDirections_item || _horizontalDirections_item._objectIndex != -index)
						_horizontalDirections[i] = _horizontalDirections_item = new _Direction();
					(_objectCache[-index] = _horizontalDirections_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction.verticalDirections = _objectCache[index];
	} else {
		let _verticalDirections = Direction.verticalDirections
		if(!_verticalDirections || _verticalDirections._objectIndex != -index) Direction.verticalDirections = _verticalDirections = [];
		_objectCache[-index] = _verticalDirections;
		for(let i=0, len = _verticalDirections.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_verticalDirections[i] = _objectCache[index];
				} else {
					let _verticalDirections_item = _verticalDirections[i]
					if(!_verticalDirections_item || _verticalDirections_item._objectIndex != -index)
						_verticalDirections[i] = _verticalDirections_item = new _Direction();
					(_objectCache[-index] = _verticalDirections_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction.trianglePointingUp = _objectCache[index];
	} else {
		let _trianglePointingUp = Direction.trianglePointingUp
		if(!_trianglePointingUp || _trianglePointingUp._objectIndex != -index) Direction.trianglePointingUp = _trianglePointingUp = [];
		_objectCache[-index] = _trianglePointingUp;
		for(let i=0, len = _trianglePointingUp.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_trianglePointingUp[i] = _objectCache[index];
				} else {
					let _trianglePointingUp_item = _trianglePointingUp[i]
					if(!_trianglePointingUp_item || _trianglePointingUp_item._objectIndex != -index)
						_trianglePointingUp[i] = _trianglePointingUp_item = new _Direction();
					(_objectCache[-index] = _trianglePointingUp_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction.trianglePointingRight = _objectCache[index];
	} else {
		let _trianglePointingRight = Direction.trianglePointingRight
		if(!_trianglePointingRight || _trianglePointingRight._objectIndex != -index) Direction.trianglePointingRight = _trianglePointingRight = [];
		_objectCache[-index] = _trianglePointingRight;
		for(let i=0, len = _trianglePointingRight.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_trianglePointingRight[i] = _objectCache[index];
				} else {
					let _trianglePointingRight_item = _trianglePointingRight[i]
					if(!_trianglePointingRight_item || _trianglePointingRight_item._objectIndex != -index)
						_trianglePointingRight[i] = _trianglePointingRight_item = new _Direction();
					(_objectCache[-index] = _trianglePointingRight_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction.trianglePointingDown = _objectCache[index];
	} else {
		let _trianglePointingDown = Direction.trianglePointingDown
		if(!_trianglePointingDown || _trianglePointingDown._objectIndex != -index) Direction.trianglePointingDown = _trianglePointingDown = [];
		_objectCache[-index] = _trianglePointingDown;
		for(let i=0, len = _trianglePointingDown.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_trianglePointingDown[i] = _objectCache[index];
				} else {
					let _trianglePointingDown_item = _trianglePointingDown[i]
					if(!_trianglePointingDown_item || _trianglePointingDown_item._objectIndex != -index)
						_trianglePointingDown[i] = _trianglePointingDown_item = new _Direction();
					(_objectCache[-index] = _trianglePointingDown_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction.trianglePointingLeft = _objectCache[index];
	} else {
		let _trianglePointingLeft = Direction.trianglePointingLeft
		if(!_trianglePointingLeft || _trianglePointingLeft._objectIndex != -index) Direction.trianglePointingLeft = _trianglePointingLeft = [];
		_objectCache[-index] = _trianglePointingLeft;
		for(let i=0, len = _trianglePointingLeft.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_trianglePointingLeft[i] = _objectCache[index];
				} else {
					let _trianglePointingLeft_item = _trianglePointingLeft[i]
					if(!_trianglePointingLeft_item || _trianglePointingLeft_item._objectIndex != -index)
						_trianglePointingLeft[i] = _trianglePointingLeft_item = new _Direction();
					(_objectCache[-index] = _trianglePointingLeft_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction.allDirections = _objectCache[index];
	} else {
		let _allDirections = Direction.allDirections
		if(!_allDirections || _allDirections._objectIndex != -index) Direction.allDirections = _allDirections = [];
		_objectCache[-index] = _allDirections;
		for(let i=0, len = _allDirections.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_allDirections[i] = _objectCache[index];
				} else {
					let _allDirections_item = _allDirections[i]
					if(!_allDirections_item || _allDirections_item._objectIndex != -index)
						_allDirections[i] = _allDirections_item = new _Direction();
					(_objectCache[-index] = _allDirections_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction.centerAndAllDirections = _objectCache[index];
	} else {
		let _centerAndAllDirections = Direction.centerAndAllDirections
		if(!_centerAndAllDirections || _centerAndAllDirections._objectIndex != -index) Direction.centerAndAllDirections = _centerAndAllDirections = [];
		_objectCache[-index] = _centerAndAllDirections;
		for(let i=0, len = _centerAndAllDirections.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_centerAndAllDirections[i] = _objectCache[index];
				} else {
					let _centerAndAllDirections_item = _centerAndAllDirections[i]
					if(!_centerAndAllDirections_item || _centerAndAllDirections_item._objectIndex != -index)
						_centerAndAllDirections[i] = _centerAndAllDirections_item = new _Direction();
					(_objectCache[-index] = _centerAndAllDirections_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction.centerAndPrimaryDirections = _objectCache[index];
	} else {
		let _centerAndPrimaryDirections = Direction.centerAndPrimaryDirections
		if(!_centerAndPrimaryDirections || _centerAndPrimaryDirections._objectIndex != -index) Direction.centerAndPrimaryDirections = _centerAndPrimaryDirections = [];
		_objectCache[-index] = _centerAndPrimaryDirections;
		for(let i=0, len = _centerAndPrimaryDirections.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_centerAndPrimaryDirections[i] = _objectCache[index];
				} else {
					let _centerAndPrimaryDirections_item = _centerAndPrimaryDirections[i]
					if(!_centerAndPrimaryDirections_item || _centerAndPrimaryDirections_item._objectIndex != -index)
						_centerAndPrimaryDirections[i] = _centerAndPrimaryDirections_item = new _Direction();
					(_objectCache[-index] = _centerAndPrimaryDirections_item).deserialize_internal(buffer);
				}
		}
	}
}
Direction.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.name);
	buffer.writeInt32(this.index);
	(this.vector || new _IntVector2()).serialize_internal(buffer);
	buffer.writeFloat64(this.angle);
	buffer.writeFloat64(this.isoAngle);
}
Direction.prototype.deserialize_internal = function(buffer) {
	this.name = buffer.readString();
	this.index = buffer.readInt32();
	(this.vector || (this.vector = new _IntVector2())).deserialize_internal(buffer);
	this.angle = buffer.readFloat64();
	this.isoAngle = buffer.readFloat64();
}
function Direction_serialize_external(buffer) {
	buffer.writeString("primaryDirections");
	let _primaryDirections = Direction.primaryDirections
	let _primaryDirections_startPos = buffer.reserveSize();
	if(_primaryDirections) {
		var index = _objectCacheIndex.get(_primaryDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_primaryDirections, index = _objectCache.length);
			_objectCache.push(_primaryDirections);
			buffer.writeInt32(-index);
			_primaryDirections._objectIndex = index;
			buffer.writeInt32(_primaryDirections.length);
			for(let i=0, len=_primaryDirections.length; i<len; ++i) {
				let _primaryDirections_item = _primaryDirections[i]
				if(_primaryDirections_item) {
					var index = _objectCacheIndex.get(_primaryDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_primaryDirections_item, index = _objectCache.length);
						_objectCache.push(_primaryDirections_item);
						buffer.writeInt32(-index);
						_primaryDirections_item._objectIndex = index;
						_primaryDirections_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_primaryDirections_startPos);
	buffer.writeString("diagonalDirections");
	let _diagonalDirections = Direction.diagonalDirections
	let _diagonalDirections_startPos = buffer.reserveSize();
	if(_diagonalDirections) {
		var index = _objectCacheIndex.get(_diagonalDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_diagonalDirections, index = _objectCache.length);
			_objectCache.push(_diagonalDirections);
			buffer.writeInt32(-index);
			_diagonalDirections._objectIndex = index;
			buffer.writeInt32(_diagonalDirections.length);
			for(let i=0, len=_diagonalDirections.length; i<len; ++i) {
				let _diagonalDirections_item = _diagonalDirections[i]
				if(_diagonalDirections_item) {
					var index = _objectCacheIndex.get(_diagonalDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_diagonalDirections_item, index = _objectCache.length);
						_objectCache.push(_diagonalDirections_item);
						buffer.writeInt32(-index);
						_diagonalDirections_item._objectIndex = index;
						_diagonalDirections_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_diagonalDirections_startPos);
	buffer.writeString("horizontalDirections");
	let _horizontalDirections = Direction.horizontalDirections
	let _horizontalDirections_startPos = buffer.reserveSize();
	if(_horizontalDirections) {
		var index = _objectCacheIndex.get(_horizontalDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_horizontalDirections, index = _objectCache.length);
			_objectCache.push(_horizontalDirections);
			buffer.writeInt32(-index);
			_horizontalDirections._objectIndex = index;
			buffer.writeInt32(_horizontalDirections.length);
			for(let i=0, len=_horizontalDirections.length; i<len; ++i) {
				let _horizontalDirections_item = _horizontalDirections[i]
				if(_horizontalDirections_item) {
					var index = _objectCacheIndex.get(_horizontalDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_horizontalDirections_item, index = _objectCache.length);
						_objectCache.push(_horizontalDirections_item);
						buffer.writeInt32(-index);
						_horizontalDirections_item._objectIndex = index;
						_horizontalDirections_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_horizontalDirections_startPos);
	buffer.writeString("verticalDirections");
	let _verticalDirections = Direction.verticalDirections
	let _verticalDirections_startPos = buffer.reserveSize();
	if(_verticalDirections) {
		var index = _objectCacheIndex.get(_verticalDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_verticalDirections, index = _objectCache.length);
			_objectCache.push(_verticalDirections);
			buffer.writeInt32(-index);
			_verticalDirections._objectIndex = index;
			buffer.writeInt32(_verticalDirections.length);
			for(let i=0, len=_verticalDirections.length; i<len; ++i) {
				let _verticalDirections_item = _verticalDirections[i]
				if(_verticalDirections_item) {
					var index = _objectCacheIndex.get(_verticalDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_verticalDirections_item, index = _objectCache.length);
						_objectCache.push(_verticalDirections_item);
						buffer.writeInt32(-index);
						_verticalDirections_item._objectIndex = index;
						_verticalDirections_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_verticalDirections_startPos);
	buffer.writeString("trianglePointingUp");
	let _trianglePointingUp = Direction.trianglePointingUp
	let _trianglePointingUp_startPos = buffer.reserveSize();
	if(_trianglePointingUp) {
		var index = _objectCacheIndex.get(_trianglePointingUp);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_trianglePointingUp, index = _objectCache.length);
			_objectCache.push(_trianglePointingUp);
			buffer.writeInt32(-index);
			_trianglePointingUp._objectIndex = index;
			buffer.writeInt32(_trianglePointingUp.length);
			for(let i=0, len=_trianglePointingUp.length; i<len; ++i) {
				let _trianglePointingUp_item = _trianglePointingUp[i]
				if(_trianglePointingUp_item) {
					var index = _objectCacheIndex.get(_trianglePointingUp_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_trianglePointingUp_item, index = _objectCache.length);
						_objectCache.push(_trianglePointingUp_item);
						buffer.writeInt32(-index);
						_trianglePointingUp_item._objectIndex = index;
						_trianglePointingUp_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_trianglePointingUp_startPos);
	buffer.writeString("trianglePointingRight");
	let _trianglePointingRight = Direction.trianglePointingRight
	let _trianglePointingRight_startPos = buffer.reserveSize();
	if(_trianglePointingRight) {
		var index = _objectCacheIndex.get(_trianglePointingRight);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_trianglePointingRight, index = _objectCache.length);
			_objectCache.push(_trianglePointingRight);
			buffer.writeInt32(-index);
			_trianglePointingRight._objectIndex = index;
			buffer.writeInt32(_trianglePointingRight.length);
			for(let i=0, len=_trianglePointingRight.length; i<len; ++i) {
				let _trianglePointingRight_item = _trianglePointingRight[i]
				if(_trianglePointingRight_item) {
					var index = _objectCacheIndex.get(_trianglePointingRight_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_trianglePointingRight_item, index = _objectCache.length);
						_objectCache.push(_trianglePointingRight_item);
						buffer.writeInt32(-index);
						_trianglePointingRight_item._objectIndex = index;
						_trianglePointingRight_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_trianglePointingRight_startPos);
	buffer.writeString("trianglePointingDown");
	let _trianglePointingDown = Direction.trianglePointingDown
	let _trianglePointingDown_startPos = buffer.reserveSize();
	if(_trianglePointingDown) {
		var index = _objectCacheIndex.get(_trianglePointingDown);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_trianglePointingDown, index = _objectCache.length);
			_objectCache.push(_trianglePointingDown);
			buffer.writeInt32(-index);
			_trianglePointingDown._objectIndex = index;
			buffer.writeInt32(_trianglePointingDown.length);
			for(let i=0, len=_trianglePointingDown.length; i<len; ++i) {
				let _trianglePointingDown_item = _trianglePointingDown[i]
				if(_trianglePointingDown_item) {
					var index = _objectCacheIndex.get(_trianglePointingDown_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_trianglePointingDown_item, index = _objectCache.length);
						_objectCache.push(_trianglePointingDown_item);
						buffer.writeInt32(-index);
						_trianglePointingDown_item._objectIndex = index;
						_trianglePointingDown_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_trianglePointingDown_startPos);
	buffer.writeString("trianglePointingLeft");
	let _trianglePointingLeft = Direction.trianglePointingLeft
	let _trianglePointingLeft_startPos = buffer.reserveSize();
	if(_trianglePointingLeft) {
		var index = _objectCacheIndex.get(_trianglePointingLeft);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_trianglePointingLeft, index = _objectCache.length);
			_objectCache.push(_trianglePointingLeft);
			buffer.writeInt32(-index);
			_trianglePointingLeft._objectIndex = index;
			buffer.writeInt32(_trianglePointingLeft.length);
			for(let i=0, len=_trianglePointingLeft.length; i<len; ++i) {
				let _trianglePointingLeft_item = _trianglePointingLeft[i]
				if(_trianglePointingLeft_item) {
					var index = _objectCacheIndex.get(_trianglePointingLeft_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_trianglePointingLeft_item, index = _objectCache.length);
						_objectCache.push(_trianglePointingLeft_item);
						buffer.writeInt32(-index);
						_trianglePointingLeft_item._objectIndex = index;
						_trianglePointingLeft_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_trianglePointingLeft_startPos);
	buffer.writeString("allDirections");
	let _allDirections = Direction.allDirections
	let _allDirections_startPos = buffer.reserveSize();
	if(_allDirections) {
		var index = _objectCacheIndex.get(_allDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_allDirections, index = _objectCache.length);
			_objectCache.push(_allDirections);
			buffer.writeInt32(-index);
			_allDirections._objectIndex = index;
			buffer.writeInt32(_allDirections.length);
			for(let i=0, len=_allDirections.length; i<len; ++i) {
				let _allDirections_item = _allDirections[i]
				if(_allDirections_item) {
					var index = _objectCacheIndex.get(_allDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_allDirections_item, index = _objectCache.length);
						_objectCache.push(_allDirections_item);
						buffer.writeInt32(-index);
						_allDirections_item._objectIndex = index;
						_allDirections_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_allDirections_startPos);
	buffer.writeString("centerAndAllDirections");
	let _centerAndAllDirections = Direction.centerAndAllDirections
	let _centerAndAllDirections_startPos = buffer.reserveSize();
	if(_centerAndAllDirections) {
		var index = _objectCacheIndex.get(_centerAndAllDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_centerAndAllDirections, index = _objectCache.length);
			_objectCache.push(_centerAndAllDirections);
			buffer.writeInt32(-index);
			_centerAndAllDirections._objectIndex = index;
			buffer.writeInt32(_centerAndAllDirections.length);
			for(let i=0, len=_centerAndAllDirections.length; i<len; ++i) {
				let _centerAndAllDirections_item = _centerAndAllDirections[i]
				if(_centerAndAllDirections_item) {
					var index = _objectCacheIndex.get(_centerAndAllDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_centerAndAllDirections_item, index = _objectCache.length);
						_objectCache.push(_centerAndAllDirections_item);
						buffer.writeInt32(-index);
						_centerAndAllDirections_item._objectIndex = index;
						_centerAndAllDirections_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_centerAndAllDirections_startPos);
	buffer.writeString("centerAndPrimaryDirections");
	let _centerAndPrimaryDirections = Direction.centerAndPrimaryDirections
	let _centerAndPrimaryDirections_startPos = buffer.reserveSize();
	if(_centerAndPrimaryDirections) {
		var index = _objectCacheIndex.get(_centerAndPrimaryDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_centerAndPrimaryDirections, index = _objectCache.length);
			_objectCache.push(_centerAndPrimaryDirections);
			buffer.writeInt32(-index);
			_centerAndPrimaryDirections._objectIndex = index;
			buffer.writeInt32(_centerAndPrimaryDirections.length);
			for(let i=0, len=_centerAndPrimaryDirections.length; i<len; ++i) {
				let _centerAndPrimaryDirections_item = _centerAndPrimaryDirections[i]
				if(_centerAndPrimaryDirections_item) {
					var index = _objectCacheIndex.get(_centerAndPrimaryDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_centerAndPrimaryDirections_item, index = _objectCache.length);
						_objectCache.push(_centerAndPrimaryDirections_item);
						buffer.writeInt32(-index);
						_centerAndPrimaryDirections_item._objectIndex = index;
						_centerAndPrimaryDirections_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_centerAndPrimaryDirections_startPos);
	buffer.writeString("");
}
function Direction_deserialize_external(buffer) {
	let primaryDirections_is_set = false, diagonalDirections_is_set = false, horizontalDirections_is_set = false, verticalDirections_is_set = false, trianglePointingUp_is_set = false, trianglePointingRight_is_set = false, trianglePointingDown_is_set = false, trianglePointingLeft_is_set = false, allDirections_is_set = false, centerAndAllDirections_is_set = false, centerAndPrimaryDirections_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "primaryDirections":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction.primaryDirections = _objectCache[index];
				} else {
					let _primaryDirections = Direction.primaryDirections
					if(!_primaryDirections || _primaryDirections._objectIndex != -index) Direction.primaryDirections = _primaryDirections = [];
					_objectCache[-index] = _primaryDirections;
					for(let i=0, len = _primaryDirections.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_primaryDirections[i] = _objectCache[index];
							} else {
								let _primaryDirections_item = _primaryDirections[i]
								if(!_primaryDirections_item || _primaryDirections_item._objectIndex != -index)
									_primaryDirections[i] = _primaryDirections_item = new _Direction();
								(_objectCache[-index] = _primaryDirections_item).deserialize_external(buffer);
							}
					}
				}
				primaryDirections_is_set = true;
				break;
			case "diagonalDirections":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction.diagonalDirections = _objectCache[index];
				} else {
					let _diagonalDirections = Direction.diagonalDirections
					if(!_diagonalDirections || _diagonalDirections._objectIndex != -index) Direction.diagonalDirections = _diagonalDirections = [];
					_objectCache[-index] = _diagonalDirections;
					for(let i=0, len = _diagonalDirections.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_diagonalDirections[i] = _objectCache[index];
							} else {
								let _diagonalDirections_item = _diagonalDirections[i]
								if(!_diagonalDirections_item || _diagonalDirections_item._objectIndex != -index)
									_diagonalDirections[i] = _diagonalDirections_item = new _Direction();
								(_objectCache[-index] = _diagonalDirections_item).deserialize_external(buffer);
							}
					}
				}
				diagonalDirections_is_set = true;
				break;
			case "horizontalDirections":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction.horizontalDirections = _objectCache[index];
				} else {
					let _horizontalDirections = Direction.horizontalDirections
					if(!_horizontalDirections || _horizontalDirections._objectIndex != -index) Direction.horizontalDirections = _horizontalDirections = [];
					_objectCache[-index] = _horizontalDirections;
					for(let i=0, len = _horizontalDirections.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_horizontalDirections[i] = _objectCache[index];
							} else {
								let _horizontalDirections_item = _horizontalDirections[i]
								if(!_horizontalDirections_item || _horizontalDirections_item._objectIndex != -index)
									_horizontalDirections[i] = _horizontalDirections_item = new _Direction();
								(_objectCache[-index] = _horizontalDirections_item).deserialize_external(buffer);
							}
					}
				}
				horizontalDirections_is_set = true;
				break;
			case "verticalDirections":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction.verticalDirections = _objectCache[index];
				} else {
					let _verticalDirections = Direction.verticalDirections
					if(!_verticalDirections || _verticalDirections._objectIndex != -index) Direction.verticalDirections = _verticalDirections = [];
					_objectCache[-index] = _verticalDirections;
					for(let i=0, len = _verticalDirections.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_verticalDirections[i] = _objectCache[index];
							} else {
								let _verticalDirections_item = _verticalDirections[i]
								if(!_verticalDirections_item || _verticalDirections_item._objectIndex != -index)
									_verticalDirections[i] = _verticalDirections_item = new _Direction();
								(_objectCache[-index] = _verticalDirections_item).deserialize_external(buffer);
							}
					}
				}
				verticalDirections_is_set = true;
				break;
			case "trianglePointingUp":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction.trianglePointingUp = _objectCache[index];
				} else {
					let _trianglePointingUp = Direction.trianglePointingUp
					if(!_trianglePointingUp || _trianglePointingUp._objectIndex != -index) Direction.trianglePointingUp = _trianglePointingUp = [];
					_objectCache[-index] = _trianglePointingUp;
					for(let i=0, len = _trianglePointingUp.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_trianglePointingUp[i] = _objectCache[index];
							} else {
								let _trianglePointingUp_item = _trianglePointingUp[i]
								if(!_trianglePointingUp_item || _trianglePointingUp_item._objectIndex != -index)
									_trianglePointingUp[i] = _trianglePointingUp_item = new _Direction();
								(_objectCache[-index] = _trianglePointingUp_item).deserialize_external(buffer);
							}
					}
				}
				trianglePointingUp_is_set = true;
				break;
			case "trianglePointingRight":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction.trianglePointingRight = _objectCache[index];
				} else {
					let _trianglePointingRight = Direction.trianglePointingRight
					if(!_trianglePointingRight || _trianglePointingRight._objectIndex != -index) Direction.trianglePointingRight = _trianglePointingRight = [];
					_objectCache[-index] = _trianglePointingRight;
					for(let i=0, len = _trianglePointingRight.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_trianglePointingRight[i] = _objectCache[index];
							} else {
								let _trianglePointingRight_item = _trianglePointingRight[i]
								if(!_trianglePointingRight_item || _trianglePointingRight_item._objectIndex != -index)
									_trianglePointingRight[i] = _trianglePointingRight_item = new _Direction();
								(_objectCache[-index] = _trianglePointingRight_item).deserialize_external(buffer);
							}
					}
				}
				trianglePointingRight_is_set = true;
				break;
			case "trianglePointingDown":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction.trianglePointingDown = _objectCache[index];
				} else {
					let _trianglePointingDown = Direction.trianglePointingDown
					if(!_trianglePointingDown || _trianglePointingDown._objectIndex != -index) Direction.trianglePointingDown = _trianglePointingDown = [];
					_objectCache[-index] = _trianglePointingDown;
					for(let i=0, len = _trianglePointingDown.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_trianglePointingDown[i] = _objectCache[index];
							} else {
								let _trianglePointingDown_item = _trianglePointingDown[i]
								if(!_trianglePointingDown_item || _trianglePointingDown_item._objectIndex != -index)
									_trianglePointingDown[i] = _trianglePointingDown_item = new _Direction();
								(_objectCache[-index] = _trianglePointingDown_item).deserialize_external(buffer);
							}
					}
				}
				trianglePointingDown_is_set = true;
				break;
			case "trianglePointingLeft":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction.trianglePointingLeft = _objectCache[index];
				} else {
					let _trianglePointingLeft = Direction.trianglePointingLeft
					if(!_trianglePointingLeft || _trianglePointingLeft._objectIndex != -index) Direction.trianglePointingLeft = _trianglePointingLeft = [];
					_objectCache[-index] = _trianglePointingLeft;
					for(let i=0, len = _trianglePointingLeft.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_trianglePointingLeft[i] = _objectCache[index];
							} else {
								let _trianglePointingLeft_item = _trianglePointingLeft[i]
								if(!_trianglePointingLeft_item || _trianglePointingLeft_item._objectIndex != -index)
									_trianglePointingLeft[i] = _trianglePointingLeft_item = new _Direction();
								(_objectCache[-index] = _trianglePointingLeft_item).deserialize_external(buffer);
							}
					}
				}
				trianglePointingLeft_is_set = true;
				break;
			case "allDirections":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction.allDirections = _objectCache[index];
				} else {
					let _allDirections = Direction.allDirections
					if(!_allDirections || _allDirections._objectIndex != -index) Direction.allDirections = _allDirections = [];
					_objectCache[-index] = _allDirections;
					for(let i=0, len = _allDirections.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_allDirections[i] = _objectCache[index];
							} else {
								let _allDirections_item = _allDirections[i]
								if(!_allDirections_item || _allDirections_item._objectIndex != -index)
									_allDirections[i] = _allDirections_item = new _Direction();
								(_objectCache[-index] = _allDirections_item).deserialize_external(buffer);
							}
					}
				}
				allDirections_is_set = true;
				break;
			case "centerAndAllDirections":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction.centerAndAllDirections = _objectCache[index];
				} else {
					let _centerAndAllDirections = Direction.centerAndAllDirections
					if(!_centerAndAllDirections || _centerAndAllDirections._objectIndex != -index) Direction.centerAndAllDirections = _centerAndAllDirections = [];
					_objectCache[-index] = _centerAndAllDirections;
					for(let i=0, len = _centerAndAllDirections.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_centerAndAllDirections[i] = _objectCache[index];
							} else {
								let _centerAndAllDirections_item = _centerAndAllDirections[i]
								if(!_centerAndAllDirections_item || _centerAndAllDirections_item._objectIndex != -index)
									_centerAndAllDirections[i] = _centerAndAllDirections_item = new _Direction();
								(_objectCache[-index] = _centerAndAllDirections_item).deserialize_external(buffer);
							}
					}
				}
				centerAndAllDirections_is_set = true;
				break;
			case "centerAndPrimaryDirections":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction.centerAndPrimaryDirections = _objectCache[index];
				} else {
					let _centerAndPrimaryDirections = Direction.centerAndPrimaryDirections
					if(!_centerAndPrimaryDirections || _centerAndPrimaryDirections._objectIndex != -index) Direction.centerAndPrimaryDirections = _centerAndPrimaryDirections = [];
					_objectCache[-index] = _centerAndPrimaryDirections;
					for(let i=0, len = _centerAndPrimaryDirections.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_centerAndPrimaryDirections[i] = _objectCache[index];
							} else {
								let _centerAndPrimaryDirections_item = _centerAndPrimaryDirections[i]
								if(!_centerAndPrimaryDirections_item || _centerAndPrimaryDirections_item._objectIndex != -index)
									_centerAndPrimaryDirections[i] = _centerAndPrimaryDirections_item = new _Direction();
								(_objectCache[-index] = _centerAndPrimaryDirections_item).deserialize_external(buffer);
							}
					}
				}
				centerAndPrimaryDirections_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!primaryDirections_is_set) Direction.primaryDirections = [Direction.Up, Direction.Right, Direction.Down, Direction.Left];
				if(!diagonalDirections_is_set) Direction.diagonalDirections = [Direction.UpLeft, Direction.UpRight, Direction.DownRight, Direction.DownLeft];
				if(!horizontalDirections_is_set) Direction.horizontalDirections = [Direction.Left, Direction.Right];
				if(!verticalDirections_is_set) Direction.verticalDirections = [Direction.Up, Direction.Down];
				if(!trianglePointingUp_is_set) Direction.trianglePointingUp = [Direction.Up, Direction.DownRight, Direction.DownLeft];
				if(!trianglePointingRight_is_set) Direction.trianglePointingRight = [Direction.UpLeft, Direction.Right, Direction.DownLeft];
				if(!trianglePointingDown_is_set) Direction.trianglePointingDown = [Direction.UpLeft, Direction.UpRight, Direction.Down];
				if(!trianglePointingLeft_is_set) Direction.trianglePointingLeft = [Direction.Left, Direction.UpRight, Direction.DownRight];
				if(!allDirections_is_set) Direction.allDirections = [Direction.Up, Direction.UpRight, Direction.Right, Direction.DownRight, Direction.Down, Direction.DownLeft, Direction.Left, Direction.UpLeft];
				if(!centerAndAllDirections_is_set) Direction.centerAndAllDirections = [Direction.None, Direction.Up, Direction.UpRight, Direction.Right, Direction.DownRight, Direction.Down, Direction.DownLeft, Direction.Left, Direction.UpLeft];
				if(!centerAndPrimaryDirections_is_set) Direction.centerAndPrimaryDirections = [Direction.None, Direction.Up, Direction.Right, Direction.Down, Direction.Left];
				return;
		}
	}
}
Direction.prototype.serialize_external = function(buffer) {
	buffer.writeString("name");
	buffer.writeString(this.name);
	buffer.writeString("index");
	buffer.writeInt32(4);
	buffer.writeInt32(this.index);
	buffer.writeString("vector");
	let vector_startPos = buffer.reserveSize();
	(this.vector || new _IntVector2()).serialize_external(buffer);
	buffer.writeSize(vector_startPos);
	buffer.writeString("angle");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.angle);
	buffer.writeString("isoAngle");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.isoAngle);
	buffer.writeString("");
}
Direction.prototype.deserialize_external = function(buffer) {
	let name_is_set = false, index_is_set = false, vector_is_set = false, angle_is_set = false, isoAngle_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "name":
				this.name = buffer.readString();
				name_is_set = true;
				break;
			case "index":
				buffer.readInt32();
				this.index = buffer.readInt32();
				index_is_set = true;
				break;
			case "vector":
				buffer.readInt32();
				(this.vector || (this.vector = new _IntVector2())).deserialize_external(buffer);
				vector_is_set = true;
				break;
			case "angle":
				buffer.readInt32();
				this.angle = buffer.readFloat64();
				angle_is_set = true;
				break;
			case "isoAngle":
				buffer.readInt32();
				this.isoAngle = buffer.readFloat64();
				isoAngle_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!name_is_set) this.name = "";
				if(!index_is_set) this.index = 0;
				if(!vector_is_set) this.vector = new IntVector2(0, 0, null);
				if(!angle_is_set) this.angle = 0.0;
				if(!isoAngle_is_set) this.isoAngle = 0.0;
				return;
		}
	}
}
function Line(start, end, type) {
	this.start = start?.clone();
	this.end = end?.clone();
	this.type = type;
}
Line.prototype.length = function() {
	return (this.type == 2/*Segment*/ ? (this.start.distanceTo(this.end)) : Number.POSITIVE_INFINITY);
}
Line.prototype.intersectionWith = function(other) {
	let x1 = this.start.x, y1 = this.start.y;
	let x2 = this.end.x, y2 = this.end.y;
	let typeA = this.type;
	let x3 = other.start.x, y3 = other.start.y;
	let x4 = other.end.x, y4 = other.end.y;
	let typeB = other.type;
	if((x1 == x2 && y1 == y2) || (x3 == x4 && y3 == y4)) {
		return new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null);
	}
	let denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
	if((denominator == 0)) {
		return new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null);
	}
	let ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
	let ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;
	if((typeA >= 1/*Ray*/ && ua < 0) || (typeA == 2/*Segment*/ && ua > 1) || (typeB >= 1/*Ray*/ && ub < 0) || (typeB == 2/*Segment*/ && ub > 1)) {
		return new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null);
	}
	return new Vector2(x1 + ua * (x2 - x1), y1 + ua * (y2 - y1), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/geometry.l", 54334, 54383, null, null));
}
Line.prototype.toString = function() {
	return ""+this.start.x.toLocaleString("en-US", {maximumFractionDigits:2, minimumFractionDigits:2, minimumIntegerDigits:1, useGrouping:false})+" "+this.start.y.toLocaleString("en-US", {maximumFractionDigits:2, minimumFractionDigits:2, minimumIntegerDigits:1, useGrouping:false})+" -> "+this.end.x.toLocaleString("en-US", {maximumFractionDigits:2, minimumFractionDigits:2, minimumIntegerDigits:1, useGrouping:false})+" "+this.end.y.toLocaleString("en-US", {maximumFractionDigits:2, minimumFractionDigits:2, minimumIntegerDigits:1, useGrouping:false});
}
Line.prototype.clone = function() {
	let clone = new _Line();
	clone.start = this.start.clone();
	clone.end = this.end.clone();
	clone.type = this.type;
	return clone;
}
function _Line() {};
_Line.prototype = Line.prototype;
Line.prototype.serialize_internal = function(buffer) {
	(this.start || new _Vector2()).serialize_internal(buffer);
	(this.end || new _Vector2()).serialize_internal(buffer);
	buffer.writeInt32(this.type);
}
Line.prototype.deserialize_internal = function(buffer) {
	(this.start || (this.start = new _Vector2())).deserialize_internal(buffer);
	(this.end || (this.end = new _Vector2())).deserialize_internal(buffer);
	this.type = buffer.readInt32();
}
Line.prototype.serialize_external = function(buffer) {
	buffer.writeString("start");
	let start_startPos = buffer.reserveSize();
	(this.start || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(start_startPos);
	buffer.writeString("end");
	let end_startPos = buffer.reserveSize();
	(this.end || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(end_startPos);
	buffer.writeString("type");
	buffer.writeInt32(4);
	buffer.writeInt32(this.type);
	buffer.writeString("");
}
Line.prototype.deserialize_external = function(buffer) {
	let start_is_set = false, end_is_set = false, type_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "start":
				buffer.readInt32();
				(this.start || (this.start = new _Vector2())).deserialize_external(buffer);
				start_is_set = true;
				break;
			case "end":
				buffer.readInt32();
				(this.end || (this.end = new _Vector2())).deserialize_external(buffer);
				end_is_set = true;
				break;
			case "type":
				buffer.readInt32();
				this.type = buffer.readInt32();
				type_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!start_is_set) this.start = new Vector2(0.0, 0.0, null);
				if(!end_is_set) this.end = new Vector2(0.0, 0.0, null);
				if(!type_is_set) this.type = 0/*Line*/;
				return;
		}
	}
}
function Rect(position, size) {
	this.position = position?.clone();
	this.size = size?.clone();
}
Rect.prototype.left = function() {
	return this.position.x - this.size.x / 2;
}
Rect.prototype.right = function() {
	return this.position.x + this.size.x / 2;
}
Rect.prototype.top = function() {
	return this.position.y - this.size.y / 2;
}
Rect.prototype.bottom = function() {
	return this.position.y + this.size.y / 2;
}
Rect.prototype.contains = function(position) {
	return this.position.minus(this.size.divide2(2)).lessOrEqual(position) && position.less(this.position.plus(this.size.divide2(2)));
}
Rect.prototype.intersectsWith = function(position, size) {
	return this.position.minus(this.size.divide2(2)).minus(size.divide2(2)).lessOrEqual(position) && position.less(this.position.plus(this.size.divide2(2)).plus(size.divide2(2)));
}
Rect.prototype.clone = function() {
	let clone = new _Rect();
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	return clone;
}
function _Rect() {};
_Rect.prototype = Rect.prototype;
Rect.prototype.serialize_internal = function(buffer) {
	(this.position || new _Vector2()).serialize_internal(buffer);
	(this.size || new _Vector2()).serialize_internal(buffer);
}
Rect.prototype.deserialize_internal = function(buffer) {
	(this.position || (this.position = new _Vector2())).deserialize_internal(buffer);
	(this.size || (this.size = new _Vector2())).deserialize_internal(buffer);
}
Rect.prototype.serialize_external = function(buffer) {
	buffer.writeString("position");
	let position_startPos = buffer.reserveSize();
	(this.position || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(position_startPos);
	buffer.writeString("size");
	let size_startPos = buffer.reserveSize();
	(this.size || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(size_startPos);
	buffer.writeString("");
}
Rect.prototype.deserialize_external = function(buffer) {
	let position_is_set = false, size_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "position":
				buffer.readInt32();
				(this.position || (this.position = new _Vector2())).deserialize_external(buffer);
				position_is_set = true;
				break;
			case "size":
				buffer.readInt32();
				(this.size || (this.size = new _Vector2())).deserialize_external(buffer);
				size_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!position_is_set) this.position = new Vector2(0.0, 0.0, null);
				if(!size_is_set) this.size = new Vector2(0.0, 0.0, null);
				return;
		}
	}
}
function Grid(size, items) {
	this.size = size?.clone();
	this.items = items;
	for(let i=0; i<this.size.x * this.size.y; ++i) {
		this.items.push(null);
	}
}
Grid.prototype.get = function(x, y) {
	return this.items[y * this.size.x + x];
}
Grid.prototype.get2 = function(position) {
	return (new Vector2(0, 0).lessOrEqual(position?.toVector2()) && position.less(this.size) ? this.items[position.y * this.size.x + position.x] : null);
}
Grid.prototype.set = function(x, y, value) {
	this.items[y * this.size.x + x] = value;
}
Grid.prototype.set2 = function(position, value) {
	this.items[position.y * this.size.x + position.x] = value;
}
Grid.prototype.count = function(predicate) {
	let count = 0;
	for(let i=0, _subject=this.items, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(predicate(it)) {
			count++;
		}
	}}
	return count;
}
Grid.prototype.isValid = function(pos) {
	return new Vector2(0, 0).lessOrEqual(pos?.toVector2()) && pos.less(this.size);
}
function _Grid() {};
_Grid.prototype = Grid.prototype;
function Texture(file, size, imageOrCanvas, context) {
	this.file = file;
	this.size = size?.clone();
	this.imageOrCanvas = imageOrCanvas;
	this.context = context;
	if(Platform.engineStarted && this.file) {
		this.open();
	}
}
Texture.prototype.ensureIsAvailable = function() {
	if(!this.imageOrCanvas && this.file) {
		this.imageOrCanvas = _htmlImageCache[this.file]
	}
	return this.imageOrCanvas != null
}
Texture.prototype.open = function() {
	if(!window._htmlImageCache) _htmlImageCache = {}
	let image = _htmlImageCache[this.file]
	if(!image) {
		return new Promise((resolve, reject) => {
			image = new Image()
			image.onload = e => {
				this.imageOrCanvas = image
				window._htmlImageCache[this.file] = image
				this.size = new Vector2(image.width, image.height, null)
				resolve(this);
			}
			image.src = Platform.getAbsoluteUrl(this.file)
		})
	} else {
		this.imageOrCanvas = image
		this.size = new Vector2(image.width, image.height, null)
		return this
	}
}
Texture.prototype.setSize = function(size) {
	if((size.x != this.size.x || size.y != this.size.y) && this.imageOrCanvas) {
		this.imageOrCanvas.width = size.x
		this.imageOrCanvas.height = size.y
	}
	this.size.assign(size);
}
Texture.prototype.modify = function(visibleFor, $do) {
	let isVisible = graphics.isVisibleFor(visibleFor)
	if(isVisible) {
		
		var prevContext = graphics.context
		var prevPixelSizeX = graphics.pixelSize.x
		var prevPixelSizeY = graphics.pixelSize.y
		var prevItems = graphics.items
		var prevFastForward = Platform.fastForward
		
		
		if(!this.context) {
			this.imageOrCanvas = document.createElement("canvas")
			this.imageOrCanvas.width = this.size.x
			this.imageOrCanvas.height = this.size.y
			this.context = this.imageOrCanvas.getContext("2d")
		}
		
		
		graphics.context = this.context
		graphics.pixelSize.x = this.size.x
		graphics.pixelSize.y = this.size.y
		graphics.items = []
		Platform.fastForward = false
		var a = graphics.localMatrix.matrix, b = graphics.totalMatrix.matrix
		var a0 = graphics.localMatrix.m0, a1 = graphics.localMatrix.m1, a2 = graphics.localMatrix.m2, a3 = graphics.localMatrix.m3, a4 = graphics.localMatrix.m4, a5 = graphics.localMatrix.m5
		var b0 = graphics.totalMatrix.m0, b1 = graphics.totalMatrix.m1, b2 = graphics.totalMatrix.m2, b3 = graphics.totalMatrix.m3, b4 = graphics.totalMatrix.m4, b5 = graphics.totalMatrix.m5
		graphics.localMatrix.set(1, 0, 0, 1, -this.size.x/2, -this.size.y/2)
		graphics.totalMatrix.set(1, 0, 0, 1, this.size.x/2, this.size.y/2)
		graphics.context.clearRect(0, 0, graphics.pixelSize.x, graphics.pixelSize.y)
		graphics.context.textBaseline = "top"
	}
	
	
	$do()
		
	if(isVisible) {
		
		graphics.drawItems()
		
		
		graphics.localMatrix.m0 = a0; graphics.localMatrix.m1 = a1; graphics.localMatrix.m2 = a2; graphics.localMatrix.m3 = a3; graphics.localMatrix.m4 = a4; graphics.localMatrix.m5 = a5
		graphics.totalMatrix.m0 = b0; graphics.totalMatrix.m1 = b1; graphics.totalMatrix.m2 = b2; graphics.totalMatrix.m3 = b3; graphics.totalMatrix.m4 = b4; graphics.totalMatrix.m5 = b5
		graphics.context = prevContext
		graphics.pixelSize.x = prevPixelSizeX
		graphics.pixelSize.y = prevPixelSizeY
		graphics.items = prevItems
		Platform.fastForward = Platform.fastForward
	}
}
Texture.prototype.clone = function() {
	let clone = new _Texture();
	clone.file = this.file;
	clone.size = this.size.clone();
	clone.imageOrCanvas = this.imageOrCanvas;
	clone.context = this.context;
	return clone;
}
function _Texture() {};
_Texture.prototype = Texture.prototype;
Texture.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.file);
	(this.size || new _Vector2()).serialize_internal(buffer);
}
Texture.prototype.deserialize_internal = function(buffer) {
	this.file = buffer.readString();
	(this.size || (this.size = new _Vector2())).deserialize_internal(buffer);
}
Texture.prototype.serialize_external = function(buffer) {
	buffer.writeString("file");
	buffer.writeString(this.file);
	buffer.writeString("size");
	let size_startPos = buffer.reserveSize();
	(this.size || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(size_startPos);
	buffer.writeString("");
}
Texture.prototype.deserialize_external = function(buffer) {
	let file_is_set = false, size_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "file":
				this.file = buffer.readString();
				file_is_set = true;
				break;
			case "size":
				buffer.readInt32();
				(this.size || (this.size = new _Vector2())).deserialize_external(buffer);
				size_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!file_is_set) this.file = "";
				if(!size_is_set) this.size = new Vector2(0.0, 0.0, null);
				return;
		}
	}
}
function ImageFrame(x1, y1, x2, y2, w, h) {
	this.x1 = x1;
	this.y1 = y1;
	this.x2 = x2;
	this.y2 = y2;
	this.w = w;
	this.h = h;
}
ImageFrame.prototype.clone = function() {
	let clone = new _ImageFrame();
	clone.x1 = this.x1;
	clone.y1 = this.y1;
	clone.x2 = this.x2;
	clone.y2 = this.y2;
	clone.w = this.w;
	clone.h = this.h;
	return clone;
}
function _ImageFrame() {};
_ImageFrame.prototype = ImageFrame.prototype;
ImageFrame.prototype.serialize_internal = function(buffer) {
	buffer.writeFloat64(this.x1);
	buffer.writeFloat64(this.y1);
	buffer.writeFloat64(this.x2);
	buffer.writeFloat64(this.y2);
	buffer.writeFloat64(this.w);
	buffer.writeFloat64(this.h);
}
ImageFrame.prototype.deserialize_internal = function(buffer) {
	this.x1 = buffer.readFloat64();
	this.y1 = buffer.readFloat64();
	this.x2 = buffer.readFloat64();
	this.y2 = buffer.readFloat64();
	this.w = buffer.readFloat64();
	this.h = buffer.readFloat64();
}
ImageFrame.prototype.serialize_external = function(buffer) {
	buffer.writeString("x1");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.x1);
	buffer.writeString("y1");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.y1);
	buffer.writeString("x2");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.x2);
	buffer.writeString("y2");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.y2);
	buffer.writeString("w");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.w);
	buffer.writeString("h");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.h);
	buffer.writeString("");
}
ImageFrame.prototype.deserialize_external = function(buffer) {
	let x1_is_set = false, y1_is_set = false, x2_is_set = false, y2_is_set = false, w_is_set = false, h_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "x1":
				buffer.readInt32();
				this.x1 = buffer.readFloat64();
				x1_is_set = true;
				break;
			case "y1":
				buffer.readInt32();
				this.y1 = buffer.readFloat64();
				y1_is_set = true;
				break;
			case "x2":
				buffer.readInt32();
				this.x2 = buffer.readFloat64();
				x2_is_set = true;
				break;
			case "y2":
				buffer.readInt32();
				this.y2 = buffer.readFloat64();
				y2_is_set = true;
				break;
			case "w":
				buffer.readInt32();
				this.w = buffer.readFloat64();
				w_is_set = true;
				break;
			case "h":
				buffer.readInt32();
				this.h = buffer.readFloat64();
				h_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!x1_is_set) this.x1 = 0.0;
				if(!y1_is_set) this.y1 = 0.0;
				if(!x2_is_set) this.x2 = 0.0;
				if(!y2_is_set) this.y2 = 0.0;
				if(!w_is_set) this.w = 0.0;
				if(!h_is_set) this.h = 0.0;
				return;
		}
	}
}
function ClippingPath(points, show) {
	this.points = points;
	this.show = show;
}
ClippingPath.prototype.clone = function() {
	let clone = new _ClippingPath();
	clone.points = this.points;
	clone.show = this.show;
	return clone;
}
function _ClippingPath() {};
_ClippingPath.prototype = ClippingPath.prototype;
ClippingPath.prototype.serialize_internal = function(buffer) {
	let points = this.points
	if(points) {
		var index = _objectCacheIndex.get(points);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(points, index = _objectCache.length);
			_objectCache.push(points);
			buffer.writeInt32(-index);
			points._objectIndex = index;
			buffer.writeInt32(points.length);
			for(let i=0, len=points.length; i<len; ++i) {
				(points[i] || new _Vector2()).serialize_internal(buffer);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeBool(this.show);
}
ClippingPath.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this.points = _objectCache[index];
	} else {
		let points = this.points
		if(!points || points._objectIndex != -index) this.points = points = [];
		_objectCache[-index] = points;
		for(let i=0, len = points.length = buffer.readInt32(); i<len; ++i) {
				(points[i] || (points[i] = new _Vector2())).deserialize_internal(buffer);
		}
	}
	this.show = buffer.readBool();
}
ClippingPath.prototype.serialize_external = function(buffer) {
	buffer.writeString("points");
	let points = this.points
	let points_startPos = buffer.reserveSize();
	if(points) {
		var index = _objectCacheIndex.get(points);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(points, index = _objectCache.length);
			_objectCache.push(points);
			buffer.writeInt32(-index);
			points._objectIndex = index;
			buffer.writeInt32(points.length);
			for(let i=0, len=points.length; i<len; ++i) {
				(points[i] || new _Vector2()).serialize_external(buffer);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(points_startPos);
	buffer.writeString("show");
	buffer.writeInt32(1);
	buffer.writeBool(this.show);
	buffer.writeString("");
}
ClippingPath.prototype.deserialize_external = function(buffer) {
	let points_is_set = false, show_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "points":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.points = _objectCache[index];
				} else {
					let points = this.points
					if(!points || points._objectIndex != -index) this.points = points = [];
					_objectCache[-index] = points;
					for(let i=0, len = points.length = buffer.readInt32(); i<len; ++i) {
							(points[i] || (points[i] = new _Vector2())).deserialize_external(buffer);
					}
				}
				points_is_set = true;
				break;
			case "show":
				buffer.readInt32();
				this.show = buffer.readBool();
				show_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!points_is_set) this.points = [];
				if(!show_is_set) this.show = false;
				return;
		}
	}
}
function TextHighlight(from, to, color, backgroundColor, cornerRadius, padding, margin, wrap) {
	this.from = from;
	this.to = to;
	this.color = color;
	this.backgroundColor = backgroundColor;
	this.cornerRadius = cornerRadius;
	this.padding = padding?.clone();
	this.margin = margin?.clone();
	this.wrap = wrap;
}
TextHighlight.prototype.clone = function() {
	let clone = new _TextHighlight();
	clone.from = this.from;
	clone.to = this.to;
	clone.color = this.color;
	clone.backgroundColor = this.backgroundColor;
	clone.cornerRadius = this.cornerRadius;
	clone.padding = this.padding.clone();
	clone.margin = this.margin.clone();
	clone.wrap = this.wrap;
	return clone;
}
function _TextHighlight() {};
_TextHighlight.prototype = TextHighlight.prototype;
TextHighlight.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.from);
	buffer.writeString(this.to);
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let backgroundColor = this.backgroundColor
	if(backgroundColor) {
		var index = _objectCacheIndex.get(backgroundColor);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(backgroundColor, index = _objectCache.length);
			_objectCache.push(backgroundColor);
			buffer.writeInt32(-index);
			backgroundColor._objectIndex = index;
			backgroundColor.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeFloat64(this.cornerRadius);
	(this.padding || new _Vector2()).serialize_internal(buffer);
	(this.margin || new _Vector2()).serialize_internal(buffer);
	buffer.writeBool(this.wrap);
}
TextHighlight.prototype.deserialize_internal = function(buffer) {
	this.from = buffer.readString();
	this.to = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.color = _objectCache[index];
	} else {
		let color = this.color
		if(!color || color._objectIndex != -index)
			this.color = color = new _Color();
		(_objectCache[-index] = color).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.backgroundColor = _objectCache[index];
	} else {
		let backgroundColor = this.backgroundColor
		if(!backgroundColor || backgroundColor._objectIndex != -index)
			this.backgroundColor = backgroundColor = new _Color();
		(_objectCache[-index] = backgroundColor).deserialize_internal(buffer);
	}
	this.cornerRadius = buffer.readFloat64();
	(this.padding || (this.padding = new _Vector2())).deserialize_internal(buffer);
	(this.margin || (this.margin = new _Vector2())).deserialize_internal(buffer);
	this.wrap = buffer.readBool();
}
TextHighlight.prototype.serialize_external = function(buffer) {
	buffer.writeString("from");
	buffer.writeString(this.from);
	buffer.writeString("to");
	buffer.writeString(this.to);
	buffer.writeString("color");
	let color_startPos = buffer.reserveSize();
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(color_startPos);
	buffer.writeString("backgroundColor");
	let backgroundColor_startPos = buffer.reserveSize();
	let backgroundColor = this.backgroundColor
	if(backgroundColor) {
		var index = _objectCacheIndex.get(backgroundColor);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(backgroundColor, index = _objectCache.length);
			_objectCache.push(backgroundColor);
			buffer.writeInt32(-index);
			backgroundColor._objectIndex = index;
			backgroundColor.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(backgroundColor_startPos);
	buffer.writeString("cornerRadius");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.cornerRadius);
	buffer.writeString("padding");
	let padding_startPos = buffer.reserveSize();
	(this.padding || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(padding_startPos);
	buffer.writeString("margin");
	let margin_startPos = buffer.reserveSize();
	(this.margin || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(margin_startPos);
	buffer.writeString("wrap");
	buffer.writeInt32(1);
	buffer.writeBool(this.wrap);
	buffer.writeString("");
}
TextHighlight.prototype.deserialize_external = function(buffer) {
	let from_is_set = false, to_is_set = false, color_is_set = false, backgroundColor_is_set = false, cornerRadius_is_set = false, padding_is_set = false, margin_is_set = false, wrap_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "from":
				this.from = buffer.readString();
				from_is_set = true;
				break;
			case "to":
				this.to = buffer.readString();
				to_is_set = true;
				break;
			case "color":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.color = _objectCache[index];
				} else {
					let color = this.color
					if(!color || color._objectIndex != -index)
						this.color = color = new _Color();
					(_objectCache[-index] = color).deserialize_external(buffer);
				}
				color_is_set = true;
				break;
			case "backgroundColor":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.backgroundColor = _objectCache[index];
				} else {
					let backgroundColor = this.backgroundColor
					if(!backgroundColor || backgroundColor._objectIndex != -index)
						this.backgroundColor = backgroundColor = new _Color();
					(_objectCache[-index] = backgroundColor).deserialize_external(buffer);
				}
				backgroundColor_is_set = true;
				break;
			case "cornerRadius":
				buffer.readInt32();
				this.cornerRadius = buffer.readFloat64();
				cornerRadius_is_set = true;
				break;
			case "padding":
				buffer.readInt32();
				(this.padding || (this.padding = new _Vector2())).deserialize_external(buffer);
				padding_is_set = true;
				break;
			case "margin":
				buffer.readInt32();
				(this.margin || (this.margin = new _Vector2())).deserialize_external(buffer);
				margin_is_set = true;
				break;
			case "wrap":
				buffer.readInt32();
				this.wrap = buffer.readBool();
				wrap_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!from_is_set) this.from = "";
				if(!to_is_set) this.to = "";
				if(!color_is_set) this.color = null;
				if(!backgroundColor_is_set) this.backgroundColor = null;
				if(!cornerRadius_is_set) this.cornerRadius = 0.0;
				if(!padding_is_set) this.padding = new Vector2(0.0, 0.0, null);
				if(!margin_is_set) this.margin = new Vector2(0.0, 0.0, null);
				if(!wrap_is_set) this.wrap = true;
				return;
		}
	}
}
var graphics; if(!graphics) graphics = {};
graphics.init = function() {
	graphics.canvas = null;
	graphics.context = null;
	graphics.baseMatrix = new Matrix2D(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
	graphics.totalMatrix = new Matrix2D(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
	graphics.localMatrix = new Matrix2D(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
	graphics.items = [];
	graphics.alignmentFactor = [0, .5, 1];
	graphics.referenceSize = new Vector2(1920, 1080, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 8165, 8177, null, null));
	graphics.drawingOrder = 0/*ItemsDrawnFirstWillBeInFront*/;
	graphics.scaleMode = 0/*Auto*/;
	graphics.effectiveScaleMode = 0/*Auto*/;
	graphics.anchor = 2/*Center*/;
	graphics.topAndBottomMarginColor = null;
	graphics.leftAndRightMarginColor = null;
	graphics.pixelSize = new Vector2(0.0, 0.0, null);
	graphics.size = new Vector2(0.0, 0.0, null);
	graphics.pixelRatio = 0.0;
	graphics.currentClippingPath = null;
	graphics.currentlyVisibleFor = null;
	graphics.backgroundColor = Color.Black;
	_constCache.push(graphics.backgroundColor);
	graphics.defaultColors = [new Color("#398CA9", "Blue"), new Color("#C01352", "Red"), new Color("#16C66E", "Green"), new Color("#FFD166", "Yellow")];
	graphics.darkDefaultColors = [new Color("#193742", "Dark Blue"), new Color("#470B21", "Dark Red"), new Color("#0A3620", "Dark Green"), new Color("#4B3F21", "Dark Yellow")];
	graphics.currentColor = new Color("#ffffff", "");
	graphics.currentFont = Font.OpenSans;
	graphics.currentFontSize = 64;
	graphics.currentLineWidth = 8;
	graphics.currentAlpha = 1.0;
	graphics.scaleAsPointerGetsCloserBy = null;
	graphics.scaleAsPointerGetsCloserFactor = 1;
	graphics.scaleAsPointerGetsCloserRadius = 0;
}
graphics.setup = async function(referenceSize) {
	graphics.referenceSize.assign(referenceSize);
}
graphics.onResize = function() {
	graphics.canvas = document.getElementById("canvas");
	graphics.pixelRatio = window.devicePixelRatio;
	graphics.pixelSize = new Vector2(window.innerWidth*graphics.pixelRatio, window.innerHeight*graphics.pixelRatio, null);
	graphics.isSmallScreen = screen.width < 600 || (localStorage.getItem("smallScreen") == "true")
	graphics.canvas.style.width = window.innerWidth + "px";
	graphics.canvas.style.height = window.innerHeight + "px";
	graphics.canvas.width = graphics.pixelSize.x;
	graphics.canvas.height = graphics.pixelSize.y;
	graphics.canvas.imageSmoothingEnabled = true;
	graphics.canvas.imageSmoothingQuality = "high";
	
	graphics.context = graphics.canvas.getContext("2d");
	graphics.updateBaseMatrix()
}
graphics.updateBaseMatrix = function() {
	let statisticsMargin = (Platform.showDebugInfo ? statistics.margin : new Vector2(0.0, 0.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 9731, 9733, null, null)))?.clone();
	let referenceSizeWithMargin = graphics.referenceSize.plus(statisticsMargin);
	let ratio = new Vector2(graphics.pixelSize.x / referenceSizeWithMargin.x, graphics.pixelSize.y / referenceSizeWithMargin.y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 9817, 9899, null, null));
	let scale = 0.0;
	if(graphics.scaleMode == 0/*Auto*/) {
		if(ratio.x < ratio.y) {
			graphics.effectiveScaleMode = 1/*FixedWidth*/;
			scale = ratio.x;
		} else {
			graphics.effectiveScaleMode = 2/*FixedHeight*/;
			scale = ratio.y;
		}
	} else {
		graphics.effectiveScaleMode = graphics.scaleMode;
	}
	if(graphics.effectiveScaleMode == 1/*FixedWidth*/) {
		scale = ratio.x;
		graphics.size.assign(new Vector2(graphics.referenceSize.x, graphics.pixelSize.y / scale, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 10199, 10235, null, null)));
	} else {
		if(graphics.effectiveScaleMode == 2/*FixedHeight*/) {
			scale = ratio.y;
			graphics.size.assign(new Vector2(graphics.pixelSize.x / scale, graphics.referenceSize.y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 10313, 10349, null, null)));
		}
	}
	let offsetX = (graphics.anchor > 0/*TopLeft*/ ? graphics.pixelSize.x / 2 : 0);
	let offsetY = (graphics.anchor > 1/*TopCenter*/ ? graphics.pixelSize.y / 2 : 0);
	graphics.baseMatrix.assign(new Matrix2D(scale, 0, 0, scale, offsetX - (statisticsMargin.x / 2) * scale, offsetY - (statisticsMargin.y / 2) * scale));
}
graphics.startFrame = function() {
	graphics.reset()
	if(!Platform.fastForward && !Platform.waitingForInitialData)
		if(!graphics.backgroundColor || graphics.backgroundColor.hex == "#000000") {
			graphics.context.clearRect(0, 0, graphics.pixelSize.x, graphics.pixelSize.y)
		} else {
			graphics.context.fillStyle = graphics.backgroundColor.hex
			graphics.context.fillRect(0, 0, graphics.pixelSize.x, graphics.pixelSize.y)
		}
		graphics.context.textBaseline = "top"
}
graphics.reset = function() {
	graphics.totalMatrix.assign(graphics.baseMatrix);
	graphics.localMatrix.clear();
	graphics.currentlyVisibleFor = null;
	graphics.items.length = 0;
}
graphics.finishFrame = function() {
	if(Platform.fastForward) {
		return;
	}
	for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if((it != null)) {
			it.videoElementIndex = 0;
		}
	}}
	graphics.drawItems();
	graphics.drawMargins();
	for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let user = _subject[i]; {
		if((user != null)) {
			for(let i=user.videoElementIndex; i<user.videoElements.length; ++i) {
				PeerNetwork.removeVideoElement(user.videoElements[i]);
			}
			user.videoElements.setLength(user.videoElementIndex);
			PeerNetwork.setAudioMuted(user.audioElement, core.muteInvisibleUsers && user.videoElementIndex == 0);
		}
	}}
}
graphics.drawItems = function() {
	core.displayItems = graphics.items.length;
	gizmo.tick();
	graphics.items.sort((a,b) => b.layer - a.layer);
	if(graphics.drawingOrder == 0/*ItemsDrawnFirstWillBeInFront*/) {
		for(let _subject=graphics.items, i=_subject.length-1; i>=0; --i) { let it = _subject[i]; {
			it.draw();
		}}
	} else {
		for(let i=0, _subject=graphics.items, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			it.draw();
		}}
	}
	graphics.resetTransform();
}
graphics.resetTransform = function() {
	graphics.context.resetTransform()
	graphics.context.globalAlpha = 1
}
graphics.isVisibleFor = function(visibleFor) {
	if(Platform.fastForward) {
		return false;
	}
	let effectiveVisibleFor = ((visibleFor != null && visibleFor.length != 0)  && (visibleFor.length != 1 || (visibleFor[0] != null)) ? visibleFor : graphics.currentlyVisibleFor);
	return effectiveVisibleFor == null || effectiveVisibleFor.some(a => a == null || a.id == input.localUser.id);
}
graphics.getClickableBy = function(visibleFor, clickableBy) {
	let effectiveVisibleBy = visibleFor || graphics.currentlyVisibleFor;
	return ((effectiveVisibleBy != null && effectiveVisibleBy.length != 0)  && (clickableBy != null && clickableBy.length != 0)  ? effectiveVisibleBy.intersectWith(clickableBy) : effectiveVisibleBy || clickableBy || input.players);
}
graphics.drawMargins = function() {
	if(graphics.effectiveScaleMode == 1) {
		if(graphics.topAndBottomMarginColor) {
			
			graphics.resetTransform()
			graphics.context.fillStyle = graphics.topAndBottomMarginColor.hex
			let ratio = graphics.pixelSize.x / graphics.referenceSize.x
			let margin = (graphics.pixelSize.y-graphics.referenceSize.y*ratio)/2
			graphics.context.fillRect(0,0,graphics.pixelSize.x, margin)
			graphics.context.fillRect(0,graphics.pixelSize.y-margin,graphics.pixelSize.x, margin)
		}
	} else 
	if(graphics.effectiveScaleMode == 2) {
		if(graphics.leftAndRightMarginColor) {
			
			graphics.resetTransform()
			graphics.context.fillStyle = graphics.leftAndRightMarginColor.hex
			let ratio = graphics.pixelSize.y / graphics.referenceSize.y
			let margin = (graphics.pixelSize.x-graphics.referenceSize.x*ratio)/2
			graphics.context.fillRect(0, 0, margin, graphics.pixelSize.y)
			graphics.context.fillRect(graphics.pixelSize.x-margin, 0, margin, graphics.pixelSize.y)
		}
	}
}
graphics.drawImage = function(image, position, size, visibleFor, frame, layer, alpha, color, align, valign, location) {
	if(!image?.texture?.ensureIsAvailable()) return
	if(graphics.isVisibleFor(visibleFor)) {
		let f = image.frames[frame % image.frames.length]
		let sizeX = size.x || f.w
		let sizeY = size.y || (sizeX/f.w)*f.h
		let factor = graphics.getScaleImagesAsPointerGetsCloserFactor(position)
		if(factor > 1) { sizeX *= factor; sizeY *= factor }
		graphics.items.push(new DisplayImage(
			graphics.totalMatrix,
			align == 0 ? position.x : align == 1 ? position.x-sizeX*.5 : position.x-sizeX,
			valign == 0 ? position.y : valign == 1 ? position.y-sizeY*.5 : position.y-sizeY,
			sizeX, sizeY,
			layer, alpha * graphics.currentAlpha, graphics.currentClippingPath, image.file,
			location, position.location, size.location,
			image.texture.imageOrCanvas,
			f.x1, f.y1, f.w, f.h,
			color
		))
	}
}
graphics.drawImage2 = function(image, position, size, visibleFor, frame, layer, alpha, color, angle, flipX, flipY, location) {
	if(angle == 0 && !flipX && !flipY) {
		graphics.drawImage(image, position, size, visibleFor, frame, layer, alpha, color, 1, 1, location)
	} else {
		if(!image.texture?.ensureIsAvailable()) return
		if(graphics.isVisibleFor(visibleFor)) {
			let f = image.frames[frame % image.frames.length]
			let sizeX = size.x || f.w
			let sizeY = size.y || (sizeX/f.w)*f.h
			let factor = graphics.getScaleImagesAsPointerGetsCloserFactor(position)
			if(factor > 1) { sizeX *= factor; sizeY *= factor }
			let matrix = graphics.totalMatrix.clone()
			matrix.move(position)
			matrix.rotate(angle)
			if(flipX || flipY) matrix.scale(new Vector2(flipX ? -1:1, flipY ? -1:1 ))
			graphics.items.push(new DisplayImage(
				matrix,
				-sizeX/2,
				-sizeY/2,
				sizeX, sizeY,
				layer, alpha * graphics.currentAlpha, graphics.currentClippingPath, image.file, 
				location, position.location, size.location,
				image.texture.imageOrCanvas,
				f.x1, f.y1, f.w, f.h,
				color
			))
		}
	}
}
graphics.drawImage3 = function(image, position, size, visibleFor, framesPerSecond, layer, alpha, color, location) {
	var _value;
	let frame = (_value = image.frames.length, ((Math.floor(core.frame * Math.max(framesPerSecond, 0) / core.targetFps) % _value) + _value) % _value);
	graphics.drawImage(image, position, size, visibleFor, frame, layer, alpha, color, 1/*Center*/, 1/*Middle*/, location);
}

graphics.drawImage4 = function(image, position, size, visibleFor, framesPerSecond, layer, alpha, color, angle, flipX, flipY, location) {
	var _value;
	let frame = (_value = image.frames.length, ((Math.floor(core.frame * Math.max(framesPerSecond, 0) / core.targetFps) % _value) + _value) % _value);
	graphics.drawImage2(image, position, size, visibleFor, frame, layer, alpha, color, angle, flipX, flipY, location);
}

graphics.drawImage5 = function(image, position, size, visibleFor, clickableBy, frame, layer, alpha, color, angle, flipX, flipY, clickableMargin, showClickableArea, hotkey, onClick, location) {
	graphics.drawImage2(image, position, size, visibleFor, frame, layer, alpha, color, angle, flipX, flipY, location);
	let effectiveClickableBy = graphics.getClickableBy(visibleFor, clickableBy);
	if((effectiveClickableBy != null && effectiveClickableBy.length != 0) ) {
		if(size.x == 0 && size.y == 0) {
			size.assign(image.size);
		} else {
			if(size.y == 0) {
				size.y = size.x * image.size.y / image.size.x;
			}
		}
		input.onTouchDown(position, size.plus(clickableMargin), effectiveClickableBy, "auto", showClickableArea, true, 1/*Center*/, 1/*Middle*/, onClick);
		if(hotkey) {
			input.onKeyDown2(hotkey, false, false, false, effectiveClickableBy, (key,pressedBy,cmdOrCtrl,alt,shift) => {
				onClick(null);
			});
		}
	}
}
graphics.drawText = function(text, position, size, color, align, valign, style, font, outlineColor, outlineWidth, layer, alpha, angle, visibleFor, clickableBy, clickableMargin, showClickableArea, hotkey, overflow, maxWidth, lineHeight, onClick, location) {
	let isVisible = graphics.isVisibleFor(visibleFor);
	let effectiveFont = font || graphics.currentFont;
	let fontSize = Math.floor(size.y || size.x || graphics.currentFontSize);
	let sizeX = 0.0, sizeY = 0.0;
	let lines = null;
	let lineOffsets = null;
	let effectiveLineHeight = 0.0;
	let offsetX = 0.0, offsetY = 0.0;
	if((overflow == 1/*Wrap*/ || overflow == 3/*WrapAndScale*/) && maxWidth) {
		let word = "";
		let words = [];
		for(let i=0; i<text.length; ++i) {
			let c = text[i];
			if(c == " ") {
				if(word) {
					words.push(word);
				}
				word = "";
			} else {
				if(c == "\n") {
					words.push(word + "\n");
					word = "";
				} else {
					word += c;
				}
			}
		}
		if(word) {
			words.push(word);
		}
		let spaceWidth = graphics.getTextWidth(" ", new Vector2(fontSize, 0.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 29757, 29769, null, null)), effectiveFont, style);
		lines = [];
		let totalWidth = 0.0;
		let line = "";
		for(let i=0, _subject=words, _len=_subject.length; i<_len; ++i) { let word = _subject[i]; {
			let wordWidth = graphics.getTextWidth(word, new Vector2(fontSize, 0.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 29904, 29916, null, null)), effectiveFont, style);
			if(totalWidth + wordWidth > maxWidth) {
				if(line) {
					lines.push(line);
					line = word + " ";
					totalWidth = wordWidth + spaceWidth;
				} else {
					lines.push(word);
					line = "";
					totalWidth = 0;
				}
			} else {
				line += word + " ";
				totalWidth += wordWidth + spaceWidth;
			}
			if(word[word.length - 1] == "\n") {
				lines.push(line);
				line = "";
				totalWidth = 0;
			}
		}}
		if(line) {
			lines.push(line);
		}
		let widestLine = "";
		sizeX = -1;
		lineOffsets = [];
		let factor = -graphics.alignmentFactor[align];
		for(let i=0, _subject=lines, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			let lineSizeX = graphics.getTextWidth(it, new Vector2(fontSize, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 30752, 30760, null, null)), null, 0/*Normal*/);
			lineOffsets.push(lineSizeX * factor);
			if(lineSizeX > sizeX) {
				sizeX = lineSizeX;
				widestLine = it;
			}
		}}
		if(overflow == 3/*WrapAndScale*/ && sizeX > maxWidth) {
			fontSize = Math.floor(fontSize * maxWidth / sizeX);
			sizeX = graphics.getTextWidth(widestLine, new Vector2(fontSize, 0.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 31030, 31042, null, null)), effectiveFont, style);
			while(sizeX > maxWidth) {
				sizeX = graphics.getTextWidth(widestLine, new Vector2(--fontSize, 0.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 31131, 31145, null, null)), effectiveFont, style);
			}
			for(let i=0, _subject=lines, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
				lineOffsets[i] = graphics.getTextWidth(it, new Vector2(fontSize, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 31231, 31239, null, null)), null, 0/*Normal*/) * factor;
			}}
		}
		effectiveLineHeight = lineHeight || fontSize * 1.3;
		sizeY = lines.length * effectiveLineHeight - (effectiveLineHeight - fontSize * effectiveFont.actualHeightFactor);
	} else {
		if(isVisible || onClick != null) {
			sizeX = graphics.getTextWidth(text, new Vector2(fontSize, 0.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 31502, 31514, null, null)), effectiveFont, style);
			if(overflow == 2/*Scale*/ && maxWidth) {
				if(sizeX > maxWidth) {
					fontSize = Math.floor(fontSize * maxWidth / sizeX);
					sizeX = graphics.getTextWidth(text, new Vector2(fontSize, 0.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 31708, 31720, null, null)), effectiveFont, style);
					while(sizeX > maxWidth) {
						sizeX = graphics.getTextWidth(text, new Vector2(--fontSize, 0.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 31807, 31821, null, null)), effectiveFont, style);
					}
				}
			}
		}
		effectiveLineHeight = effectiveLineHeight || fontSize * 1.5;
		sizeY = fontSize * effectiveFont.actualHeightFactor;
		offsetX = -graphics.alignmentFactor[align] * sizeX;
	}
	offsetY = -graphics.alignmentFactor[valign] * sizeY;
	if(isVisible) {
		let matrix = new Matrix2D(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
		let x = 0.0, y = 0.0;
		if(!angle) {
			matrix.assign(graphics.totalMatrix);
			x = position.x;
			y = position.y;
		} else {
			matrix.assign(graphics.totalMatrix.clone().move(position).rotate(angle));
			x = 0;
			y = 0;
		}
		graphics.items.push(new DisplayText(matrix, x + offsetX, y + offsetY, sizeX, sizeY, layer, alpha * graphics.currentAlpha, graphics.currentClippingPath, text, location, position.location, size.location, (color || graphics.currentColor).hex, ((outlineColor != null) ? outlineColor.hex : null), outlineWidth || graphics.currentLineWidth, effectiveFont.offset.y * sizeY, ((style ? "bold " : "")) + fontSize?.toString() + "px " + effectiveFont.name, lines, lineOffsets, effectiveLineHeight));
	}
	if(onClick != null) {
		let effectiveClickableBy = graphics.getClickableBy(visibleFor, clickableBy);
		if((effectiveClickableBy != null && effectiveClickableBy.length != 0) ) {
			let effectiveSize = new Vector2(sizeX + clickableMargin.x, sizeY + clickableMargin.y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 32924, 32978, null, null));
			input.onTouchDown(position, effectiveSize, effectiveClickableBy, "auto", showClickableArea, true, 1/*Center*/, 1/*Middle*/, onClick);
			if(hotkey) {
				input.onKeyDown2(hotkey, false, false, false, effectiveClickableBy, (key,pressedBy,cmdOrCtrl,alt,shift) => {
					onClick?.(null);
				});
			}
		}
	}
	return sizeY;
}
graphics.drawTextWithHighlight = function(text, position, highlights, size, color, align, valign, style, font, outlineColor, outlineWidth, layer, alpha, angle, visibleFor, clickableBy, clickableMargin, showClickableArea, hotkey, overflow, maxWidth, lineHeight, onClick, location) {
	let isVisible = graphics.isVisibleFor(visibleFor);
	let effectiveFont = font || graphics.currentFont;
	let fontSize = Math.floor(size.y || size.x || graphics.currentFontSize);
	let sizeX = 0.0, sizeY = 0.0;
	let effectiveLineHeight = lineHeight || fontSize * 1.3;
	let offsetX = 0.0, offsetY = 0.0;
	let word = "";
	let words = [];
	for(let i=0; i<text.length; ++i) {
		let c = text[i];
		if(c == " ") {
			if(word) {
				words.push(word);
			}
			word = "";
		} else {
			if(c == "\n") {
				words.push(word + "\n");
				word = "";
			} else {
				word += c;
			}
		}
	}
	if(word) {
		words.push(word);
	}
	let spaceWidth = graphics.getTextWidth(" ", new Vector2(fontSize, 0.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 37316, 37328, null, null)), effectiveFont, style);
	let segment = new TextSegment("", null, new Vector2(0.0, 0.0, null), new Vector2(0.0, 0.0, null));
	let segments = [segment];
	let highlight = null;
	for(let i=0, _subject=words, _len=_subject.length; i<_len; ++i) { let word = _subject[i]; {
		let suffix = "", prefix = "";
		let suffixWidth = 0.0, prefixWidth = 0.0;
		let startHighlight = null, endHighlight = null;
		let startIndex = 0;
		let expectedSegmentWidth = segment.size.x;
		if(!(highlight != null)) {
			for(let i=0, _subject=highlights, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
				startIndex = word.indexOf(it.from);
				if(startIndex != -1) {
					startHighlight = it;
					if(startIndex > 0) {
						prefix = word.substring(0, startIndex);
						prefixWidth = graphics.getTextWidth(prefix, new Vector2(fontSize, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 37910, 37918, null, null)), effectiveFont, style);
						expectedSegmentWidth += prefixWidth;
					}
					word = word.substring(startIndex + 1);
					expectedSegmentWidth += it.margin.x + it.padding.x * 2;
					break;
				}
			}}
		}
		if((highlight != null) || (startHighlight != null)) {
			for(let i=0, _subject=highlights, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
				let endIndex = word.indexOf(it.to, startIndex + 1);
				if(endIndex != -1) {
					endHighlight = it;
					if(endIndex < word.length - 1) {
						suffix = word.substring(endIndex + 1);
						suffixWidth = graphics.getTextWidth(suffix, new Vector2(fontSize, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 38394, 38402, null, null)), effectiveFont, style);
						expectedSegmentWidth += suffixWidth;
					}
					word = word.substring(0, endIndex);
					break;
				}
			}}
		}
		let wordWidth = graphics.getTextWidth(word, new Vector2(fontSize, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 38586, 38594, null, null)), effectiveFont, style);
		if(segment.text || segment.position.x > 0) {
			expectedSegmentWidth += spaceWidth;
			if((highlight != null)) {
				expectedSegmentWidth += highlight.margin.x;
			}
			if(segment.position.x + expectedSegmentWidth + wordWidth > maxWidth) {
				if(highlight == null || highlight.wrap) {
					segments.push(segment = new TextSegment("", highlight, new Vector2(0, segment.position.y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 39029, 39052, null, null)), ((highlight != null) ? highlight.padding.multiply2(2) : new Vector2(0.0, 0.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 39104, 39106, null, null)))));
				}
				segment.position.x = 0;
				segment.position.y += effectiveLineHeight;
			}
		}
		if(segment.text || segment.position.x > 0) {
			segment.text += " ";
			segment.size.x += spaceWidth;
		}
		if((startHighlight != null)) {
			if(prefix) {
				segment.text += prefix;
				segment.size.x += prefixWidth;
			}
			highlight = startHighlight;
			segments.push(segment = new TextSegment("", highlight, new Vector2(segment.position.x + segment.size.x + highlight.margin.x, segment.position.y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 39507, 39585, null, null)), highlight.padding.multiply2(2)));
		}
		segment.text += word;
		segment.size.x += wordWidth;
		if((endHighlight != null)) {
			segments.push(segment = new TextSegment("", null, new Vector2(segment.position.x + segment.size.x + highlight.margin.x, segment.position.y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 39782, 39860, null, null)), new Vector2(0.0, 0.0, null)));
			highlight = null;
			if(suffix) {
				segment.text += suffix;
				segment.size.x += suffixWidth;
			}
		}
		if(segment.text[segment.text.length - 1] == "\n") {
			segments.push(segment = new TextSegment("", highlight, new Vector2(0, segment.position.y + effectiveLineHeight, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 40054, 40099, null, null)), ((highlight != null) ? highlight.padding.multiply2(2) : new Vector2(0.0, 0.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 40151, 40153, null, null)))));
		}
	}}
	let factor = graphics.alignmentFactor[align];
	let lineStartIndex = 0;
	let lineWidth = 0.0;
	for(let i=0; i<segments.length + 1; ++i) { let index = i; {
		let s = segments[index];
		if(!(s != null) || segment.position.x == 0) {
			for(let i=lineStartIndex; i<index; ++i) {
				segments[i].position.x -= lineWidth * factor;
			}
			lineStartIndex = index;
		}
		if(index < segments.length) {
			lineWidth += s.size.x;
		}
	}}
	for(let i=0, _subject=segments, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		it.size.y = fontSize;
	}}
	sizeY = ((segments != null && segments.length != 0)  ? segments[segments.length-1].position.y + fontSize : 0);
	offsetY = -graphics.alignmentFactor[valign] * sizeY;
	if(isVisible) {
		let matrix = new Matrix2D(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
		let x = 0.0, y = 0.0;
		if(!angle) {
			matrix.assign(graphics.totalMatrix);
			x = position.x;
			y = position.y;
		} else {
			matrix.assign(graphics.totalMatrix.clone().move(position).rotate(angle));
			x = 0;
			y = 0;
		}
		graphics.items.push(new DisplayTextWithHighlights(matrix, x + offsetX, y + offsetY, sizeX, sizeY, layer, alpha * graphics.currentAlpha, graphics.currentClippingPath, text, location, position.location, size.location, (color || graphics.currentColor).hex, ((outlineColor != null) ? outlineColor.hex : null), outlineWidth || graphics.currentLineWidth, effectiveFont.offset.y * sizeY, ((style ? "bold " : "")) + fontSize?.toString() + "px " + effectiveFont.name, segments));
	}
	if(onClick != null) {
		let effectiveClickableBy = graphics.getClickableBy(visibleFor, clickableBy);
		if((effectiveClickableBy != null && effectiveClickableBy.length != 0) ) {
			let effectiveSize = new Vector2(sizeX + clickableMargin.x, sizeY + clickableMargin.y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 41499, 41553, null, null));
			input.onTouchDown(position, effectiveSize, effectiveClickableBy, "auto", showClickableArea, true, 1/*Center*/, 1/*Middle*/, onClick);
			if(hotkey) {
				input.onKeyDown2(hotkey, false, false, false, effectiveClickableBy, (key,pressedBy,cmdOrCtrl,alt,shift) => {
					onClick?.(null);
				});
			}
		}
	}
	return sizeY;
}
graphics.drawCircularText = function(text, position, size, color, font, layer, radius, angle, spacing, visibleFor, location) {
	let effectiveFont = font || graphics.currentFont;
	let fontSize = Math.floor(size || graphics.currentFontSize);
	let totalWidth = graphics.getTextWidth(text, new Vector2(fontSize, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 43452, 43460, null, null)), effectiveFont, 0/*Normal*/);
	let startAngle = angle - (totalWidth / 2 * spacing / radius);
	let prevWidth = 0.0;
	for(let i=0, _subject=text, _len=_subject.length; i<_len; ++i) { let letter = _subject[i]; {
		let width = graphics.getTextWidth(text.substring(0, i + 1), new Vector2(fontSize, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 43624, 43632, null, null)), effectiveFont, 0/*Normal*/);
		let centerOfLetter = (width + prevWidth) / 2;
		prevWidth = width;
		let angleOfLetter = startAngle + (centerOfLetter * spacing / radius);
		graphics.drawText(letter, position.plus(math.getVectorForAngle(angleOfLetter, radius)), new Vector2(fontSize, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 43864, 43872, null, null)), color, 1/*Center*/, 1/*Middle*/, 0/*Normal*/, effectiveFont, null, 0, layer, 1.0, angleOfLetter, visibleFor, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, location);
	}}
}
graphics.drawButton = function(image, text, position, size, frame, textColor, textSize, textOffset, clickableMargin, showClickableArea, scaleOnHover, frameOnHover, textColorOnHover, accentImage, accentColor, visibleFor, clickableBy, hotkey, layer, alpha, enabled, alphaWhenDisabled, onClick, location) {
	let scale = 1.0;
	let effectiveSize = ((image != null) ? graphics.getEffectiveSize(image.size, size) : new Vector2(graphics.getTextWidth(text, new Vector2(textSize, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 47652, 47660, null, null)), null, 0/*Normal*/), textSize, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 47627, 47672, null, null)))?.clone();
	let effectiveClickableBy = graphics.getClickableBy(visibleFor, clickableBy);
	if(enabled && (effectiveClickableBy != null && effectiveClickableBy.length != 0)  && onClick != null) {
		let sizeWithMargin = effectiveSize.plus(clickableMargin);
		let switchFrameOnHover = frameOnHover != -1 && frame == -1 && (image?.frames.length > frameOnHover || accentImage?.frames.length > frameOnHover);
		if(switchFrameOnHover || scaleOnHover != 1.0 || (textColorOnHover != null)) {
			input.onTouchOver(position, sizeWithMargin, effectiveClickableBy, "auto", false, true, 1/*Center*/, 1/*Middle*/, touch => {
				if((textColorOnHover != null)) {
					textColor = textColorOnHover;
				}
				if(switchFrameOnHover) {
					frame = frameOnHover;
				}
				if(scaleOnHover != 1.0) {
					scale = scaleOnHover;
				}
			});
		}
		input.onTouchDown(position, sizeWithMargin, effectiveClickableBy, "auto", showClickableArea, true, 1/*Center*/, 1/*Middle*/, onClick);
		if(hotkey) {
			input.onKeyDown2(hotkey, false, false, false, effectiveClickableBy, (key,pressedBy,cmdOrCtrl,alt,shift) => {
				onClick?.(null);
			});
		}
	}
	if(graphics.isVisibleFor(visibleFor)) {
		if(frame == -1) {
			frame = 0;
		}
		if(scale != 1.0) {
			textSize = Math.round(textSize * scale);
			effectiveSize.multiplyAssign2(scale);
		}
		let effectiveAlpha = (enabled ? alpha : alpha * alphaWhenDisabled);
		if(text) {
			graphics.drawText(text, position.plus(textOffset), new Vector2(textSize, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 48816, 48824, null, null)), textColor, 1/*Center*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, layer, effectiveAlpha, 0.0, visibleFor, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, location);
		}
		if((accentImage != null)) {
			if(!(accentColor != null)) {
				if((effectiveClickableBy != null && effectiveClickableBy.length != 0)  && (effectiveClickableBy[0] != null)) {
					accentColor = effectiveClickableBy[0].color;
				} else {
					accentColor = input.localPlayer.color;
				}
			}
			graphics.drawImage(accentImage, position, effectiveSize, visibleFor, frame, layer, effectiveAlpha, accentColor, 1/*Center*/, 1/*Middle*/, location);
		}
		if((image != null)) {
			graphics.drawImage(image, position, effectiveSize, visibleFor, frame, layer, effectiveAlpha, Color.White, 1/*Center*/, 1/*Middle*/, location);
		}
	}
}
graphics.drawRectangle = function(position, size, color, outlineColor, outlineWidth, visibleFor, layer, alpha, align, valign, location) {
	if(graphics.isVisibleFor(visibleFor)) {
		let sizeX = size.x
		let sizeY = size.y || size.x
		graphics.items.push(new DisplayRectangle(
			graphics.totalMatrix,
			align == 0 ? position.x : align == 1 ? position.x-sizeX*.5 : position.x-sizeX,
			valign == 0 ? position.y : valign == 1 ? position.y-sizeY*.5 : position.y-sizeY,
			sizeX, sizeY,
			layer, alpha * graphics.currentAlpha, graphics.currentClippingPath, "Rectangle", 
			location, position.location, size.location,
			color || !outlineColor ? (color || graphics.currentColor).hex : null,
			outlineColor ? outlineColor.hex : null,
			outlineWidth || graphics.currentLineWidth
		))
	}
}
graphics.drawRoundedRectangle = function(position, size, radius, color, outlineColor, outlineWidth, visibleFor, layer, alpha, align, valign) {
	if(graphics.isVisibleFor(visibleFor)) {
		let sizeX = size.x
		let sizeY = size.y || size.x
		graphics.items.push(new DisplayRoundedRectangle(
			graphics.totalMatrix,
			align == 0 ? position.x : align == 1 ? position.x-sizeX*.5 : position.x-sizeX,
			valign == 0 ? position.y : valign == 1 ? position.y-sizeY*.5 : position.y-sizeY,
			sizeX, sizeY,
			layer, alpha * graphics.currentAlpha, graphics.currentClippingPath, "RoundedRectangle", 
			location, position.location, size.location,
			radius,
			color || !outlineColor ? (color || graphics.currentColor).hex : null,
			outlineColor ? outlineColor.hex : null,
			outlineWidth || graphics.currentLineWidth
		))
	}
}
graphics.drawCircle = function(position, size, color, outlineColor, outlineWidth, startAngle, angle, direction, visibleFor, layer, alpha, location) {
	if(graphics.isVisibleFor(visibleFor)) {
		let sizeX = size.x, sizeY = size.y || size.x
		graphics.items.push(new DisplayCircle(
			graphics.totalMatrix, 
			position.x - sizeX/2, 
			position.y - sizeY/2, 
			sizeX, sizeY,
			layer, alpha * graphics.currentAlpha, graphics.currentClippingPath, "Circle", 
			location, position.location, size.location,
			startAngle, angle,
			direction == 1,
			color || !outlineColor ? (color || graphics.currentColor).hex : null,
			outlineColor ? outlineColor.hex : null,
			outlineWidth || graphics.currentLineWidth
		))
	}
}
graphics.drawLine = function(from, to, color, width, visibleFor, layer, alpha) {
	if(graphics.isVisibleFor(visibleFor)) {
		graphics.items.push(new DisplayLine(
			graphics.totalMatrix,
			from.x, from.y,
			to.x - from.x, to.y - from.y,
			layer, alpha * graphics.currentAlpha, graphics.currentClippingPath, "Line", 
			location, from.location, null,
			to,
			(color || graphics.currentColor).hex,
			width || graphics.currentLineWidth
		))
	}
}
graphics.drawLines = function(points, position, color, width, smooth, visibleFor, layer, alpha) {
	if(graphics.isVisibleFor(visibleFor)) {
		graphics.items.push(new DisplayPolygon(
			graphics.totalMatrix,
			position.x, position.y,
			0, 0,
			layer, alpha * graphics.currentAlpha, graphics.currentClippingPath, "Line", 
			location, position.location, null,
			points,
			null, 
			(color || graphics.currentColor).hex,
			width || graphics.currentLineWidth,
			smooth, /*close*/false
		))
	}
}
graphics.drawPolygon = function(points, position, color, outlineColor, outlineWidth, smooth, visibleFor, layer, alpha) {
	if(graphics.isVisibleFor(visibleFor)) {
		graphics.items.push(new DisplayPolygon(
			graphics.totalMatrix,
			position.x, position.y,
			0, 0,
			layer, alpha * graphics.currentAlpha, graphics.currentClippingPath, "Polygon", 
			location, position.location, null,
			points,
			color || !outlineColor ? (color || graphics.currentColor).hex : null,
			outlineColor ? outlineColor.hex : null,
			outlineWidth || graphics.currentLineWidth,
			smooth, /*close*/true
		))
	}
}
graphics.drawVideo = function(player, position, size, shape, visibleFor, location) {
	if(graphics.isVisibleFor(visibleFor)) {
		if(!size.y) {
			size.y = (shape == 0/*Rectangle*/ ? size.x * 3 / 4 : size.x);
		}
		if(core.mode == 2/*Local*/ || !PeerNetwork.enableVideo) {
			graphics.drawImage($Image.VideoScreen, position, size, null, (shape == 2/*Circle*/ ? 1 : 0), 1000000, 1.0, Color.White, 1/*Center*/, 1/*Middle*/, location);
		} else {
			graphics.items.push(new DisplayVideo(graphics.totalMatrix, position.x, position.y, size.x, size.y, 1000000, 1.0, graphics.currentClippingPath, "Video", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 63621, 63804, null, null), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 63621, 63804, null, null), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 63621, 63804, null, null), player.id, shape));
		}
	}
}
graphics.drawPointer = function(player, mode, color) {
	if(mode == 3/*LocalAndRemote*/ || (player.id == input.localUser.id && mode == 1/*Local*/) || (player.id != input.localUser.id && mode == 2/*Remote*/)) {
		if(!(color != null)) {
			color = player.color;
		}
		for(let i=0, _subject=player.touches, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			graphics.drawImage($Image.finger, it.smoothPosition.plus(new Vector2(11, 32, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 64798, 64805, null, null))), new Vector2(0.0, 0.0, null), null, (it.isDown ? 1 : 0), int.maxValue, 1.0, Color.White, 1/*Center*/, 1/*Middle*/, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 64764, 64848, null, null));
			if((color != null)) {
				if(color?.hex == Color.Black?.hex) {
					graphics.drawRectangle(it.smoothPosition.plus(new Vector2(16, 80, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 64921, 64928, null, null))), new Vector2(26, 10, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 64935, 64942, null, null)), color, new Color("#a0a0a0", ""), 2, null, int.maxValue, 1.0, 1/*Center*/, 1/*Middle*/, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 64891, 65011, null, null));
				} else {
					graphics.drawRectangle(it.smoothPosition.plus(new Vector2(16, 78, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 65058, 65065, null, null))), new Vector2(26, 10, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 65072, 65079, null, null)), color, null, 0, null, int.maxValue, 1.0, 1/*Center*/, 1/*Middle*/, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 65028, 65106, null, null));
				}
			}
		}}
	}
}
graphics.drawTexture = function(texture, position, size, visibleFor, layer, alpha, color) {
	if(!texture?.ensureIsAvailable()) return
	if(graphics.isVisibleFor(visibleFor)) {
		let sizeX = size.x || texture.size.x
		let sizeY = size.y || (sizeX/texture.size.x)*texture.size.y
		graphics.items.push(new DisplayImage(
			graphics.totalMatrix,
			position.x - sizeX/2,
			position.y - sizeY/2,
			sizeX, sizeY,
			layer, alpha * graphics.currentAlpha, graphics.currentClippingPath, texture.file,
			location, position.location, size.location,
			texture.imageOrCanvas,
			0, 0, texture.size.x, texture.size.y,
			color
		))
	}
}
graphics.drawTexture2 = function(texture, position, size, sourcePosition, sourceSize, visibleFor, layer, alpha, color) {
	if(!texture?.ensureIsAvailable()) return
	if(graphics.isVisibleFor(visibleFor)) {
		let sizeX = size.x || texture.size.x
		let sizeY = size.y || (sizeX/texture.size.x)*texture.size.y
		graphics.items.push(new DisplayImage(
			graphics.totalMatrix,
			position.x - sizeX/2,
			position.y - sizeY/2,
			sizeX, sizeY,
			layer, alpha * graphics.currentAlpha, graphics.currentClippingPath, texture.file, 
			location, position.location, size.location,
			texture.imageOrCanvas,
			sourcePosition.x+texture.size.x/2-sourceSize.x/2,
			sourcePosition.y+texture.size.y/2-sourceSize.y/2,
			sourceSize.x, 
			sourceSize.y,
			color
		))
	}
}
graphics.clearRectangle = function(position, size, visibleFor, layer, align, valign) {
	if(graphics.isVisibleFor(visibleFor)) {
		let sizeX = size.x
		let sizeY = size.y || size.x
		graphics.items.push(new DisplayRectangle(
			graphics.totalMatrix,
			align == 0 ? position.x : align == 1 ? position.x-sizeX*.5 : position.x-sizeX,
			valign == 0 ? position.y : valign == 1 ? position.y-sizeY*.5 : position.y-sizeY,
			sizeX, sizeY,
			layer, 1, graphics.currentClippingPath, "Clear", 
			location, position.location, size.location,
			"clear", null, 0
		))
	}
}
graphics.move = function(distance, code) {
	let a0 = graphics.localMatrix.m0, a1 = graphics.localMatrix.m1, a2 = graphics.localMatrix.m2, a3 = graphics.localMatrix.m3, a4 = graphics.localMatrix.m4, a5 = graphics.localMatrix.m5;
	let b0 = graphics.totalMatrix.m0, b1 = graphics.totalMatrix.m1, b2 = graphics.totalMatrix.m2, b3 = graphics.totalMatrix.m3, b4 = graphics.totalMatrix.m4, b5 = graphics.totalMatrix.m5;
	graphics.localMatrix.move(distance);
	graphics.totalMatrix.move(distance);
	code();
	graphics.localMatrix.m0 = a0;
	graphics.localMatrix.m1 = a1;
	graphics.localMatrix.m2 = a2;
	graphics.localMatrix.m3 = a3;
	graphics.localMatrix.m4 = a4;
	graphics.localMatrix.m5 = a5;
	graphics.totalMatrix.m0 = b0;
	graphics.totalMatrix.m1 = b1;
	graphics.totalMatrix.m2 = b2;
	graphics.totalMatrix.m3 = b3;
	graphics.totalMatrix.m4 = b4;
	graphics.totalMatrix.m5 = b5;
}
graphics.rotate = function(angle, code) {
	if(angle == 0) {
		code();
		return;
	}
	let a0 = graphics.localMatrix.m0, a1 = graphics.localMatrix.m1, a2 = graphics.localMatrix.m2, a3 = graphics.localMatrix.m3, a4 = graphics.localMatrix.m4, a5 = graphics.localMatrix.m5;
	let b0 = graphics.totalMatrix.m0, b1 = graphics.totalMatrix.m1, b2 = graphics.totalMatrix.m2, b3 = graphics.totalMatrix.m3, b4 = graphics.totalMatrix.m4, b5 = graphics.totalMatrix.m5;
	graphics.localMatrix.rotate(angle);
	graphics.totalMatrix.rotate(angle);
	code();
	graphics.localMatrix.m0 = a0;
	graphics.localMatrix.m1 = a1;
	graphics.localMatrix.m2 = a2;
	graphics.localMatrix.m3 = a3;
	graphics.localMatrix.m4 = a4;
	graphics.localMatrix.m5 = a5;
	graphics.totalMatrix.m0 = b0;
	graphics.totalMatrix.m1 = b1;
	graphics.totalMatrix.m2 = b2;
	graphics.totalMatrix.m3 = b3;
	graphics.totalMatrix.m4 = b4;
	graphics.totalMatrix.m5 = b5;
}
graphics.scale = function(factor, code) {
	if(factor == 1) {
		code();
		return;
	}
	let a0 = graphics.localMatrix.m0, a1 = graphics.localMatrix.m1, a2 = graphics.localMatrix.m2, a3 = graphics.localMatrix.m3, a4 = graphics.localMatrix.m4, a5 = graphics.localMatrix.m5;
	let b0 = graphics.totalMatrix.m0, b1 = graphics.totalMatrix.m1, b2 = graphics.totalMatrix.m2, b3 = graphics.totalMatrix.m3, b4 = graphics.totalMatrix.m4, b5 = graphics.totalMatrix.m5;
	graphics.localMatrix.scale(new Vector2(factor, factor, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 73904, 73920, null, null)));
	graphics.totalMatrix.scale(new Vector2(factor, factor, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 73941, 73957, null, null)));
	code();
	graphics.localMatrix.m0 = a0;
	graphics.localMatrix.m1 = a1;
	graphics.localMatrix.m2 = a2;
	graphics.localMatrix.m3 = a3;
	graphics.localMatrix.m4 = a4;
	graphics.localMatrix.m5 = a5;
	graphics.totalMatrix.m0 = b0;
	graphics.totalMatrix.m1 = b1;
	graphics.totalMatrix.m2 = b2;
	graphics.totalMatrix.m3 = b3;
	graphics.totalMatrix.m4 = b4;
	graphics.totalMatrix.m5 = b5;
}
graphics.transform = function(move, rotate, scale, code) {
	let a0 = graphics.localMatrix.m0, a1 = graphics.localMatrix.m1, a2 = graphics.localMatrix.m2, a3 = graphics.localMatrix.m3, a4 = graphics.localMatrix.m4, a5 = graphics.localMatrix.m5;
	let b0 = graphics.totalMatrix.m0, b1 = graphics.totalMatrix.m1, b2 = graphics.totalMatrix.m2, b3 = graphics.totalMatrix.m3, b4 = graphics.totalMatrix.m4, b5 = graphics.totalMatrix.m5;
	if(move?.toBool()) {
		graphics.localMatrix.move(move);
		graphics.totalMatrix.move(move);
	}
	if(scale != 1) {
		graphics.localMatrix.scale(new Vector2(scale, scale, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 75357, 75371, null, null)));
		graphics.totalMatrix.scale(new Vector2(scale, scale, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 75393, 75407, null, null)));
	}
	if(rotate) {
		graphics.localMatrix.rotate(rotate);
		graphics.totalMatrix.rotate(rotate);
	}
	code();
	graphics.localMatrix.m0 = a0;
	graphics.localMatrix.m1 = a1;
	graphics.localMatrix.m2 = a2;
	graphics.localMatrix.m3 = a3;
	graphics.localMatrix.m4 = a4;
	graphics.localMatrix.m5 = a5;
	graphics.totalMatrix.m0 = b0;
	graphics.totalMatrix.m1 = b1;
	graphics.totalMatrix.m2 = b2;
	graphics.totalMatrix.m3 = b3;
	graphics.totalMatrix.m4 = b4;
	graphics.totalMatrix.m5 = b5;
}
graphics.applyMatrix = function(matrix, code) {
	let a0 = graphics.localMatrix.m0, a1 = graphics.localMatrix.m1, a2 = graphics.localMatrix.m2, a3 = graphics.localMatrix.m3, a4 = graphics.localMatrix.m4, a5 = graphics.localMatrix.m5;
	let b0 = graphics.totalMatrix.m0, b1 = graphics.totalMatrix.m1, b2 = graphics.totalMatrix.m2, b3 = graphics.totalMatrix.m3, b4 = graphics.totalMatrix.m4, b5 = graphics.totalMatrix.m5;
	graphics.localMatrix.multiplyLeft(matrix);
	graphics.totalMatrix.multiplyLeft(matrix);
	code();
	graphics.localMatrix.m0 = a0;
	graphics.localMatrix.m1 = a1;
	graphics.localMatrix.m2 = a2;
	graphics.localMatrix.m3 = a3;
	graphics.localMatrix.m4 = a4;
	graphics.localMatrix.m5 = a5;
	graphics.totalMatrix.m0 = b0;
	graphics.totalMatrix.m1 = b1;
	graphics.totalMatrix.m2 = b2;
	graphics.totalMatrix.m3 = b3;
	graphics.totalMatrix.m4 = b4;
	graphics.totalMatrix.m5 = b5;
}
graphics.clip = function(points, position, show, code) {
	let prev = graphics.currentClippingPath;
	graphics.currentClippingPath = new ClippingPath([], show);
	for(let i=0, _subject=points, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		graphics.currentClippingPath.points.push(position.plus(it));
	}}
	code();
	graphics.currentClippingPath = prev;
}
graphics.visibleFor = function(player, code) {
	let prev = graphics.currentlyVisibleFor;
	graphics.currentlyVisibleFor = player;
	code();
	graphics.currentlyVisibleFor = prev;
	return graphics.currentlyVisibleFor;
}
graphics.color = function() {
	return graphics.currentColor;
}
graphics.color2 = function(color) {
	graphics.currentColor = color;
	return graphics.currentColor;
}
graphics.color3 = function(color, code) {
	let prev = graphics.currentColor;
	graphics.currentColor = color;
	code();
	graphics.currentColor = prev;
	return graphics.currentColor;
}
graphics.font = function() {
	return graphics.currentFont;
}
graphics.font2 = function(font) {
	graphics.currentFont = font;
	return graphics.currentFont;
}
graphics.font3 = function(font, code) {
	let prev = graphics.currentFont;
	graphics.currentFont = font;
	code();
	graphics.currentFont = prev;
	return graphics.currentFont;
}
graphics.fontSize = function() {
	return graphics.currentFontSize;
}
graphics.fontSize2 = function(fontSize) {
	graphics.currentFontSize = fontSize;
	return graphics.currentFontSize;
}
graphics.fontSize3 = function(fontSize, code) {
	let prev = graphics.currentFontSize;
	graphics.currentFontSize = fontSize;
	code();
	graphics.currentFontSize = prev;
	return graphics.currentFontSize;
}
graphics.lineWidth = function() {
	return graphics.currentLineWidth;
}
graphics.lineWidth2 = function(lineWidth) {
	graphics.currentLineWidth = lineWidth;
	return graphics.currentLineWidth;
}
graphics.lineWidth3 = function(lineWidth, code) {
	let prev = graphics.currentLineWidth;
	graphics.currentLineWidth = lineWidth;
	code();
	graphics.currentLineWidth = prev;
	return graphics.currentLineWidth;
}
graphics.alpha = function() {
	return graphics.currentAlpha;
}
graphics.alpha2 = function(alpha) {
	graphics.currentAlpha = alpha;
	return graphics.currentAlpha;
}
graphics.alpha3 = function(alpha, code) {
	let prev = graphics.currentAlpha;
	graphics.currentAlpha = alpha;
	code();
	graphics.currentAlpha = prev;
	return graphics.currentAlpha;
}
graphics.getTextWidth = function(text, size, font, style) {
	if(!text) return 0
	let effectiveFont = font || graphics.currentFont
	let fontSize = size.y || size.x || graphics.currentFontSize
	graphics.context.font = (style ? "bold ":"")+fontSize+"px "+effectiveFont.name;
	let textSize = graphics.context.measureText(text)
	return textSize.width
}
graphics.getAbsolutPosition = function(position) {
	return position.transformed(graphics.localMatrix);
}
graphics.getRelativePosition = function(position) {
	return position.getRelativeTo(graphics.localMatrix);
}
graphics.getPixelPosition = function(position) {
	return position.transformed(graphics.totalMatrix).divide2(graphics.pixelRatio);
}
graphics.getPixelSize = function(size) {
	return size.multiply(new Vector2(graphics.totalMatrix.m0, graphics.totalMatrix.m3, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 83250, 83282, null, null))).divide2(graphics.pixelRatio);
}
graphics.getEffectiveSize = function(imageSize, size) {
	let sizeX = size.x || imageSize.x;
	let sizeY = size.y || (sizeX / imageSize.x) * imageSize.y;
	return new Vector2(sizeX, sizeY, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 83467, 83481, null, null));
}
graphics.scaleImagesAsPointerGetsCloser = function(by, factor, radius, $do) {
	let prevBy = graphics.scaleAsPointerGetsCloserBy;
	let prevFactor = graphics.scaleAsPointerGetsCloserFactor;
	let prevRadius = graphics.scaleAsPointerGetsCloserRadius;
	graphics.scaleAsPointerGetsCloserBy = by;
	graphics.scaleAsPointerGetsCloserFactor = factor;
	graphics.scaleAsPointerGetsCloserRadius = radius;
	$do();
	graphics.scaleAsPointerGetsCloserBy = prevBy;
	graphics.scaleAsPointerGetsCloserFactor = prevFactor;
	graphics.scaleAsPointerGetsCloserRadius = prevRadius;
}
graphics.getScaleImagesAsPointerGetsCloserFactor = function(position) {
	if(!graphics.scaleAsPointerGetsCloserRadius) {
		return 1.0;
	}
	let distance = ((graphics.scaleAsPointerGetsCloserBy != null) ? graphics.scaleAsPointerGetsCloserBy.pointerPosition.distanceTo(position) : input.players.min2(a => a.pointerPosition.distanceTo(position), Number.MAX_VALUE, 0));
	return math.map(distance, 0, graphics.scaleAsPointerGetsCloserRadius, graphics.scaleAsPointerGetsCloserFactor, 1);
}
graphics.createImage = function(size, file, code) {
	let prevContext = graphics.context
	let prevPixelSizeX = graphics.pixelSize.x
	let prevPixelSizeY = graphics.pixelSize.y
	let prevItems = graphics.items
	graphics.items = []
	let canvas = document.createElement("canvas")
	canvas.width = size.x
	canvas.height = size.y
	graphics.context = canvas.getContext("2d")
	graphics.pixelSize.x = size.x
	graphics.pixelSize.y = size.y
	let a = graphics.localMatrix.matrix, b = graphics.totalMatrix.matrix
	let a0 = graphics.localMatrix.m0, a1 = graphics.localMatrix.m1, a2 = graphics.localMatrix.m2, a3 = graphics.localMatrix.m3, a4 = graphics.localMatrix.m4, a5 = graphics.localMatrix.m5
	let b0 = graphics.totalMatrix.m0, b1 = graphics.totalMatrix.m1, b2 = graphics.totalMatrix.m2, b3 = graphics.totalMatrix.m3, b4 = graphics.totalMatrix.m4, b5 = graphics.totalMatrix.m5
	graphics.localMatrix.set(1, 0, 0, 1, -size.x/2, -size.y/2)
	graphics.totalMatrix.set(1, 0, 0, 1, size.x/2, size.y/2)
	code()
	graphics.drawItems()
	var dataUrl = canvas.toDataURL("image/png");
	if(file) file.saveImage(dataUrl, file);
	graphics.localMatrix.m0 = a0; graphics.localMatrix.m1 = a1; graphics.localMatrix.m2 = a2; graphics.localMatrix.m3 = a3; graphics.localMatrix.m4 = a4; graphics.localMatrix.m5 = a5
	graphics.totalMatrix.m0 = b0; graphics.totalMatrix.m1 = b1; graphics.totalMatrix.m2 = b2; graphics.totalMatrix.m3 = b3; graphics.totalMatrix.m4 = b4; graphics.totalMatrix.m5 = b5
	graphics.context = prevContext
	graphics.pixelSize.x = prevPixelSizeX
	graphics.pixelSize.y = prevPixelSizeY
	graphics.items = prevItems
	return dataUrl
}
graphics.copyScreenshotToClipboard = function() {
	graphics.canvas.toBlob((blob) => {
		const item = new ClipboardItem({ 'image/png': blob });
		navigator.clipboard.write([item]);
		log("Copied screenshot to clipboard");
	});
}
graphics.accessPixel = function(code) {
	let imageData = graphics.context.getImageData(0,0,graphics.pixelSize.x, graphics.pixelSize.y)
	code(imageData.data)
	graphics.context.putImageData(imageData, 0, 0)
}
graphics.drawTimer = function(startTime, duration, completionSound, timeBeforeCompletionToPlaySound, onComplete) {
	let width = 8;
	let margin1 = 8;
	let margin2 = margin1 - width / 2;
	let completion = (Time.now - startTime) / duration;
	let time = (1 - completion) * 6000;
	graphics.drawLine(new Vector2(0, -540 + margin1, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 87828, 87856, null, null)), new Vector2(math.map(time, 0, 960, 0, -960 + margin2), -540 + margin1, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 87860, 87915, null, null)), null, width, null, 0, 1.0);
	graphics.drawLine(new Vector2(-960 + margin1, -540 + margin2, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 87934, 87962, null, null)), new Vector2(-960 + margin1, math.map(time, 960, 960 + 1080, -540 + margin2, 540 - margin2), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 87966, 88038, null, null)), null, width, null, 0, 1.0);
	graphics.drawLine(new Vector2(-960 + margin2, 540 - margin1, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 88057, 88085, null, null)), new Vector2(math.map(time, 960 + 1080, 960 + 1080 + 1920, -960 + margin2, 960 - margin2), 540 - margin1, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 88089, 88170, null, null)), null, width, null, 0, 1.0);
	graphics.drawLine(new Vector2(960 - margin1, 540 - margin2, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 88189, 88217, null, null)), new Vector2(960 - margin1, math.map(time, 960 + 1080 + 1920, 960 + 1080 + 1920 + 1080, 540 - margin2, -540 + margin2), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 88221, 88313, null, null)), null, width, null, 0, 1.0);
	graphics.drawLine(new Vector2(960 - margin2, -540 + margin1, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 88332, 88360, null, null)), new Vector2(math.map(time, 960 + 1080 + 1920 + 1080, 960 + 1080 + 1920 + 1080 + 960, 960 - margin2, 0), -540 + margin1, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 88364, 88454, null, null)), null, width, null, 0, 1.0);
	if((completionSound != null) && Time.now > startTime + duration - timeBeforeCompletionToPlaySound && !completionSound.isPlaying()) {
		audio.playSound(completionSound, 0, false);
	}
	if(onComplete != null && completion >= 1) {
		onComplete?.();
	}
}
graphics.setPlayerVideo = function(player, pos, size, shape) {
	let videoObject = graphics.getVideoObject(player);
	if(!(videoObject != null)) {
		videoObject = new VideoObject(new Vector2(0.0, 0.0, null), new Vector2(0.0, 0.0, null), 0.0, 1, null, 0, false, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 1581, 1600, null, null), player, 0/*Rectangle*/);
	}
	videoObject.position.assign(pos);
	videoObject.size.assign(size);
	videoObject.shape = shape;
	videoObject.locked = true;
}
graphics.getVideoObject = function(player) {
	for(let i=0, _subject=Framework.objects, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(it.type == "VideoObject") {
			let v = it;
			if(v.player.id == player.id) {
				return v;
			}
		}
	}}
	return null;
}
graphics.drawStandardButton = function(text, position, accentColor, visibleFor, clickableBy, hotkey, layer, alpha, enabled, onClick, location) {
	graphics.drawButton($Image.Button, text, position, new Vector2(0.0, 0.0, null), -1, null, 24, new Vector2(0, 0, null), new Vector2(16, 16, null), false, 1.0, 1, Color.Black, $Image.ButtonAccent, accentColor, visibleFor, clickableBy, hotkey, layer, alpha, enabled, .5, onClick, location);
}
graphics.drawLargeButton = function(text, position, accentColor, visibleFor, clickableBy, hotkey, layer, alpha, textSize, enabled, onClick, location) {
	graphics.drawButton($Image.LargeButton, text, position, new Vector2(0.0, 0.0, null), -1, null, textSize, new Vector2(0, 0, null), new Vector2(16, 16, null), false, 1.0, 1, Color.Black, $Image.LargeButtonAccent, accentColor, visibleFor, clickableBy, hotkey, layer, alpha, enabled, .5, onClick, location);
}
function GizomInfluence(file, start, end, deltas, initialValues, label) {
	this.file = file;
	this.start = start;
	this.end = end;
	this.deltas = deltas;
	this.initialValues = initialValues;
	this.label = label;
}
GizomInfluence.prototype.clone = function() {
	let clone = new _GizomInfluence();
	clone.file = this.file;
	clone.start = this.start;
	clone.end = this.end;
	clone.deltas = this.deltas;
	clone.initialValues = this.initialValues;
	clone.label = this.label;
	return clone;
}
function _GizomInfluence() {};
_GizomInfluence.prototype = GizomInfluence.prototype;
GizomInfluence.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.file);
	buffer.writeInt32(this.start);
	buffer.writeInt32(this.end);
	let deltas = this.deltas
	if(deltas) {
		var index = _objectCacheIndex.get(deltas);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(deltas, index = _objectCache.length);
			_objectCache.push(deltas);
			buffer.writeInt32(-index);
			deltas._objectIndex = index;
			buffer.writeInt32(deltas.length);
			for(let i=0, len=deltas.length; i<len; ++i) {
				buffer.writeFloat64(deltas[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let initialValues = this.initialValues
	if(initialValues) {
		var index = _objectCacheIndex.get(initialValues);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(initialValues, index = _objectCache.length);
			_objectCache.push(initialValues);
			buffer.writeInt32(-index);
			initialValues._objectIndex = index;
			buffer.writeInt32(initialValues.length);
			for(let i=0, len=initialValues.length; i<len; ++i) {
				buffer.writeFloat64(initialValues[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeString(this.label);
}
GizomInfluence.prototype.deserialize_internal = function(buffer) {
	this.file = buffer.readString();
	this.start = buffer.readInt32();
	this.end = buffer.readInt32();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.deltas = _objectCache[index];
	} else {
		let deltas = this.deltas
		if(!deltas || deltas._objectIndex != -index) this.deltas = deltas = [];
		_objectCache[-index] = deltas;
		for(let i=0, len = deltas.length = buffer.readInt32(); i<len; ++i) {
				deltas[i] = buffer.readFloat64();
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.initialValues = _objectCache[index];
	} else {
		let initialValues = this.initialValues
		if(!initialValues || initialValues._objectIndex != -index) this.initialValues = initialValues = [];
		_objectCache[-index] = initialValues;
		for(let i=0, len = initialValues.length = buffer.readInt32(); i<len; ++i) {
				initialValues[i] = buffer.readFloat64();
		}
	}
	this.label = buffer.readString();
}
GizomInfluence.prototype.serialize_external = function(buffer) {
	buffer.writeString("file");
	buffer.writeString(this.file);
	buffer.writeString("start");
	buffer.writeInt32(4);
	buffer.writeInt32(this.start);
	buffer.writeString("end");
	buffer.writeInt32(4);
	buffer.writeInt32(this.end);
	buffer.writeString("deltas");
	let deltas = this.deltas
	let deltas_startPos = buffer.reserveSize();
	if(deltas) {
		var index = _objectCacheIndex.get(deltas);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(deltas, index = _objectCache.length);
			_objectCache.push(deltas);
			buffer.writeInt32(-index);
			deltas._objectIndex = index;
			buffer.writeInt32(deltas.length);
			for(let i=0, len=deltas.length; i<len; ++i) {
				buffer.writeFloat64(deltas[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(deltas_startPos);
	buffer.writeString("initialValues");
	let initialValues = this.initialValues
	let initialValues_startPos = buffer.reserveSize();
	if(initialValues) {
		var index = _objectCacheIndex.get(initialValues);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(initialValues, index = _objectCache.length);
			_objectCache.push(initialValues);
			buffer.writeInt32(-index);
			initialValues._objectIndex = index;
			buffer.writeInt32(initialValues.length);
			for(let i=0, len=initialValues.length; i<len; ++i) {
				buffer.writeFloat64(initialValues[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(initialValues_startPos);
	buffer.writeString("label");
	buffer.writeString(this.label);
	buffer.writeString("");
}
GizomInfluence.prototype.deserialize_external = function(buffer) {
	let file_is_set = false, start_is_set = false, end_is_set = false, deltas_is_set = false, initialValues_is_set = false, label_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "file":
				this.file = buffer.readString();
				file_is_set = true;
				break;
			case "start":
				buffer.readInt32();
				this.start = buffer.readInt32();
				start_is_set = true;
				break;
			case "end":
				buffer.readInt32();
				this.end = buffer.readInt32();
				end_is_set = true;
				break;
			case "deltas":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.deltas = _objectCache[index];
				} else {
					let deltas = this.deltas
					if(!deltas || deltas._objectIndex != -index) this.deltas = deltas = [];
					_objectCache[-index] = deltas;
					for(let i=0, len = deltas.length = buffer.readInt32(); i<len; ++i) {
							deltas[i] = buffer.readFloat64();
					}
				}
				deltas_is_set = true;
				break;
			case "initialValues":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.initialValues = _objectCache[index];
				} else {
					let initialValues = this.initialValues
					if(!initialValues || initialValues._objectIndex != -index) this.initialValues = initialValues = [];
					_objectCache[-index] = initialValues;
					for(let i=0, len = initialValues.length = buffer.readInt32(); i<len; ++i) {
							initialValues[i] = buffer.readFloat64();
					}
				}
				initialValues_is_set = true;
				break;
			case "label":
				this.label = buffer.readString();
				label_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!file_is_set) this.file = "";
				if(!start_is_set) this.start = 0;
				if(!end_is_set) this.end = 0;
				if(!deltas_is_set) this.deltas = [];
				if(!initialValues_is_set) this.initialValues = [];
				if(!label_is_set) this.label = "";
				return;
		}
	}
}
function GizmoOverItem(item, location) {
	this.item = item;
	this.location = location;
}
GizmoOverItem.prototype.clone = function() {
	let clone = new _GizmoOverItem();
	clone.item = this.item;
	clone.location = this.location;
	return clone;
}
function _GizmoOverItem() {};
_GizmoOverItem.prototype = GizmoOverItem.prototype;
GizmoOverItem.prototype.serialize_internal = function(buffer) {
}
GizmoOverItem.prototype.deserialize_internal = function(buffer) {
}
GizmoOverItem.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
GizmoOverItem.prototype.deserialize_external = function(buffer) {
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				return;
		}
	}
}
var gizmo; if(!gizmo) gizmo = {};
gizmo.init = function() {
	gizmo.items = [];
	gizmo.min = new Vector2(0.0, 0.0, null);
	gizmo.max = new Vector2(0.0, 0.0, null);
	gizmo.cursorLocation = null;
	gizmo.cursorItem = null;
	gizmo.handleSize = 0.0;
	gizmo.overHandleDirection = null;
	gizmo.touchDownPos = new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 91092, 91124, null, null));
	gizmo.touchDownInsideGizmo = false;
	gizmo.locationIndex = 0;
	gizmo.waitingForCodeId = 0;
	gizmo.aspectRatio = 0.0;
	gizmo.isManipulating = false;
}
gizmo.findInfluencedItems = function() {
	gizmo.items.length = 0;
	gizmo.cursorLocation = null;
	if(!window._cursorFile) {
		return;
	}
	for(let i=0, _subject=graphics.items, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if((it.positionLocation != null) && ((gizmo.cursorLocation = it.positionLocation.find(_cursorFile, _cursorPos)) != null)) {
			gizmo.cursorItem = it;
			break;
		}
		if((it.location != null) && it.location.file == _cursorFile && _cursorPos >= it.location.start && _cursorPos <= it.location.end) {
			gizmo.cursorLocation = it.positionLocation?.leaf() || it.location;
			gizmo.cursorItem = it;
			break;
		}
	}}
	gizmo.min.x = Number.MAX_VALUE;
	gizmo.max.x = -Number.MAX_VALUE;
	gizmo.min.y = Number.MAX_VALUE;
	gizmo.max.y = -Number.MAX_VALUE;
	if(gizmo.cursorLocation != null) {
		for(let i=0, _subject=graphics.items, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			if(it.location == gizmo.cursorLocation || it.positionLocation?.find2(gizmo.cursorLocation) != null) {
				gizmo.items.push(it);
				if(it.x < gizmo.min.x) {
					gizmo.min.x = it.x;
				}
				if(it.y < gizmo.min.y) {
					gizmo.min.y = it.y;
				}
				if(it.x + it.w > gizmo.max.x) {
					gizmo.max.x = it.x + it.w;
				}
				if(it.y + it.h > gizmo.max.y) {
					gizmo.max.y = it.y + it.h;
				}
			}
		}}
	}
	gizmo.handleSize = math.map(Math.min(gizmo.max.x - gizmo.min.x, gizmo.max.y - gizmo.min.y), 64, 256, 16, 32);
}
gizmo.tick = function() {
	if(Platform.mode != 1/*Manipulator*/) {
		return;
	}
	gizmo.findInfluencedItems();
	if((gizmo.items != null && gizmo.items.length != 0) ) {
		let size = gizmo.max.minus(gizmo.min);
		let center = (gizmo.max.plus(gizmo.min)).divide2(2);
		for(let i=0, _subject=Direction.allDirections, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			graphics.drawImage($Image.ResizeHandle, center.plus(size.divide2(2).multiply(it.vector?.toVector2())), new Vector2(gizmo.handleSize, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 90830, 90840, null, null)), null, 0, int.maxValue, 1.0, Color.White, 1/*Center*/, 1/*Middle*/, null);
		}}
		graphics.drawRectangle(center, gizmo.max.minus(gizmo.min), null, new Color("#437FDF", ""), 4, null, int.maxValue, 1.0, 1/*Center*/, 1/*Middle*/, null);
	}
}
gizmo.clear = function() {
	gizmo.overHandleDirection = null;
	gizmo.touchDownPos.assign(new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null));
	gizmo.touchDownInsideGizmo = false;
	gizmo.locationIndex = 0;
	gizmo.waitingForCodeId = 0;
	gizmo.aspectRatio = 1;
	gizmo.items.length = 0;
	gizmo.min.assign(new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null));
	gizmo.max.assign(new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null));
}
gizmo.onTouch = function(InputType, id, pixelPos, referencePos, shift, alt, cmdOrCtrl) {
	var _value;
	if(Platform.mode != 1/*Manipulator*/) {
		return;
	}
	let movedSinceTouchDown = (referencePos.manhattanDistanceTo(gizmo.touchDownPos)) > 8;
	let insideGizmo = referencePos.greaterOrEqual(gizmo.min) && referencePos.lessOrEqual(gizmo.max);
	if(InputType == 1/*TouchDown*/) {
		gizmo.touchDownPos.assign(referencePos);
		gizmo.touchDownInsideGizmo = insideGizmo;
	} else {
		if(InputType == 3/*TouchUp*/) {
			gizmo.touchDownPos.assign(new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null));
			gizmo.isManipulating = false;
		}
	}
	if((gizmo.items != null && gizmo.items.length != 0)  && !gizmo.touchDownPos?.toBool()) {
		let center = (gizmo.min.plus(gizmo.max)).divide2(2);
		if(referencePos.manhattanDistanceTo(gizmo.max) < gizmo.handleSize) {
			gizmo.overHandleDirection = Direction.DownRight;
		} else {
			if(referencePos.manhattanDistanceTo(gizmo.min) < gizmo.handleSize) {
				gizmo.overHandleDirection = Direction.UpLeft;
			} else {
				if(referencePos.manhattanDistanceTo(new Vector2(gizmo.max.x, gizmo.min.y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 92394, 92408, null, null))) < gizmo.handleSize) {
					gizmo.overHandleDirection = Direction.UpRight;
				} else {
					if(referencePos.manhattanDistanceTo(new Vector2(gizmo.min.x, gizmo.max.y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 92511, 92525, null, null))) < gizmo.handleSize) {
						gizmo.overHandleDirection = Direction.DownLeft;
					} else {
						if(referencePos.manhattanDistanceTo(new Vector2(gizmo.max.x, center.y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 92629, 92646, null, null))) < gizmo.handleSize) {
							gizmo.overHandleDirection = Direction.Right;
						} else {
							if(referencePos.manhattanDistanceTo(new Vector2(gizmo.min.x, center.y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 92744, 92761, null, null))) < gizmo.handleSize) {
								gizmo.overHandleDirection = Direction.Left;
							} else {
								if(referencePos.manhattanDistanceTo(new Vector2(center.x, gizmo.min.y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 92858, 92875, null, null))) < gizmo.handleSize) {
									gizmo.overHandleDirection = Direction.Up;
								} else {
									if(referencePos.manhattanDistanceTo(new Vector2(center.x, gizmo.max.y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 92970, 92987, null, null))) < gizmo.handleSize) {
										gizmo.overHandleDirection = Direction.Down;
									} else {
										gizmo.overHandleDirection = null;
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if(!(gizmo.overHandleDirection != null) && _codeId >= gizmo.waitingForCodeId) {
		if((InputType == 1/*TouchDown*/ && !insideGizmo) || (InputType == 3/*TouchUp*/ && gizmo.touchDownInsideGizmo && !movedSinceTouchDown)) {
			let overItems = [];
			for(let i=0, _subject=graphics.items, _len=_subject.length; i<_len; ++i) { let item = _subject[i]; {
				if(pixelPos.isInsidePolygon(item.poly)) {
					if((item.positionLocation != null)) {
						gizmo.flattenLocations(overItems, item, item.positionLocation);
					} else {
						if((item.location != null)) {
							overItems.push(new GizmoOverItem(item, item.location));
						}
					}
				}
			}}
			if(overItems.length) {
				if(InputType == 1/*TouchDown*/) {
					gizmo.locationIndex = 0;
				}
				let selectedStackItem = overItems[(_value = overItems.length, ((gizmo.locationIndex++ % _value) + _value) % _value)];
				gizmo.cursorLocation = selectedStackItem.location;
				gizmo.cursorItem = selectedStackItem.item;
				Platform.sendSelectToEditor(gizmo.cursorLocation.file, gizmo.cursorLocation.start);
			} else {
				gizmo.locationIndex = 0;
				gizmo.cursorLocation = null;
				Platform.sendDeselectToEditor();
			}
		}
	}
	if((gizmo.cursorLocation != null)) {
		let influences = [];
		if((gizmo.overHandleDirection != null)) {
			let handle = gizmo.overHandleDirection.vector?.clone();
			let isOrthogonal = handle.x == 0 || handle.y == 0;
			let dx = (referencePos.x - gizmo.touchDownPos.x) * handle.x;
			let dy = (referencePos.y - gizmo.touchDownPos.y) * handle.y;
			let deltas = (shift || isOrthogonal ? [dx, dy] : (gizmo.aspectRatio < 1 ? [dx, dx * gizmo.aspectRatio] : [dy / gizmo.aspectRatio, dy]));
			gizmo.setCursor((isOrthogonal ? ((handle.y == 0 ? "ew-resize" : "ns-resize")) : ((handle.x == handle.y ? "nwse-resize" : "nesw-resize"))));
			for(let i=0, _subject=gizmo.items, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
				if((it.sizeLocation != null)) {
					influences.push(new GizomInfluence(it.sizeLocation.file, it.sizeLocation.start, it.sizeLocation.end, deltas, [], ""));
				} else {
					influences.push(new GizomInfluence(gizmo.cursorLocation.file, gizmo.cursorLocation.start, gizmo.cursorLocation.end, deltas, [it.w, it.h], "size"));
				}
			}}
			if(!cmdOrCtrl) {
				if(gizmo.cursorItem.location != gizmo.cursorLocation) {
					influences.push(new GizomInfluence(gizmo.cursorLocation.file, gizmo.cursorLocation.start, gizmo.cursorLocation.end, [.5 * deltas[0] * handle.x, .5 * deltas[1] * handle.y], [], ""));
				} else {
					influences.push(new GizomInfluence(gizmo.cursorLocation.file, gizmo.cursorLocation.end, gizmo.cursorLocation.end, [.5 * deltas[0] * handle.x, .5 * deltas[1] * handle.y], [0, 0], "position"));
				}
			} else {
				if(gizmo.cursorItem.location != gizmo.cursorLocation) {
					influences.push(new GizomInfluence(gizmo.cursorLocation.file, gizmo.cursorLocation.start, gizmo.cursorLocation.end, [0, 0], [], ""));
				}
			}
		} else {
			gizmo.setCursor("auto");
			if(gizmo.cursorItem.location != gizmo.cursorLocation) {
				influences.push(new GizomInfluence(gizmo.cursorLocation.file, gizmo.cursorLocation.start, gizmo.cursorLocation.end, [referencePos.x - gizmo.touchDownPos.x, referencePos.y - gizmo.touchDownPos.y], [], ""));
			} else {
				influences.push(new GizomInfluence(gizmo.cursorLocation.file, gizmo.cursorLocation.end, gizmo.cursorLocation.end, [referencePos.x - gizmo.touchDownPos.x, referencePos.y - gizmo.touchDownPos.y], [0, 0], "position"));
			}
		}
		if(InputType == 2/*TouchMove*/ && gizmo.touchDownPos?.toBool() && _codeId >= gizmo.waitingForCodeId) {
			if(!gizmo.isManipulating && movedSinceTouchDown) {
				gizmo.isManipulating = true;
				gizmo.aspectRatio = (gizmo.max.y - gizmo.min.y) / (gizmo.max.x - gizmo.min.x);
				Platform.sendStartManipulationToEditor(influences);
			}
			if(gizmo.isManipulating) {
				Platform.sendMoveManipulationToEditor(influences, ++gizmo.waitingForCodeId);
			}
		}
	}
}

gizmo.setCursor = function(cursor) {
	document.body.style.cursor = cursor
}
gizmo.flattenLocations = function(stack, item, location) {
	if(location.file) {
		stack.push(new GizmoOverItem(item, location));
	}
	if((location.right != null)) {
		gizmo.flattenLocations(stack, item, location.right);
	}
	if((location.left != null)) {
		gizmo.flattenLocations(stack, item, location.left);
	}
}
var awardScreen; if(!awardScreen) awardScreen = {};
awardScreen.init = function() {
	awardScreen.active = false;
}
awardScreen.tick = function() {
	input.onKeyDown(18/*Alt*/, 87/*W*/, null, (key,pressedBy,cmdOrCtrl,alt,shift) => {
		awardScreen.active = !awardScreen.active;
	});
	if(awardScreen.active) {
		let size = new Vector2(720, 540);
		for(let i=0, _subject=input.players, _center = new Vector2(0, 0, null), _delta = size, _grid=new IntVector2(2, 2, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 97707, 97712, null, null)), _y=0, _yPos=_center.y-(_grid.y-1)*_delta.y/2; _y<_grid.y; ++_y, _yPos += _delta.y) for(let _x=0, _xPos = _center.x-(_grid.x-1)*_delta.x/2; _x < _grid.x && i < _subject.length; ++_x, _xPos += _delta.x, i++) {{ let it = _subject[i], pos = new Vector2(_xPos, _yPos, _center.location || _delta.location ? new SourceCodeLocation(null, 0, 0, _center.location, _delta.location) : null); {
			graphics.drawVideo(it, pos, size, 0/*Rectangle*/, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 97729, 97759, null, null));
			graphics.drawText(it.score?.toString(), pos.multiply(new Vector2(2.13, 1.8, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 97787, 97798, null, null))), new Vector2(0.0, 0.0, null), null, 1/*Center*/, 1/*Middle*/, 0/*Normal*/, Font.ByTheWay, null, 0, 0, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 97764, 97813, null, null));
		}}}
	}
}
function awardScreen_serialize_internal(buffer) {
	buffer.writeBool(awardScreen.active);
}
function awardScreen_deserialize_internal(buffer) {
	awardScreen.active = buffer.readBool();
}
function awardScreen_serialize_external(buffer) {
	buffer.writeString("active");
	buffer.writeInt32(1);
	buffer.writeBool(awardScreen.active);
	buffer.writeString("");
}
function awardScreen_deserialize_external(buffer) {
	let active_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "active":
				buffer.readInt32();
				awardScreen.active = buffer.readBool();
				active_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!active_is_set) awardScreen.active = false;
				return;
		}
	}
}
function DisplayItem(m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation) {
	this.type = "DisplayItem";
	this.x = x;
	this.y = y;
	this.w = w;
	this.h = h;
	this.layer = layer;
	this.alpha = alpha;
	this.clippingPath = clippingPath;
	this.name = name;
	this.location = location;
	this.positionLocation = positionLocation;
	this.sizeLocation = sizeLocation;
	this.m0 = 0.0;
	this.m1 = 0.0;
	this.m2 = 0.0;
	this.m3 = 0.0;
	this.m4 = 0.0;
	this.m5 = 0.0;
	this.poly = [];
	this.m0 = m.m0;
	this.m1 = m.m1;
	this.m2 = m.m2;
	this.m3 = m.m3;
	this.m4 = m.m4;
	this.m5 = m.m5;
	if(Platform.isDebug && (this.w || this.h)) {
		this.poly = [new Vector2(this.x, this.y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 98358, 98370, null, null)).transform(m), new Vector2(this.x + this.w, this.y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 98389, 98401, null, null)).transform(m), new Vector2(this.x + this.w, this.y + this.h, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 98420, 98432, null, null)).transform(m), new Vector2(this.x, this.y + this.h, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/graphics.l", 98451, 98463, null, null)).transform(m)];
	}
}
function new_DisplayItem_of_type(type) {
	switch(type) {
		case "DisplayItem": return new _DisplayItem();
		case "DisplayImage": return new _DisplayImage();
		case "DisplayText": return new _DisplayText();
		case "DisplayTextWithHighlights": return new _DisplayTextWithHighlights();
		case "DisplayRectangle": return new _DisplayRectangle();
		case "DisplayRoundedRectangle": return new _DisplayRoundedRectangle();
		case "DisplayPolygon": return new _DisplayPolygon();
		case "DisplayCircle": return new _DisplayCircle();
		case "DisplayLine": return new _DisplayLine();
		case "DisplayVideo": return new _DisplayVideo();
	}
}
DisplayItem.prototype.draw = function() {
}
DisplayItem.prototype.startClipping = function() {
	let points = this.clippingPath.points
	if(points.length >= 2) {
		let x = this.x, y = this.y
		let firstPos = points[points.length-1]
		graphics.context.beginPath();
		graphics.context.moveTo(firstPos.x, firstPos.y)
		for(let p of points) graphics.context.lineTo(p.x, p.y)
		if(this.clippingPath.show) {
			graphics.context.fillStyle = "#ff000080"
			graphics.context.fill()
		}
		graphics.context.save()
		graphics.context.clip()
	}
}
DisplayItem.prototype.endClipping = function() {
	if(this.clippingPath.points.length >= 2)
		graphics.context.restore()
}
DisplayItem.prototype.clone = function() {
	let clone = new _DisplayItem();
	clone.type = this.type;
	clone.x = this.x;
	clone.y = this.y;
	clone.w = this.w;
	clone.h = this.h;
	clone.layer = this.layer;
	clone.alpha = this.alpha;
	clone.clippingPath = this.clippingPath;
	clone.name = this.name;
	clone.location = this.location;
	clone.positionLocation = this.positionLocation;
	clone.sizeLocation = this.sizeLocation;
	clone.m0 = this.m0;
	clone.m1 = this.m1;
	clone.m2 = this.m2;
	clone.m3 = this.m3;
	clone.m4 = this.m4;
	clone.m5 = this.m5;
	clone.poly = this.poly;
	return clone;
}
function _DisplayItem() {};
_DisplayItem.prototype = DisplayItem.prototype;
function TextSegment(text, highlight, position, size) {
	this.text = text;
	this.highlight = highlight;
	this.position = position?.clone();
	this.size = size?.clone();
}
TextSegment.prototype.clone = function() {
	let clone = new _TextSegment();
	clone.text = this.text;
	clone.highlight = this.highlight;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	return clone;
}
function _TextSegment() {};
_TextSegment.prototype = TextSegment.prototype;
TextSegment.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.text);
	let highlight = this.highlight
	if(highlight) {
		var index = _objectCacheIndex.get(highlight);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(highlight, index = _objectCache.length);
			_objectCache.push(highlight);
			buffer.writeInt32(-index);
			highlight._objectIndex = index;
			highlight.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	(this.position || new _Vector2()).serialize_internal(buffer);
	(this.size || new _Vector2()).serialize_internal(buffer);
}
TextSegment.prototype.deserialize_internal = function(buffer) {
	this.text = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.highlight = _objectCache[index];
	} else {
		let highlight = this.highlight
		if(!highlight || highlight._objectIndex != -index)
			this.highlight = highlight = new _TextHighlight();
		(_objectCache[-index] = highlight).deserialize_internal(buffer);
	}
	(this.position || (this.position = new _Vector2())).deserialize_internal(buffer);
	(this.size || (this.size = new _Vector2())).deserialize_internal(buffer);
}
TextSegment.prototype.serialize_external = function(buffer) {
	buffer.writeString("text");
	buffer.writeString(this.text);
	buffer.writeString("highlight");
	let highlight_startPos = buffer.reserveSize();
	let highlight = this.highlight
	if(highlight) {
		var index = _objectCacheIndex.get(highlight);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(highlight, index = _objectCache.length);
			_objectCache.push(highlight);
			buffer.writeInt32(-index);
			highlight._objectIndex = index;
			highlight.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(highlight_startPos);
	buffer.writeString("position");
	let position_startPos = buffer.reserveSize();
	(this.position || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(position_startPos);
	buffer.writeString("size");
	let size_startPos = buffer.reserveSize();
	(this.size || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(size_startPos);
	buffer.writeString("");
}
TextSegment.prototype.deserialize_external = function(buffer) {
	let text_is_set = false, highlight_is_set = false, position_is_set = false, size_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "text":
				this.text = buffer.readString();
				text_is_set = true;
				break;
			case "highlight":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.highlight = _objectCache[index];
				} else {
					let highlight = this.highlight
					if(!highlight || highlight._objectIndex != -index)
						this.highlight = highlight = new _TextHighlight();
					(_objectCache[-index] = highlight).deserialize_external(buffer);
				}
				highlight_is_set = true;
				break;
			case "position":
				buffer.readInt32();
				(this.position || (this.position = new _Vector2())).deserialize_external(buffer);
				position_is_set = true;
				break;
			case "size":
				buffer.readInt32();
				(this.size || (this.size = new _Vector2())).deserialize_external(buffer);
				size_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!text_is_set) this.text = "";
				if(!highlight_is_set) this.highlight = null;
				if(!position_is_set) this.position = new Vector2(0.0, 0.0, null);
				if(!size_is_set) this.size = new Vector2(0.0, 0.0, null);
				return;
		}
	}
}
function Lambda5() {
	this._id = 5;
}
Lambda5.prototype.invoke = function(x) {
	return x;
}
Lambda5.prototype.serialize_internal = function(buffer) {
}
Lambda5.prototype.deserialize_internal = function(buffer) {
}
Lambda5.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda5.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda5() {
	this._id = 5;
};
_Lambda5.prototype = Lambda5.prototype;
function Lambda6() {
	this._id = 6;
}
Lambda6.prototype.invoke = function(x) {
	return 1 - math.cos((.25 * x));
}
Lambda6.prototype.serialize_internal = function(buffer) {
}
Lambda6.prototype.deserialize_internal = function(buffer) {
}
Lambda6.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda6.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda6() {
	this._id = 6;
};
_Lambda6.prototype = Lambda6.prototype;
function Lambda7() {
	this._id = 7;
}
Lambda7.prototype.invoke = function(x) {
	return math.sin((.25 * x));
}
Lambda7.prototype.serialize_internal = function(buffer) {
}
Lambda7.prototype.deserialize_internal = function(buffer) {
}
Lambda7.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda7.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda7() {
	this._id = 7;
};
_Lambda7.prototype = Lambda7.prototype;
function Lambda8() {
	this._id = 8;
}
Lambda8.prototype.invoke = function(x) {
	return -(math.cos((.5 * x)) - 1) * .5;
}
Lambda8.prototype.serialize_internal = function(buffer) {
}
Lambda8.prototype.deserialize_internal = function(buffer) {
}
Lambda8.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda8.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda8() {
	this._id = 8;
};
_Lambda8.prototype = Lambda8.prototype;
function Lambda9() {
	this._id = 9;
}
Lambda9.prototype.invoke = function(x) {
	return x * x;
}
Lambda9.prototype.serialize_internal = function(buffer) {
}
Lambda9.prototype.deserialize_internal = function(buffer) {
}
Lambda9.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda9.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda9() {
	this._id = 9;
};
_Lambda9.prototype = Lambda9.prototype;
function Lambda10() {
	this._id = 10;
}
Lambda10.prototype.invoke = function(x) {
	return 1 - (1 - x) * (1 - x);
}
Lambda10.prototype.serialize_internal = function(buffer) {
}
Lambda10.prototype.deserialize_internal = function(buffer) {
}
Lambda10.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda10.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda10() {
	this._id = 10;
};
_Lambda10.prototype = Lambda10.prototype;
function Lambda11() {
	this._id = 11;
}
Lambda11.prototype.invoke = function(x) {
	return (x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2);
}
Lambda11.prototype.serialize_internal = function(buffer) {
}
Lambda11.prototype.deserialize_internal = function(buffer) {
}
Lambda11.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda11.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda11() {
	this._id = 11;
};
_Lambda11.prototype = Lambda11.prototype;
function Lambda12() {
	this._id = 12;
}
Lambda12.prototype.invoke = function(x) {
	return x * x * x;
}
Lambda12.prototype.serialize_internal = function(buffer) {
}
Lambda12.prototype.deserialize_internal = function(buffer) {
}
Lambda12.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda12.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda12() {
	this._id = 12;
};
_Lambda12.prototype = Lambda12.prototype;
function Lambda13() {
	this._id = 13;
}
Lambda13.prototype.invoke = function(x) {
	return 1 - Math.pow(1 - x, 3);
}
Lambda13.prototype.serialize_internal = function(buffer) {
}
Lambda13.prototype.deserialize_internal = function(buffer) {
}
Lambda13.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda13.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda13() {
	this._id = 13;
};
_Lambda13.prototype = Lambda13.prototype;
function Lambda14() {
	this._id = 14;
}
Lambda14.prototype.invoke = function(x) {
	return (x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2);
}
Lambda14.prototype.serialize_internal = function(buffer) {
}
Lambda14.prototype.deserialize_internal = function(buffer) {
}
Lambda14.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda14.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda14() {
	this._id = 14;
};
_Lambda14.prototype = Lambda14.prototype;
function Lambda15() {
	this._id = 15;
}
Lambda15.prototype.invoke = function(x) {
	return x * x * x * x;
}
Lambda15.prototype.serialize_internal = function(buffer) {
}
Lambda15.prototype.deserialize_internal = function(buffer) {
}
Lambda15.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda15.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda15() {
	this._id = 15;
};
_Lambda15.prototype = Lambda15.prototype;
function Lambda16() {
	this._id = 16;
}
Lambda16.prototype.invoke = function(x) {
	return 1 - Math.pow(1 - x, 4);
}
Lambda16.prototype.serialize_internal = function(buffer) {
}
Lambda16.prototype.deserialize_internal = function(buffer) {
}
Lambda16.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda16.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda16() {
	this._id = 16;
};
_Lambda16.prototype = Lambda16.prototype;
function Lambda17() {
	this._id = 17;
}
Lambda17.prototype.invoke = function(x) {
	return (x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2);
}
Lambda17.prototype.serialize_internal = function(buffer) {
}
Lambda17.prototype.deserialize_internal = function(buffer) {
}
Lambda17.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda17.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda17() {
	this._id = 17;
};
_Lambda17.prototype = Lambda17.prototype;
function Lambda18() {
	this._id = 18;
}
Lambda18.prototype.invoke = function(x) {
	return 2.70158 * x * x * x - 1.70158 * x * x;
}
Lambda18.prototype.serialize_internal = function(buffer) {
}
Lambda18.prototype.deserialize_internal = function(buffer) {
}
Lambda18.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda18.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda18() {
	this._id = 18;
};
_Lambda18.prototype = Lambda18.prototype;
function Lambda19() {
	this._id = 19;
}
Lambda19.prototype.invoke = function(x) {
	return 1 + 2.70158 * Math.pow(x - 1, 3) + 1.70158 * Math.pow(x - 1, 2);
}
Lambda19.prototype.serialize_internal = function(buffer) {
}
Lambda19.prototype.deserialize_internal = function(buffer) {
}
Lambda19.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda19.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda19() {
	this._id = 19;
};
_Lambda19.prototype = Lambda19.prototype;
function Lambda20() {
	this._id = 20;
}
Lambda20.prototype.invoke = function(x) {
	return (x < 0.5 ? (Math.pow(2 * x, 2) * ((2.70158 + 1) * 2 * x - 2.70158)) / 2 : (Math.pow(2 * x - 2, 2) * ((2.70158 + 1) * (x * 2 - 2) + 2.70158) + 2) / 2);
}
Lambda20.prototype.serialize_internal = function(buffer) {
}
Lambda20.prototype.deserialize_internal = function(buffer) {
}
Lambda20.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda20.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda20() {
	this._id = 20;
};
_Lambda20.prototype = Lambda20.prototype;
function EaseFunction($function) {
	this.function = $function;
}
EaseFunction.init = function() {
	EaseFunction.None = new EaseFunction(new Lambda5());
	_constCache.push(EaseFunction.None);
	EaseFunction.InSin = new EaseFunction(new Lambda6());
	_constCache.push(EaseFunction.InSin);
	EaseFunction.OutSin = new EaseFunction(new Lambda7());
	_constCache.push(EaseFunction.OutSin);
	EaseFunction.InOutSin = new EaseFunction(new Lambda8());
	_constCache.push(EaseFunction.InOutSin);
	EaseFunction.InQuadratic = new EaseFunction(new Lambda9());
	_constCache.push(EaseFunction.InQuadratic);
	EaseFunction.OutQuadratic = new EaseFunction(new Lambda10());
	_constCache.push(EaseFunction.OutQuadratic);
	EaseFunction.InOutQuadratic = new EaseFunction(new Lambda11());
	_constCache.push(EaseFunction.InOutQuadratic);
	EaseFunction.InCubic = new EaseFunction(new Lambda12());
	_constCache.push(EaseFunction.InCubic);
	EaseFunction.OutCubic = new EaseFunction(new Lambda13());
	_constCache.push(EaseFunction.OutCubic);
	EaseFunction.InOutCubic = new EaseFunction(new Lambda14());
	_constCache.push(EaseFunction.InOutCubic);
	EaseFunction.InQuartic = new EaseFunction(new Lambda15());
	_constCache.push(EaseFunction.InQuartic);
	EaseFunction.OutQuartic = new EaseFunction(new Lambda16());
	_constCache.push(EaseFunction.OutQuartic);
	EaseFunction.InOutQuartic = new EaseFunction(new Lambda17());
	_constCache.push(EaseFunction.InOutQuartic);
	EaseFunction.InBack = new EaseFunction(new Lambda18());
	_constCache.push(EaseFunction.InBack);
	EaseFunction.OutBack = new EaseFunction(new Lambda19());
	_constCache.push(EaseFunction.OutBack);
	EaseFunction.InOutBack = new EaseFunction(new Lambda20());
	_constCache.push(EaseFunction.InOutBack);
}
EaseFunction.prototype.clone = function() {
	let clone = new _EaseFunction();
	clone.function = this.function;
	return clone;
}
function _EaseFunction() {};
_EaseFunction.prototype = EaseFunction.prototype;
function EaseFunction_serialize_internal(buffer) {
}
function EaseFunction_deserialize_internal(buffer) {
}
EaseFunction.prototype.serialize_internal = function(buffer) {
	let $function = this.function
	if($function) {
		var index = _objectCacheIndex.get($function);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set($function, index = _objectCache.length);
			_objectCache.push($function);
			buffer.writeInt32(-index);
			buffer.writeInt32($function._id);
			$function._objectIndex = index;
			$function.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
EaseFunction.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this.function = _objectCache[index];
	} else {
		let $function = this.function
		let _id = buffer.readInt32();
		if(!$function || $function._id != _id || $function._objectIndex != -index)
			this.function = $function = new _lambdaContructors[_id]();
		$function._id = _id;
		(_objectCache[-index] = $function).deserialize_internal(buffer);
	}
}
function EaseFunction_serialize_external(buffer) {
	buffer.writeString("");
}
function EaseFunction_deserialize_external(buffer) {
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				return;
		}
	}
}
EaseFunction.prototype.serialize_external = function(buffer) {
	buffer.writeString("function");
	let $function_startPos = buffer.reserveSize();
	let $function = this.function
	if($function) {
		var index = _objectCacheIndex.get($function);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set($function, index = _objectCache.length);
			_objectCache.push($function);
			buffer.writeInt32(-index);
			buffer.writeInt32($function._id);
			$function._objectIndex = index;
			$function.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize($function_startPos);
	buffer.writeString("");
}
EaseFunction.prototype.deserialize_external = function(buffer) {
	let function_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "function":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.function = _objectCache[index];
				} else {
					let $function = this.function
					let _id = buffer.readInt32();
					if(!$function || $function._id != _id || $function._objectIndex != -index)
						this.function = $function = new _lambdaContructors[_id]();
					$function._id = _id;
					(_objectCache[-index] = $function).deserialize_external(buffer);
				}
				function_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!function_is_set) this.function = null;
				return;
		}
	}
}
var lobby; if(!lobby) lobby = {};
lobby.init = function() {
	lobby.inLobby = true;
	lobby.enableFullscreen = true;
	lobby.points = [];
	lobby.fields = [];
	lobby.showNameIndex = 1;
	lobby.editNames = false;
	lobby.nameSuggestions = ["Heiko", "Bianca", "Bjarne", "Tim", "Christian", "Svend", "Holger", "Joe", "Kevin", "Simonas", "Dominik", "Felix", "Edi", "Matthias", "Phillip", "Jürgen", "Jakob", "Christopher", "Krzysztof", "Chuck", "Markus", "Nick", "Marijn", "Carina", "Beatrice", "Talea", "Tanja", "Yvonne"];
	lobby.counter = 0;
}
lobby.show = function() {
	Framework.clear(true);
	lobby.fields.length = 0;
	lobby.inLobby = true;
	lobby.showNameIndex = 1;
	lobby.editNames = false;
	for(let i=0, _subject=input.players, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		it.isReadyInLobby = false;
	}}
	audio.stop();
}
lobby.tick = function() {
	var _value, _value2;
	lobby.tickSettings();
	if(Platform.isStaging) {
		graphics.drawText("Version:"+_buildVersion?.toString(), new Vector2(-940, 520, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 812, 823, null, null)), new Vector2(20, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 799, 801, null, null)), null, 0/*Left*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, 0, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 750, 835, null, null));
	}
	if((PeerNetwork.error || core.errorMessage) && Platform.isStaging) {
		graphics.drawText(PeerNetwork.error, new Vector2(0.0, 0.0, null), new Vector2(40, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 941, 943, null, null)), null, 1/*Center*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, 0, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 908, 943, null, null));
		graphics.drawText(core.errorMessage, new Vector2(0, 40, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 993, 999, null, null)), new Vector2(14, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 980, 982, null, null)), null, 1/*Center*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, 0, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 947, 999, null, null));
		return;
	}
	input.onKeyDown3([input.host], (key,pressedBy,cmdOrCtrl,alt,shift) => {
		let cmd = pressedBy.keysCurrentlyDown.includes(91/*LeftMetaKey*/);
		if(key == 69/*E*/ && cmd) {
			lobby.setupFields(pressedBy);
		}
		if(!(input.host != null)) {
			return;
		}
		if(key == 39/*Right*/) {
			lobby.showName(input.players[(_value = input.players.length, ((lobby.showNameIndex++ % _value) + _value) % _value)]);
		} else {
			if(key == 9/*Tab*/ && cmd) {
				lobby.showNameIndex = (_value2 = input.players.length, (((lobby.showNameIndex + 1) % _value2) + _value2) % _value2);
			} else {
				if(key == 13/*Enter*/ || key == 9/*Tab*/ || key == 39/*Right*/) {
					lobby.switchFieldFocus(1);
				} else {
					if(key == 37/*Left*/) {
						lobby.switchFieldFocus(-1);
					}
				}
			}
		}
	});
	let count = input.players.length;
	if(count) {
		let videoWidth = (count < 2 ? 900.0 : 1920 / count);
		let offset = -videoWidth * (count - 1) / 2;
		let halfVideoHeight = videoWidth * 3 / 8;
		for(let i=0, _subject=input.players, _len=_subject.length; i<_len; ++i) { let player = _subject[i], playerIndex = i; {
			let pos = new Vector2(offset + videoWidth * player.index, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 1724, 1753, null, null));
			input.onTouchDown(pos, new Vector2(videoWidth, videoWidth * 3 / 4, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 1788, 1816, null, null)), null, "auto", false, true, 1/*Center*/, 1/*Middle*/, touch => {
				lobby.cyclePlayer(player);
			});
		}}
		for(let i=0, _subject=input.players, _len=_subject.length; i<_len; ++i) { let player = _subject[i], playerIndex = i; {
			let pos = new Vector2(offset + videoWidth * player.index, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 1903, 1932, null, null));
			graphics.drawVideo(player, pos, new Vector2(videoWidth, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 1955, 1965, null, null)), 0/*Rectangle*/, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 1937, 1965, null, null));
			let text = (!player.isReadyInLobby ? "START" : (Loca.language == 1/*German*/ ? "Ich bin bereit" : "I'm ready"));
			graphics.drawStandardButton(text, pos.plus(new Vector2(0, halfVideoHeight + 90, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 2128, 2150, null, null))), player.color, null, [player], 0/*None*/, 0, 1.0, !player.isReadyInLobby, touch => {
				if(lobby.enableFullscreen) {
					Platform.setFullscreen(true, touch.by);
				}
				touch.by.isReadyInLobby = true;
			}, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 2099, 2386, null, null));
			if((input.players.length >= Platform.supportedUserCount.from && input.players.length <= Platform.supportedUserCount.to) && input.players.every(a => a.isReadyInLobby)) {
				lobby.fields.length = 0;
				{
					core.restart();
				}
			}
			let closePos = pos.plus(new Vector2(videoWidth / 2 - 15, -halfVideoHeight - 25, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 2560, 2597, null, null)));
			let state = input.internalUsers[player.id]?.connectionState;
			if(state && state != "connected") {
				graphics.drawText(state, pos.plus(new Vector2(0, -halfVideoHeight - 40, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 2782, 2806, null, null))), new Vector2(80, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 2725, 2727, null, null)), (state == "failed" ? Color.Red : Color.Yellow), 1/*Center*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, 0, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 2704, 2806, null, null));
				graphics.drawText("x", closePos, new Vector2(50, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 2831, 2833, null, null)), new Color("#808080ff"), 1/*Center*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, 0, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 2812, 2867, null, null));
			}
			input.onTouchDown(closePos, new Vector2(32, 32, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 2899, 2906, null, null)), null, "auto", false, true, 1/*Center*/, 1/*Middle*/, touch => {
				input.removePlayer(player);
			});
			let field = lobby.fields.find(a => a.player == player);
			if((field != null)) {
				field.position.assign(pos.plus(new Vector2(0, -halfVideoHeight - ((input.players.length <= 2 ? 85 : 120)), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 3043, 3095, null, null))));
				if((field.effect != null)) {
					field.effect.position.assign(field.position.plus(new Vector2(0, -190, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 3159, 3167, null, null))));
				}
				if((field.particleSystem != null)) {
					field.particleSystem.position.assign(field.position);
				}
				if(lobby.editNames) {
					for(let i=0, _subject=lobby.nameSuggestions, _len=_subject.length; i<_len; ++i) { let name = _subject[i]; {
						graphics.drawButton(null, name, pos.plus(new Vector2(-150 + 100 * ((((i % 4) + 4) % 4)), halfVideoHeight + 150 + 20 * Math.floor(i / 4), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 3362, 3417, null, null))), new Vector2(0.0, 0.0, null), -1, new Color("#808080ff"), 14, new Vector2(0, 0, null), new Vector2(16, 16, null), false, 1.0, 1, Color.White, null, null, [input.host], null, 0/*None*/, 0, 1.0, true, .5, touch => {
							lobby.fields[playerIndex].text = name;
							lobby.setPlayerName(player, name);
						}, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 3332, 3565, null, null));
					}}
					if(lobby.showNameIndex == playerIndex) {
						graphics.drawCircle(field.position.plus(new Vector2(0, 60, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 3703, 3709, null, null))), new Vector2(20, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 3716, 3718, null, null)), null, null, 0, 0, 1.0, 0/*Clockwise*/, [input.host], 0, 1.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 3677, 3735, null, null));
					}
				}
			}
		}}
	}
	if(core.drawPointsForTesting) {
		input.onTouchDown5(null, true, touch => {
			lobby.points.push(touch.position().clone());
		});
		for(let i=0, _subject=lobby.points, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			graphics.drawText(it?.toString(), it, new Vector2(30, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 3924, 3926, null, null)), null, 1/*Center*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, 0, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 3892, 3926, null, null));
			graphics.drawCircle(it, new Vector2(200, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 3965, 3968, null, null)), null, Color.White, 0, 0, 1.0, 0/*Clockwise*/, null, 0, 1.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 3928, 3968, null, null));
		}}
		graphics.drawText((++lobby.counter)?.toString(), new Vector2(0, -480, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 3992, 4001, null, null)), new Vector2(100, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 4008, 4011, null, null)), null, 1/*Center*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, 0, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 3972, 4011, null, null));
	}
	if(Loca.supportedLanguages.length > 1) {
		for(let i=0, _subject=Loca.supportedLanguages, _end = new Vector2(930, -510, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 4121, 4131, null, null)), _delta = new Vector2(40, 0.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 4139, 4143, null, null)), _len=_subject.length, _x = _end.x-(_len-1)*_delta.x, _y=_end.y-(_len-1)*_delta.y; i<_len; ++i, _x += _delta.x, _y += _delta.y) { let it = _subject[i], pos = new Vector2(_x, _y, _end.location || _delta.location ? new SourceCodeLocation(null, 0, 0, _end.location, _delta.location) : null); {
			graphics.drawImage5($Image.Flag[i], pos, new Vector2(0.0, 0.0, null), null, null, (Loca.language == i ? 1 : 0), 0, 1.0, Color.White, 0.0, false, false, new Vector2(16, 16, null), false, 0/*None*/, touch => {
				Loca.setLanguage(i, null);
			}, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 4148, 4240, null, null));
		}}
	}
}

lobby.setupFields = function(newHost) {
	input.host = newHost;
	lobby.showNameIndex = input.host.index + 1;
	Framework.clear(false);
	lobby.fields.length = 0;
	if(!lobby.editNames) {
		lobby.editNames = true;
		for(let i=0, _subject=input.players, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			lobby.createField(it, [input.host]);
		}}
		lobby.fields[0].focus(true);
	} else {
		lobby.editNames = false;
		input.showPointers = false;
	}
}
lobby.switchFieldFocus = function(delta) {
	var _value;
	let focusIndex = lobby.fields.indexWhere(a => a.isFocused, 0);
	focusIndex = (_value = lobby.fields.length, (((focusIndex + delta) % _value) + _value) % _value);
	for(let i=0, _subject=lobby.fields, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		it.focus(focusIndex == i);
	}}
}

lobby.showName = function(player) {
	let field = lobby.createField(player, null);
	field = field.fadeScaleAndRotateIn(5, (-.08), (-.01), 200, 0);
	field.effect = new Effect(new Vector2(0.0, 0.0, null), new Vector2(1000, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 5196, 5200, null, null)), 0.0, 1, null, 0, false, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 5172, 5201, null, null), $Image.Nuke, 15);
	field.particleSystem = new ParticleSystem(new Vector2(0.0, 0.0, null), new Vector2(0.0, 0.0, null), 0.0, 1, null, 0, false, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 5227, 5317, null, null), $Image.Spark, 10, 20, 30, 500, (-1), 1, .5, .05, 0/*Burst*/, .5);
}
function Lambda21(player) {
	this._id = 21;
	this.player = player;
}
Lambda21.prototype.invoke = function(text) {
	lobby.setPlayerName(this.player, text);
}
Lambda21.prototype.serialize_internal = function(buffer) {
	let player = this.player
	if(player) {
		var index = _objectCacheIndex.get(player);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(player, index = _objectCache.length);
			_objectCache.push(player);
			buffer.writeInt32(-index);
			player._objectIndex = index;
			player.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
Lambda21.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this.player = _objectCache[index];
	} else {
		let player = this.player
		if(!player || player._objectIndex != -index)
			this.player = player = new _Player();
		(_objectCache[-index] = player).deserialize_internal(buffer);
	}
}
Lambda21.prototype.serialize_external = function(buffer) {
	buffer.writeString("player");
	let player_startPos = buffer.reserveSize();
	let player = this.player
	if(player) {
		var index = _objectCacheIndex.get(player);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(player, index = _objectCache.length);
			_objectCache.push(player);
			buffer.writeInt32(-index);
			player._objectIndex = index;
			player.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(player_startPos);
	buffer.writeString("");
}
Lambda21.prototype.deserialize_external = function(buffer) {
	let player_is_set = false;
	for(;;) {
		switch(buffer.readString()) {
			case "player":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.player = _objectCache[index];
				} else {
					let player = this.player
					if(!player || player._objectIndex != -index)
						this.player = player = new _Player();
					(_objectCache[-index] = player).deserialize_external(buffer);
				}
				player_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				if(!player_is_set) this.player = null;
				return;
		}
	}
}
function _Lambda21() {
	this._id = 21;
};
_Lambda21.prototype = Lambda21.prototype;
lobby.createField = function(player, visibleFor) {
	let field = new LobbyTextField(new Vector2(0.0, 0.0, null), new Vector2(100, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 5515, 5518, null, null)), (-.01), 1, visibleFor, 0, false, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 5427, 5581, null, null), player.name, Font.ByTheWay, Color.White, player, null, null, input.host, 600, new Lambda21(player));
	lobby.fields.push(field);
	return field;
}
lobby.setPlayerName = function(player, name) {
	player.name = name.capitalizeWords();
	let user = input.internalUsers[player.id];
	if((user != null)) {
		user.name = player.name;
	}
	if(player.id == input.localUser.id) {
		core.account.name = player.name;
		Platform.setLocalStorageObject("user", core.account, null, null);
	}
}
lobby.cyclePlayer = function(player) {
	System.watch(("Cycle color "+player.index?.toString()), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 5930, 5964, null, null));
	input.players.moveToBack(player);
	input.updatePlayers();
	player.colorPreferences = [player.index];
}
lobby.tickSettings = function() {
	for(let i=0, _subject=input.players, _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		graphics.visibleFor([player], () => {
			graphics.drawImage5($Image.settingsIcon, new Vector2(-920, -500, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 6156, 6167, null, null)), new Vector2(32, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 6174, 6176, null, null)), null, null, 0, 0, 1.0, Color.White, 0.0, false, false, new Vector2(16, 16, null), false, 0/*None*/, touch => {
				player.showSettingsInLobby = !player.showSettingsInLobby;
			}, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 6132, 6238, null, null));
			if(player.showSettingsInLobby) {
				let pos = new Vector2(-650, -500, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 6298, 6309, null, null));
				graphics.drawImage($Image.cameraIcon, pos, new Vector2(0.0, 0.0, null), null, 0, 0, 1.0, Color.White, 1/*Center*/, 1/*Middle*/, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 6321, 6346, null, null));
				for(let i=0, _start = pos.plus(new Vector2(36, 0.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 6378, 6382, null, null))), _delta = new Vector2(0, 26, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 6389, 6395, null, null)), _len=10, _x = _start.x, _y= _start.y; i<_len; ++i, _x += _delta.x, _y += _delta.y) { let pos = new Vector2(_x, _y, _start.location || _delta.location ? new SourceCodeLocation(null, 0, 0, _start.location, _delta.location) : null); {
					let device = PeerNetwork.devices.videoInput[i];
					if((device != null)) {
						graphics.drawText(device.label, pos, new Vector2(18, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 6489, 6491, null, null)), (PeerNetwork.videoInputId == device.deviceId ? player.color : Color.White), 0/*Left*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, 0, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 6456, 6577, null, null));
					}
					input.onTouchDown(pos.plus(new Vector2(200, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 6600, 6607, null, null))), new Vector2(400, 30, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 6614, 6622, null, null)), [player], "auto", false, true, 1/*Center*/, 1/*Middle*/, touch => {
						PeerNetwork.setVideoInput(device?.deviceId, player);
					});
				}}
				pos.plusAssign(new Vector2(450, 0.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 6703, 6708, null, null)));
				graphics.drawImage($Image.microphoneIcon, pos, new Vector2(0.0, 0.0, null), null, 0, 0, 1.0, Color.White, 1/*Center*/, 1/*Middle*/, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 6720, 6749, null, null));
				for(let i=0, _start = pos.plus(new Vector2(36, 0.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 6781, 6785, null, null))), _delta = new Vector2(0, 26, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 6792, 6798, null, null)), _len=10, _x = _start.x, _y= _start.y; i<_len; ++i, _x += _delta.x, _y += _delta.y) { let pos = new Vector2(_x, _y, _start.location || _delta.location ? new SourceCodeLocation(null, 0, 0, _start.location, _delta.location) : null); {
					let device = PeerNetwork.devices.audioInput[i];
					if((device != null)) {
						graphics.drawText(device.label, pos, new Vector2(18, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 6892, 6894, null, null)), (PeerNetwork.audioInputId == device.deviceId ? player.color : Color.White), 0/*Left*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, 0, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 6859, 6980, null, null));
					}
					input.onTouchDown(pos.plus(new Vector2(200, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 7003, 7010, null, null))), new Vector2(400, 30, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 7017, 7025, null, null)), [player], "auto", false, true, 1/*Center*/, 1/*Middle*/, touch => {
						PeerNetwork.setAudioInput(device?.deviceId, player);
					});
				}}
				pos.plusAssign(new Vector2(550, 0.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 7106, 7111, null, null)));
				if((PeerNetwork.devices.audioOutput != null && PeerNetwork.devices.audioOutput.length != 0) ) {
					graphics.drawImage($Image.speakerIcon, pos, new Vector2(0.0, 0.0, null), null, 0, 0, 1.0, Color.White, 1/*Center*/, 1/*Middle*/, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 7166, 7192, null, null));
				}
				for(let i=0, _start = pos.plus(new Vector2(36, 0.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 7224, 7228, null, null))), _delta = new Vector2(0, 26, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 7235, 7241, null, null)), _len=10, _x = _start.x, _y= _start.y; i<_len; ++i, _x += _delta.x, _y += _delta.y) { let pos = new Vector2(_x, _y, _start.location || _delta.location ? new SourceCodeLocation(null, 0, 0, _start.location, _delta.location) : null); {
					let device = PeerNetwork.devices.audioOutput[i];
					if((device != null)) {
						graphics.drawText(device.label, pos, new Vector2(18, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 7336, 7338, null, null)), (PeerNetwork.audioOutputId == device.deviceId ? player.color : Color.White), 0/*Left*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, 0, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 7303, 7425, null, null));
					}
					input.onTouchDown(pos.plus(new Vector2(200, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 7448, 7455, null, null))), new Vector2(400, 30, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 7462, 7470, null, null)), [player], "auto", false, true, 1/*Center*/, 1/*Middle*/, touch => {
						PeerNetwork.setAudioOutput(device?.deviceId, player);
					});
				}}
			}
		});
	}}
}
function lobby_serialize_internal(buffer) {
	buffer.writeBool(lobby.inLobby);
	buffer.writeBool(lobby.enableFullscreen);
	let _points = lobby.points
	if(_points) {
		var index = _objectCacheIndex.get(_points);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_points, index = _objectCache.length);
			_objectCache.push(_points);
			buffer.writeInt32(-index);
			_points._objectIndex = index;
			buffer.writeInt32(_points.length);
			for(let i=0, len=_points.length; i<len; ++i) {
				(_points[i] || new _Vector2()).serialize_internal(buffer);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let _fields = lobby.fields
	if(_fields) {
		var index = _objectCacheIndex.get(_fields);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_fields, index = _objectCache.length);
			_objectCache.push(_fields);
			buffer.writeInt32(-index);
			_fields._objectIndex = index;
			buffer.writeInt32(_fields.length);
			for(let i=0, len=_fields.length; i<len; ++i) {
				let _fields_item = _fields[i]
				if(_fields_item) {
					var index = _objectCacheIndex.get(_fields_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_fields_item, index = _objectCache.length);
						_objectCache.push(_fields_item);
						buffer.writeInt32(-index);
						buffer.writeString(_fields_item.type);
						_fields_item._objectIndex = index;
						_fields_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(lobby.showNameIndex);
	buffer.writeBool(lobby.editNames);
	let _nameSuggestions = lobby.nameSuggestions
	if(_nameSuggestions) {
		var index = _objectCacheIndex.get(_nameSuggestions);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_nameSuggestions, index = _objectCache.length);
			_objectCache.push(_nameSuggestions);
			buffer.writeInt32(-index);
			_nameSuggestions._objectIndex = index;
			buffer.writeInt32(_nameSuggestions.length);
			for(let i=0, len=_nameSuggestions.length; i<len; ++i) {
				buffer.writeString(_nameSuggestions[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(lobby.counter);
}
function lobby_deserialize_internal(buffer) {
	lobby.inLobby = buffer.readBool();
	lobby.enableFullscreen = buffer.readBool();
	var index = buffer.readInt32();
	if(index >= 0) {
		lobby.points = _objectCache[index];
	} else {
		let _points = lobby.points
		if(!_points || _points._objectIndex != -index) lobby.points = _points = [];
		_objectCache[-index] = _points;
		for(let i=0, len = _points.length = buffer.readInt32(); i<len; ++i) {
				(_points[i] || (_points[i] = new _Vector2())).deserialize_internal(buffer);
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		lobby.fields = _objectCache[index];
	} else {
		let _fields = lobby.fields
		if(!_fields || _fields._objectIndex != -index) lobby.fields = _fields = [];
		_objectCache[-index] = _fields;
		for(let i=0, len = _fields.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_fields[i] = _objectCache[index];
				} else {
					let _fields_item = _fields[i]
					let type = buffer.readString();
					if(!_fields_item || _fields_item._objectIndex != -index)
						_fields[i] = _fields_item = new_Object_of_type(type);
					_fields_item.type = type;
					(_objectCache[-index] = _fields_item).deserialize_internal(buffer);
				}
		}
	}
	lobby.showNameIndex = buffer.readInt32();
	lobby.editNames = buffer.readBool();
	var index = buffer.readInt32();
	if(index >= 0) {
		lobby.nameSuggestions = _objectCache[index];
	} else {
		let _nameSuggestions = lobby.nameSuggestions
		if(!_nameSuggestions || _nameSuggestions._objectIndex != -index) lobby.nameSuggestions = _nameSuggestions = [];
		_objectCache[-index] = _nameSuggestions;
		for(let i=0, len = _nameSuggestions.length = buffer.readInt32(); i<len; ++i) {
				_nameSuggestions[i] = buffer.readString();
		}
	}
	lobby.counter = buffer.readInt32();
}
function lobby_serialize_external(buffer) {
	buffer.writeString("inLobby");
	buffer.writeInt32(1);
	buffer.writeBool(lobby.inLobby);
	buffer.writeString("enableFullscreen");
	buffer.writeInt32(1);
	buffer.writeBool(lobby.enableFullscreen);
	buffer.writeString("points");
	let _points = lobby.points
	let _points_startPos = buffer.reserveSize();
	if(_points) {
		var index = _objectCacheIndex.get(_points);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_points, index = _objectCache.length);
			_objectCache.push(_points);
			buffer.writeInt32(-index);
			_points._objectIndex = index;
			buffer.writeInt32(_points.length);
			for(let i=0, len=_points.length; i<len; ++i) {
				(_points[i] || new _Vector2()).serialize_external(buffer);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_points_startPos);
	buffer.writeString("fields");
	let _fields = lobby.fields
	let _fields_startPos = buffer.reserveSize();
	if(_fields) {
		var index = _objectCacheIndex.get(_fields);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_fields, index = _objectCache.length);
			_objectCache.push(_fields);
			buffer.writeInt32(-index);
			_fields._objectIndex = index;
			buffer.writeInt32(_fields.length);
			for(let i=0, len=_fields.length; i<len; ++i) {
				let _fields_item = _fields[i]
				if(_fields_item) {
					var index = _objectCacheIndex.get(_fields_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_fields_item, index = _objectCache.length);
						_objectCache.push(_fields_item);
						buffer.writeInt32(-index);
						buffer.writeString(_fields_item.type);
						_fields_item._objectIndex = index;
						_fields_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_fields_startPos);
	buffer.writeString("showNameIndex");
	buffer.writeInt32(4);
	buffer.writeInt32(lobby.showNameIndex);
	buffer.writeString("editNames");
	buffer.writeInt32(1);
	buffer.writeBool(lobby.editNames);
	buffer.writeString("nameSuggestions");
	let _nameSuggestions = lobby.nameSuggestions
	let _nameSuggestions_startPos = buffer.reserveSize();
	if(_nameSuggestions) {
		var index = _objectCacheIndex.get(_nameSuggestions);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_nameSuggestions, index = _objectCache.length);
			_objectCache.push(_nameSuggestions);
			buffer.writeInt32(-index);
			_nameSuggestions._objectIndex = index;
			buffer.writeInt32(_nameSuggestions.length);
			for(let i=0, len=_nameSuggestions.length; i<len; ++i) {
				buffer.writeString(_nameSuggestions[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_nameSuggestions_startPos);
	buffer.writeString("counter");
	buffer.writeInt32(4);
	buffer.writeInt32(lobby.counter);
	buffer.writeString("");
}
function lobby_deserialize_external(buffer) {
	let inLobby_is_set = false, enableFullscreen_is_set = false, points_is_set = false, fields_is_set = false, showNameIndex_is_set = false, editNames_is_set = false, nameSuggestions_is_set = false, counter_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "inLobby":
				buffer.readInt32();
				lobby.inLobby = buffer.readBool();
				inLobby_is_set = true;
				break;
			case "enableFullscreen":
				buffer.readInt32();
				lobby.enableFullscreen = buffer.readBool();
				enableFullscreen_is_set = true;
				break;
			case "points":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					lobby.points = _objectCache[index];
				} else {
					let _points = lobby.points
					if(!_points || _points._objectIndex != -index) lobby.points = _points = [];
					_objectCache[-index] = _points;
					for(let i=0, len = _points.length = buffer.readInt32(); i<len; ++i) {
							(_points[i] || (_points[i] = new _Vector2())).deserialize_external(buffer);
					}
				}
				points_is_set = true;
				break;
			case "fields":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					lobby.fields = _objectCache[index];
				} else {
					let _fields = lobby.fields
					if(!_fields || _fields._objectIndex != -index) lobby.fields = _fields = [];
					_objectCache[-index] = _fields;
					for(let i=0, len = _fields.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_fields[i] = _objectCache[index];
							} else {
								let _fields_item = _fields[i]
								let type = buffer.readString();
								if(!_fields_item || _fields_item._objectIndex != -index)
									_fields[i] = _fields_item = new_Object_of_type(type);
								_fields_item.type = type;
								(_objectCache[-index] = _fields_item).deserialize_external(buffer);
							}
					}
				}
				fields_is_set = true;
				break;
			case "showNameIndex":
				buffer.readInt32();
				lobby.showNameIndex = buffer.readInt32();
				showNameIndex_is_set = true;
				break;
			case "editNames":
				buffer.readInt32();
				lobby.editNames = buffer.readBool();
				editNames_is_set = true;
				break;
			case "nameSuggestions":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					lobby.nameSuggestions = _objectCache[index];
				} else {
					let _nameSuggestions = lobby.nameSuggestions
					if(!_nameSuggestions || _nameSuggestions._objectIndex != -index) lobby.nameSuggestions = _nameSuggestions = [];
					_objectCache[-index] = _nameSuggestions;
					for(let i=0, len = _nameSuggestions.length = buffer.readInt32(); i<len; ++i) {
							_nameSuggestions[i] = buffer.readString();
					}
				}
				nameSuggestions_is_set = true;
				break;
			case "counter":
				buffer.readInt32();
				lobby.counter = buffer.readInt32();
				counter_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!inLobby_is_set) lobby.inLobby = true;
				if(!enableFullscreen_is_set) lobby.enableFullscreen = true;
				if(!points_is_set) lobby.points = [];
				if(!fields_is_set) lobby.fields = [];
				if(!showNameIndex_is_set) lobby.showNameIndex = 1;
				if(!editNames_is_set) lobby.editNames = false;
				if(!nameSuggestions_is_set) lobby.nameSuggestions = ["Heiko", "Bianca", "Bjarne", "Tim", "Christian", "Svend", "Holger", "Joe", "Kevin", "Simonas", "Dominik", "Felix", "Edi", "Matthias", "Phillip", "Jürgen", "Jakob", "Christopher", "Krzysztof", "Chuck", "Markus", "Nick", "Marijn", "Carina", "Beatrice", "Talea", "Tanja", "Yvonne"];
				if(!counter_is_set) lobby.counter = 0;
				return;
		}
	}
}
var Framework; if(!Framework) Framework = {};
Framework.init = function() {
	Framework.objects = [];
	Framework.selectedObjects = [];
	Framework.toBeRemoved = [];
}
Framework.clear = function(includingLockedObjects) {
	for(let _subject=Framework.objects, i=_subject.length-1; i>=0; --i) { let it = _subject[i]; {
		if(!it.locked || includingLockedObjects) {
			Framework.objects.splice(i, 1);
		}
	}}
}
Framework.clearAtEndOfFrame = function() {
	for(let i=0, _subject=Framework.objects, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(!it.locked) {
			it.hide();
			Framework.toBeRemoved.push(it);
		}
	}}
}
Framework.removeWhere = function(condition) {
	for(let i=0, _subject=Framework.objects, _len=_subject.length; i<_len; ++i) { let obj = _subject[i]; {
		if(condition(obj)) {
			obj.hide();
			Framework.toBeRemoved.push(obj);
		}
	}}
}
Framework.tick = function() {
	fx.tick();
	for(let i=0, _subject=[...Framework.objects], _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		it.tick();
	}}
	input.onTouchUp2(null, true, touch => {
		Framework.deselect(touch.by);
	});
	if((Framework.toBeRemoved != null && Framework.toBeRemoved.length != 0) ) {
		for(let i=0, _subject=Framework.toBeRemoved, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			it.siblings().remove(it);
		}}
		Framework.toBeRemoved.length = 0;
	}
}
Framework.deselect = function(player) {
	Framework.selectedObjects[player.id] = null;
}
Framework.debugString = function() {
	let result = "";
	for(let i=0, _subject=Framework.objects, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		result += it.debugString();
	}}
	return result;
}
function Framework_serialize_internal(buffer) {
	let _objects = Framework.objects
	if(_objects) {
		var index = _objectCacheIndex.get(_objects);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_objects, index = _objectCache.length);
			_objectCache.push(_objects);
			buffer.writeInt32(-index);
			_objects._objectIndex = index;
			buffer.writeInt32(_objects.length);
			for(let i=0, len=_objects.length; i<len; ++i) {
				let _objects_item = _objects[i]
				if(_objects_item) {
					var index = _objectCacheIndex.get(_objects_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_objects_item, index = _objectCache.length);
						_objectCache.push(_objects_item);
						buffer.writeInt32(-index);
						buffer.writeString(_objects_item.type);
						_objects_item._objectIndex = index;
						_objects_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let _selectedObjects = Framework.selectedObjects
	if(_selectedObjects) {
		var index = _objectCacheIndex.get(_selectedObjects);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_selectedObjects, index = _objectCache.length);
			_objectCache.push(_selectedObjects);
			buffer.writeInt32(-index);
			_selectedObjects._objectIndex = index;
			buffer.writeInt32(_selectedObjects.length);
			for(let i=0, len=_selectedObjects.length; i<len; ++i) {
				let _selectedObjects_item = _selectedObjects[i]
				if(_selectedObjects_item) {
					var index = _objectCacheIndex.get(_selectedObjects_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_selectedObjects_item, index = _objectCache.length);
						_objectCache.push(_selectedObjects_item);
						buffer.writeInt32(-index);
						buffer.writeString(_selectedObjects_item.type);
						_selectedObjects_item._objectIndex = index;
						_selectedObjects_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let _toBeRemoved = Framework.toBeRemoved
	if(_toBeRemoved) {
		var index = _objectCacheIndex.get(_toBeRemoved);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_toBeRemoved, index = _objectCache.length);
			_objectCache.push(_toBeRemoved);
			buffer.writeInt32(-index);
			_toBeRemoved._objectIndex = index;
			buffer.writeInt32(_toBeRemoved.length);
			for(let i=0, len=_toBeRemoved.length; i<len; ++i) {
				let _toBeRemoved_item = _toBeRemoved[i]
				if(_toBeRemoved_item) {
					var index = _objectCacheIndex.get(_toBeRemoved_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_toBeRemoved_item, index = _objectCache.length);
						_objectCache.push(_toBeRemoved_item);
						buffer.writeInt32(-index);
						buffer.writeString(_toBeRemoved_item.type);
						_toBeRemoved_item._objectIndex = index;
						_toBeRemoved_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
function Framework_deserialize_internal(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		Framework.objects = _objectCache[index];
	} else {
		let _objects = Framework.objects
		if(!_objects || _objects._objectIndex != -index) Framework.objects = _objects = [];
		_objectCache[-index] = _objects;
		for(let i=0, len = _objects.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_objects[i] = _objectCache[index];
				} else {
					let _objects_item = _objects[i]
					let type = buffer.readString();
					if(!_objects_item || _objects_item._objectIndex != -index)
						_objects[i] = _objects_item = new_Object_of_type(type);
					_objects_item.type = type;
					(_objectCache[-index] = _objects_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Framework.selectedObjects = _objectCache[index];
	} else {
		let _selectedObjects = Framework.selectedObjects
		if(!_selectedObjects || _selectedObjects._objectIndex != -index) Framework.selectedObjects = _selectedObjects = [];
		_objectCache[-index] = _selectedObjects;
		for(let i=0, len = _selectedObjects.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_selectedObjects[i] = _objectCache[index];
				} else {
					let _selectedObjects_item = _selectedObjects[i]
					let type = buffer.readString();
					if(!_selectedObjects_item || _selectedObjects_item._objectIndex != -index)
						_selectedObjects[i] = _selectedObjects_item = new_Object_of_type(type);
					_selectedObjects_item.type = type;
					(_objectCache[-index] = _selectedObjects_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Framework.toBeRemoved = _objectCache[index];
	} else {
		let _toBeRemoved = Framework.toBeRemoved
		if(!_toBeRemoved || _toBeRemoved._objectIndex != -index) Framework.toBeRemoved = _toBeRemoved = [];
		_objectCache[-index] = _toBeRemoved;
		for(let i=0, len = _toBeRemoved.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_toBeRemoved[i] = _objectCache[index];
				} else {
					let _toBeRemoved_item = _toBeRemoved[i]
					let type = buffer.readString();
					if(!_toBeRemoved_item || _toBeRemoved_item._objectIndex != -index)
						_toBeRemoved[i] = _toBeRemoved_item = new_Object_of_type(type);
					_toBeRemoved_item.type = type;
					(_objectCache[-index] = _toBeRemoved_item).deserialize_internal(buffer);
				}
		}
	}
}
function Framework_serialize_external(buffer) {
	buffer.writeString("objects");
	let _objects = Framework.objects
	let _objects_startPos = buffer.reserveSize();
	if(_objects) {
		var index = _objectCacheIndex.get(_objects);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_objects, index = _objectCache.length);
			_objectCache.push(_objects);
			buffer.writeInt32(-index);
			_objects._objectIndex = index;
			buffer.writeInt32(_objects.length);
			for(let i=0, len=_objects.length; i<len; ++i) {
				let _objects_item = _objects[i]
				if(_objects_item) {
					var index = _objectCacheIndex.get(_objects_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_objects_item, index = _objectCache.length);
						_objectCache.push(_objects_item);
						buffer.writeInt32(-index);
						buffer.writeString(_objects_item.type);
						_objects_item._objectIndex = index;
						_objects_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_objects_startPos);
	buffer.writeString("selectedObjects");
	let _selectedObjects = Framework.selectedObjects
	let _selectedObjects_startPos = buffer.reserveSize();
	if(_selectedObjects) {
		var index = _objectCacheIndex.get(_selectedObjects);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_selectedObjects, index = _objectCache.length);
			_objectCache.push(_selectedObjects);
			buffer.writeInt32(-index);
			_selectedObjects._objectIndex = index;
			buffer.writeInt32(_selectedObjects.length);
			for(let i=0, len=_selectedObjects.length; i<len; ++i) {
				let _selectedObjects_item = _selectedObjects[i]
				if(_selectedObjects_item) {
					var index = _objectCacheIndex.get(_selectedObjects_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_selectedObjects_item, index = _objectCache.length);
						_objectCache.push(_selectedObjects_item);
						buffer.writeInt32(-index);
						buffer.writeString(_selectedObjects_item.type);
						_selectedObjects_item._objectIndex = index;
						_selectedObjects_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_selectedObjects_startPos);
	buffer.writeString("toBeRemoved");
	let _toBeRemoved = Framework.toBeRemoved
	let _toBeRemoved_startPos = buffer.reserveSize();
	if(_toBeRemoved) {
		var index = _objectCacheIndex.get(_toBeRemoved);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_toBeRemoved, index = _objectCache.length);
			_objectCache.push(_toBeRemoved);
			buffer.writeInt32(-index);
			_toBeRemoved._objectIndex = index;
			buffer.writeInt32(_toBeRemoved.length);
			for(let i=0, len=_toBeRemoved.length; i<len; ++i) {
				let _toBeRemoved_item = _toBeRemoved[i]
				if(_toBeRemoved_item) {
					var index = _objectCacheIndex.get(_toBeRemoved_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_toBeRemoved_item, index = _objectCache.length);
						_objectCache.push(_toBeRemoved_item);
						buffer.writeInt32(-index);
						buffer.writeString(_toBeRemoved_item.type);
						_toBeRemoved_item._objectIndex = index;
						_toBeRemoved_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_toBeRemoved_startPos);
	buffer.writeString("");
}
function Framework_deserialize_external(buffer) {
	let objects_is_set = false, selectedObjects_is_set = false, toBeRemoved_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "objects":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Framework.objects = _objectCache[index];
				} else {
					let _objects = Framework.objects
					if(!_objects || _objects._objectIndex != -index) Framework.objects = _objects = [];
					_objectCache[-index] = _objects;
					for(let i=0, len = _objects.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_objects[i] = _objectCache[index];
							} else {
								let _objects_item = _objects[i]
								let type = buffer.readString();
								if(!_objects_item || _objects_item._objectIndex != -index)
									_objects[i] = _objects_item = new_Object_of_type(type);
								_objects_item.type = type;
								(_objectCache[-index] = _objects_item).deserialize_external(buffer);
							}
					}
				}
				objects_is_set = true;
				break;
			case "selectedObjects":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Framework.selectedObjects = _objectCache[index];
				} else {
					let _selectedObjects = Framework.selectedObjects
					if(!_selectedObjects || _selectedObjects._objectIndex != -index) Framework.selectedObjects = _selectedObjects = [];
					_objectCache[-index] = _selectedObjects;
					for(let i=0, len = _selectedObjects.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_selectedObjects[i] = _objectCache[index];
							} else {
								let _selectedObjects_item = _selectedObjects[i]
								let type = buffer.readString();
								if(!_selectedObjects_item || _selectedObjects_item._objectIndex != -index)
									_selectedObjects[i] = _selectedObjects_item = new_Object_of_type(type);
								_selectedObjects_item.type = type;
								(_objectCache[-index] = _selectedObjects_item).deserialize_external(buffer);
							}
					}
				}
				selectedObjects_is_set = true;
				break;
			case "toBeRemoved":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Framework.toBeRemoved = _objectCache[index];
				} else {
					let _toBeRemoved = Framework.toBeRemoved
					if(!_toBeRemoved || _toBeRemoved._objectIndex != -index) Framework.toBeRemoved = _toBeRemoved = [];
					_objectCache[-index] = _toBeRemoved;
					for(let i=0, len = _toBeRemoved.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_toBeRemoved[i] = _objectCache[index];
							} else {
								let _toBeRemoved_item = _toBeRemoved[i]
								let type = buffer.readString();
								if(!_toBeRemoved_item || _toBeRemoved_item._objectIndex != -index)
									_toBeRemoved[i] = _toBeRemoved_item = new_Object_of_type(type);
								_toBeRemoved_item.type = type;
								(_objectCache[-index] = _toBeRemoved_item).deserialize_external(buffer);
							}
					}
				}
				toBeRemoved_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!objects_is_set) Framework.objects = [];
				if(!selectedObjects_is_set) Framework.selectedObjects = [];
				if(!toBeRemoved_is_set) Framework.toBeRemoved = [];
				return;
		}
	}
}
function $Object(position, size, angle, alpha, visibleFor, layer, locked, location) {
	this.type = "Object";
	this.position = position?.clone();
	this.size = size?.clone();
	this.angle = angle;
	this.alpha = alpha;
	this.visibleFor = visibleFor;
	this.layer = layer;
	this.locked = locked;
	this.location = location;
	this.siblings().push(this);
}
function new_Object_of_type(type) {
	switch(type) {
		case "Object": return new _Object();
		case "LobbyTextField": return new _LobbyTextField();
		case "RectangleObject": return new _RectangleObject();
		case "CircleObject": return new _CircleObject();
		case "VisualizeObject": return new _VisualizeObject();
		case "TextObject": return new _TextObject();
		case "CircularTextObject": return new _CircularTextObject();
		case "ImageObject": return new _ImageObject();
		case "Effect": return new _Effect();
		case "VideoObject": return new _VideoObject();
		case "Button": return new _Button();
		case "StandardButton": return new _StandardButton();
		case "ParticleSystem": return new _ParticleSystem();
		case "Menu": return new _Menu();
	}
}
$Object.prototype.siblings = function() {
	return Framework.objects;
}
$Object.prototype.debugString = function() {
	return "(Object pos:"+this.position.x.toString()+" "+this.position.y.toString()+")";
}
$Object.prototype.tick = function() {
}
$Object.prototype.removeImmediately = function() {
	this.siblings().remove(this);
}
$Object.prototype.removeAtEndOfFrame = function() {
	Framework.toBeRemoved.push(this);
}
$Object.prototype.hide = function() {
	this.alpha = 0.0;
}
$Object.prototype.show = function() {
	this.alpha = 1.0;
}
$Object.prototype.moveToFront = function() {
	this.siblings().moveToFront(this);
}
$Object.prototype.moveToBack = function() {
	this.siblings().moveToBack(this);
}
$Object.prototype.moveTo = function(pos, duration, delay) {
	let startPosition = this.position?.clone();
	let moveAnimation = fx.animations.findLast(a => a.type == "MoveAnimation" && a.object == this);
	if((moveAnimation != null)) {
		startPosition.assign(moveAnimation.startValue.plus(moveAnimation.delta));
	}
	let delta = pos.minus(startPosition);
	fx.add(new MoveAnimation((fx.endOfPrevAnimation(this) + delay), duration, this, startPosition, delta));
	return this;
}
$Object.prototype.moveTo2 = function(pos, speed, delay) {
	let delta = pos.minus(this.position);
	let duration = Math.floor(delta.length() / speed);
	fx.add(new MoveAnimation((fx.endOfPrevAnimation(this) + delay), duration, this, this.position, delta));
	return this;
}
$Object.prototype.moveAndScaleTo = function(position, size, duration, delay) {
	let startPosition = this.position?.clone();
	let startSize = this.size?.clone();
	let endSize = (size.y ? size : new Vector2(size.x, size.x * startSize.y / startSize.x, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 3364, 3406, null, null)))?.clone();
	let moveAnimation = fx.animations.findLast(a => a.type == "MoveAnimation" && a.object == this);
	if((moveAnimation != null)) {
		startPosition.assign(moveAnimation.startValue.plus(moveAnimation.delta));
	}
	let startTime = fx.endOfPrevAnimation(this) + delay;
	fx.add(new MoveAnimation(startTime, duration, this, startPosition, position.minus(startPosition)));
	fx.add(new ScaleAnimation(startTime, duration, this, startSize, endSize.minus(startSize)));
	return this;
}
$Object.prototype.fadeIn = function(duration, delay) {
	this.alpha = 0;
	fx.add(new FadeAnimation((fx.endOfPrevAnimation(this) + delay), duration, this, 0, 1, false));
	return this;
}
$Object.prototype.scaleTo = function(size, duration, delay) {
	fx.add(new ScaleAnimation((fx.endOfPrevAnimation(this) + delay), duration, this, this.size, size.minus(this.size)));
	return this;
}
$Object.prototype.do = function($do, delay) {
	fx.add(new DelayAnimation((fx.endOfPrevAnimation(this) + delay), 0, this, $do));
}
$Object.prototype.playSound = function(sound, delay) {
	fx.add(new PlaySoundAnimation((fx.endOfPrevAnimation(this) + delay), 0, this, sound));
}
$Object.prototype.fadeAndScaleIn = function(startScale, duration, delay) {
	this.alpha = 0;
	let startTime = fx.endOfPrevAnimation(this) + delay;
	fx.add(new ScaleAnimation(startTime, duration, this, new Vector2(startScale * this.size.x, startScale * this.size.y, this.size.location), new Vector2((1 - startScale) * this.size.x, (1 - startScale) * this.size.y, this.size.location)));
	fx.add(new FadeAnimation(startTime, duration, this, 0, 1, false));
	return this;
}
$Object.prototype.fadeScaleAndRotateIn = function(startScale, startAngle, endAngle, duration, delay) {
	this.alpha = 0;
	let startTime = fx.endOfPrevAnimation(this) + delay;
	fx.add(new RotateAnimation(startTime, duration, this, startAngle, endAngle - startAngle));
	fx.add(new ScaleAnimation(startTime, duration, this, new Vector2(startScale * this.size.x, startScale * this.size.y, this.size.location), new Vector2((1 - startScale) * this.size.x, (1 - startScale) * this.size.y, this.size.location)));
	fx.add(new FadeAnimation(startTime, duration, this, 0, 1, false));
	return this;
}
$Object.prototype.removeAnimations = function() {
	fx.removeForObject(this);
}
$Object.prototype.clone = function() {
	let clone = new _Object();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.angle = this.angle;
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	return clone;
}
function _Object() {};
_Object.prototype = $Object.prototype;
$Object.prototype.serialize_internal = function(buffer) {
	(this.position || new _Vector2()).serialize_internal(buffer);
	(this.size || new _Vector2()).serialize_internal(buffer);
	buffer.writeFloat64(this.angle);
	buffer.writeFloat64(this.alpha);
	let visibleFor = this.visibleFor
	if(visibleFor) {
		var index = _objectCacheIndex.get(visibleFor);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(visibleFor, index = _objectCache.length);
			_objectCache.push(visibleFor);
			buffer.writeInt32(-index);
			visibleFor._objectIndex = index;
			buffer.writeInt32(visibleFor.length);
			for(let i=0, len=visibleFor.length; i<len; ++i) {
				let visibleFor_item = visibleFor[i]
				if(visibleFor_item) {
					var index = _objectCacheIndex.get(visibleFor_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(visibleFor_item, index = _objectCache.length);
						_objectCache.push(visibleFor_item);
						buffer.writeInt32(-index);
						visibleFor_item._objectIndex = index;
						visibleFor_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.layer);
	buffer.writeBool(this.locked);
}
$Object.prototype.deserialize_internal = function(buffer) {
	(this.position || (this.position = new _Vector2())).deserialize_internal(buffer);
	(this.size || (this.size = new _Vector2())).deserialize_internal(buffer);
	this.angle = buffer.readFloat64();
	this.alpha = buffer.readFloat64();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.visibleFor = _objectCache[index];
	} else {
		let visibleFor = this.visibleFor
		if(!visibleFor || visibleFor._objectIndex != -index) this.visibleFor = visibleFor = [];
		_objectCache[-index] = visibleFor;
		for(let i=0, len = visibleFor.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					visibleFor[i] = _objectCache[index];
				} else {
					let visibleFor_item = visibleFor[i]
					if(!visibleFor_item || visibleFor_item._objectIndex != -index)
						visibleFor[i] = visibleFor_item = new _Player();
					(_objectCache[-index] = visibleFor_item).deserialize_internal(buffer);
				}
		}
	}
	this.layer = buffer.readInt32();
	this.locked = buffer.readBool();
}
$Object.prototype.serialize_external = function(buffer) {
	buffer.writeString("position");
	let position_startPos = buffer.reserveSize();
	(this.position || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(position_startPos);
	buffer.writeString("size");
	let size_startPos = buffer.reserveSize();
	(this.size || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(size_startPos);
	buffer.writeString("angle");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.angle);
	buffer.writeString("alpha");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.alpha);
	buffer.writeString("visibleFor");
	let visibleFor = this.visibleFor
	let visibleFor_startPos = buffer.reserveSize();
	if(visibleFor) {
		var index = _objectCacheIndex.get(visibleFor);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(visibleFor, index = _objectCache.length);
			_objectCache.push(visibleFor);
			buffer.writeInt32(-index);
			visibleFor._objectIndex = index;
			buffer.writeInt32(visibleFor.length);
			for(let i=0, len=visibleFor.length; i<len; ++i) {
				let visibleFor_item = visibleFor[i]
				if(visibleFor_item) {
					var index = _objectCacheIndex.get(visibleFor_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(visibleFor_item, index = _objectCache.length);
						_objectCache.push(visibleFor_item);
						buffer.writeInt32(-index);
						visibleFor_item._objectIndex = index;
						visibleFor_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(visibleFor_startPos);
	buffer.writeString("layer");
	buffer.writeInt32(4);
	buffer.writeInt32(this.layer);
	buffer.writeString("locked");
	buffer.writeInt32(1);
	buffer.writeBool(this.locked);
	buffer.writeString("");
}
$Object.prototype.deserialize_external = function(buffer) {
	let position_is_set = false, size_is_set = false, angle_is_set = false, alpha_is_set = false, visibleFor_is_set = false, layer_is_set = false, locked_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "position":
				buffer.readInt32();
				(this.position || (this.position = new _Vector2())).deserialize_external(buffer);
				position_is_set = true;
				break;
			case "size":
				buffer.readInt32();
				(this.size || (this.size = new _Vector2())).deserialize_external(buffer);
				size_is_set = true;
				break;
			case "angle":
				buffer.readInt32();
				this.angle = buffer.readFloat64();
				angle_is_set = true;
				break;
			case "alpha":
				buffer.readInt32();
				this.alpha = buffer.readFloat64();
				alpha_is_set = true;
				break;
			case "visibleFor":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.visibleFor = _objectCache[index];
				} else {
					let visibleFor = this.visibleFor
					if(!visibleFor || visibleFor._objectIndex != -index) this.visibleFor = visibleFor = [];
					_objectCache[-index] = visibleFor;
					for(let i=0, len = visibleFor.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								visibleFor[i] = _objectCache[index];
							} else {
								let visibleFor_item = visibleFor[i]
								if(!visibleFor_item || visibleFor_item._objectIndex != -index)
									visibleFor[i] = visibleFor_item = new _Player();
								(_objectCache[-index] = visibleFor_item).deserialize_external(buffer);
							}
					}
				}
				visibleFor_is_set = true;
				break;
			case "layer":
				buffer.readInt32();
				this.layer = buffer.readInt32();
				layer_is_set = true;
				break;
			case "locked":
				buffer.readInt32();
				this.locked = buffer.readBool();
				locked_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!position_is_set) this.position = new Vector2(0.0, 0.0, null);
				if(!size_is_set) this.size = new Vector2(0.0, 0.0, null);
				if(!angle_is_set) this.angle = 0.0;
				if(!alpha_is_set) this.alpha = 1;
				if(!visibleFor_is_set) this.visibleFor = null;
				if(!layer_is_set) this.layer = 0;
				if(!locked_is_set) this.locked = false;
				return;
		}
	}
}
function Particle(pos, speed, angle, rotationSpeed, frame) {
	this.pos = pos?.clone();
	this.speed = speed?.clone();
	this.angle = angle;
	this.rotationSpeed = rotationSpeed;
	this.frame = frame;
}
Particle.prototype.clone = function() {
	let clone = new _Particle();
	clone.pos = this.pos.clone();
	clone.speed = this.speed.clone();
	clone.angle = this.angle;
	clone.rotationSpeed = this.rotationSpeed;
	clone.frame = this.frame;
	return clone;
}
function _Particle() {};
_Particle.prototype = Particle.prototype;
Particle.prototype.serialize_internal = function(buffer) {
	(this.pos || new _Vector2()).serialize_internal(buffer);
	(this.speed || new _Vector2()).serialize_internal(buffer);
	buffer.writeFloat64(this.angle);
	buffer.writeFloat64(this.rotationSpeed);
	buffer.writeInt32(this.frame);
}
Particle.prototype.deserialize_internal = function(buffer) {
	(this.pos || (this.pos = new _Vector2())).deserialize_internal(buffer);
	(this.speed || (this.speed = new _Vector2())).deserialize_internal(buffer);
	this.angle = buffer.readFloat64();
	this.rotationSpeed = buffer.readFloat64();
	this.frame = buffer.readInt32();
}
Particle.prototype.serialize_external = function(buffer) {
	buffer.writeString("pos");
	let pos_startPos = buffer.reserveSize();
	(this.pos || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(pos_startPos);
	buffer.writeString("speed");
	let speed_startPos = buffer.reserveSize();
	(this.speed || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(speed_startPos);
	buffer.writeString("angle");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.angle);
	buffer.writeString("rotationSpeed");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.rotationSpeed);
	buffer.writeString("frame");
	buffer.writeInt32(4);
	buffer.writeInt32(this.frame);
	buffer.writeString("");
}
Particle.prototype.deserialize_external = function(buffer) {
	let pos_is_set = false, speed_is_set = false, angle_is_set = false, rotationSpeed_is_set = false, frame_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "pos":
				buffer.readInt32();
				(this.pos || (this.pos = new _Vector2())).deserialize_external(buffer);
				pos_is_set = true;
				break;
			case "speed":
				buffer.readInt32();
				(this.speed || (this.speed = new _Vector2())).deserialize_external(buffer);
				speed_is_set = true;
				break;
			case "angle":
				buffer.readInt32();
				this.angle = buffer.readFloat64();
				angle_is_set = true;
				break;
			case "rotationSpeed":
				buffer.readInt32();
				this.rotationSpeed = buffer.readFloat64();
				rotationSpeed_is_set = true;
				break;
			case "frame":
				buffer.readInt32();
				this.frame = buffer.readInt32();
				frame_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!pos_is_set) this.pos = new Vector2(0.0, 0.0, null);
				if(!speed_is_set) this.speed = new Vector2(0.0, 0.0, null);
				if(!angle_is_set) this.angle = 0.0;
				if(!rotationSpeed_is_set) this.rotationSpeed = 0.0;
				if(!frame_is_set) this.frame = 0;
				return;
		}
	}
}
function MenuItem(image, label, type, value, onClick) {
	this.image = image;
	this.label = label;
	this.type = type;
	this.value = value;
	this.onClick = onClick;
}
MenuItem.prototype.clone = function() {
	let clone = new _MenuItem();
	clone.image = this.image;
	clone.label = this.label;
	clone.type = this.type;
	clone.value = this.value;
	clone.onClick = this.onClick;
	return clone;
}
function _MenuItem() {};
_MenuItem.prototype = MenuItem.prototype;
MenuItem.prototype.serialize_internal = function(buffer) {
	let image = this.image
	if(image) {
		var index = _objectCacheIndex.get(image);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(image, index = _objectCache.length);
			_objectCache.push(image);
			buffer.writeInt32(-index);
			image._objectIndex = index;
			image.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeString(this.label);
	buffer.writeInt32(this.type);
	buffer.writeBool(this.value);
	let onClick = this.onClick
	if(onClick) {
		var index = _objectCacheIndex.get(onClick);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(onClick, index = _objectCache.length);
			_objectCache.push(onClick);
			buffer.writeInt32(-index);
			buffer.writeInt32(onClick._id);
			onClick._objectIndex = index;
			onClick.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
MenuItem.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this.image = _objectCache[index];
	} else {
		let image = this.image
		if(!image || image._objectIndex != -index)
			this.image = image = new _Image();
		(_objectCache[-index] = image).deserialize_internal(buffer);
	}
	this.label = buffer.readString();
	this.type = buffer.readInt32();
	this.value = buffer.readBool();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.onClick = _objectCache[index];
	} else {
		let onClick = this.onClick
		let _id = buffer.readInt32();
		if(!onClick || onClick._id != _id || onClick._objectIndex != -index)
			this.onClick = onClick = new _lambdaContructors[_id]();
		onClick._id = _id;
		(_objectCache[-index] = onClick).deserialize_internal(buffer);
	}
}
MenuItem.prototype.serialize_external = function(buffer) {
	buffer.writeString("image");
	let image_startPos = buffer.reserveSize();
	let image = this.image
	if(image) {
		var index = _objectCacheIndex.get(image);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(image, index = _objectCache.length);
			_objectCache.push(image);
			buffer.writeInt32(-index);
			image._objectIndex = index;
			image.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(image_startPos);
	buffer.writeString("label");
	buffer.writeString(this.label);
	buffer.writeString("type");
	buffer.writeInt32(4);
	buffer.writeInt32(this.type);
	buffer.writeString("value");
	buffer.writeInt32(1);
	buffer.writeBool(this.value);
	buffer.writeString("onClick");
	let onClick_startPos = buffer.reserveSize();
	let onClick = this.onClick
	if(onClick) {
		var index = _objectCacheIndex.get(onClick);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(onClick, index = _objectCache.length);
			_objectCache.push(onClick);
			buffer.writeInt32(-index);
			buffer.writeInt32(onClick._id);
			onClick._objectIndex = index;
			onClick.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(onClick_startPos);
	buffer.writeString("");
}
MenuItem.prototype.deserialize_external = function(buffer) {
	let image_is_set = false, label_is_set = false, type_is_set = false, value_is_set = false, onClick_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "image":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.image = _objectCache[index];
				} else {
					let image = this.image
					if(!image || image._objectIndex != -index)
						this.image = image = new _Image();
					(_objectCache[-index] = image).deserialize_external(buffer);
				}
				image_is_set = true;
				break;
			case "label":
				this.label = buffer.readString();
				label_is_set = true;
				break;
			case "type":
				buffer.readInt32();
				this.type = buffer.readInt32();
				type_is_set = true;
				break;
			case "value":
				buffer.readInt32();
				this.value = buffer.readBool();
				value_is_set = true;
				break;
			case "onClick":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.onClick = _objectCache[index];
				} else {
					let onClick = this.onClick
					let _id = buffer.readInt32();
					if(!onClick || onClick._id != _id || onClick._objectIndex != -index)
						this.onClick = onClick = new _lambdaContructors[_id]();
					onClick._id = _id;
					(_objectCache[-index] = onClick).deserialize_external(buffer);
				}
				onClick_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!image_is_set) this.image = null;
				if(!label_is_set) this.label = "";
				if(!type_is_set) this.type = 0/*Button*/;
				if(!value_is_set) this.value = false;
				if(!onClick_is_set) this.onClick = null;
				return;
		}
	}
}
var statistics; if(!statistics) statistics = {};
statistics.framesPerValue = 15;
statistics.init = function() {
	statistics.backgroundColor = new Color("#202020", "");
	_constCache.push(statistics.backgroundColor);
	statistics.margin = new Vector2(224, 126, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/core.l", 28605, 28614, null, null));
	statistics.position = new Vector2(-960, 540, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/core.l", 28641, 28652, null, null));
	statistics.size = new Vector2(1920 + statistics.margin.x, statistics.margin.y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/core.l", 28675, 28700, null, null));
	statistics.serverPings = [];
	statistics.successfullySentServerPings = 0;
	statistics.graphs = [];
	statistics.systemLogs = [];
	statistics.gameLogs = [];
	statistics.successfullySentGameLogs = 0;
	statistics.successfullySentSystemLogs = 0;
	statistics.startTime = 0.0;
	statistics.loadTime = 0.0;
	statistics.cameraTime = 0.0;
	statistics.connectTime = 0.0;
	statistics.maxValue = 0.0;
	statistics.currentSet = 0;
	statistics.sets = 1;
	statistics.id = 0;
	statistics.infos = [];
	statistics.infoNames = [];
	statistics.currentlySendingStatistics = false;
	statistics.sessionStarted = false;
	statistics.nextSendTime = Number.MAX_VALUE;
}
statistics.draw = function() {
	let startPos = statistics.position.plus(statistics.size);
	let labelPos = statistics.position.plus(new Vector2(statistics.size.x / 2, -12, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 162, 177, null, null)));
	let height = statistics.size.y - 20;
	let graphIndex = 0;
	for(let i=0, _subject=statistics.graphs, _len=_subject.length; i<_len; ++i) { let s = _subject[i]; {
		if(s.set != statistics.currentSet) {
			continue;
		}
		let text = ""+s.label+": "+s.lastValue().toLocaleString("en-US", {maximumFractionDigits:1, minimumFractionDigits:1, minimumIntegerDigits:1, useGrouping:false});
		graphics.drawRectangle(labelPos, new Vector2(8, 8, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 375, 380, null, null)), s.color, null, 0, null, 0, 1.0, 0/*Left*/, 1/*Middle*/, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 351, 406, null, null));
		graphics.drawText(text, labelPos.plus(new Vector2(11, -2, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 434, 442, null, null))), new Vector2(12, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 461, 463, null, null)), null, 0/*Left*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, 0, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 410, 463, null, null));
		labelPos.x += graphics.getTextWidth(text, new Vector2(12, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 514, 516, null, null)), null, 0/*Normal*/) + 50;
		let len = Math.min(s.values.length, Math.round(statistics.size.x));
		let prevY = 0;
		for(let i=0; i<len; ++i) {
			let value = s.values[s.values.length - 1 - i];
			let pos = new Vector2(startPos.x - i, startPos.y - ((value / statistics.maxValue) > 1 ? 1 : (value / statistics.maxValue)) * height + graphIndex, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 673, 750, null, null));
			if(i) {
				graphics.drawRectangle(pos, new Vector2(4, prevY - pos.y + 4, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 785, 803, null, null)), s.color, null, 0, null, 0, 1.0, 1/*Center*/, 0/*Top*/, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 761, 830, null, null));
			}
			prevY = pos.y;
		}
		graphIndex++;
	}}
	for(let _subject=statistics.infos, i=_subject.length-1; i>=0; --i) { let it = _subject[i]; {
		let x = (core.frame - it.frame) / statistics.framesPerValue;
		if(x > statistics.size.x) {
			break;
		}
		graphics.drawText(it.value.toString(), new Vector2(statistics.position.x + statistics.size.x - x, statistics.position.y + 10 * it.index, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 998, 1047, null, null)), new Vector2(8, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 1054, 1055, null, null)), null, 1/*Center*/, 0/*Top*/, 0/*Normal*/, null, null, 0, 0, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 976, 1067, null, null));
	}}
	if(core.errorMessage) {
		graphics.drawText(core.errorMessage, statistics.position, new Vector2(12, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 1152, 1154, null, null)), new Color("#ffff00", ""), 0/*Left*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, 0, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 1097, 1173, null, null));
	}
	graphics.drawText("#"+core.frame?.toString()+" "+statistics.maxValue.toString(), new Vector2(statistics.position.x + statistics.size.x - 8, labelPos.y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 1213, 1246, null, null)), new Vector2(12, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 1266, 1268, null, null)), null, 2/*Right*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, 0, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 1176, 1268, null, null));
	graphics.drawRectangle(statistics.position, statistics.size, statistics.backgroundColor, null, 0, null, 0, 1.0, 0/*Left*/, 0/*Top*/, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 1271, 1346, null, null));
}
statistics.scheduleSendIn = function(delay) {
	statistics.nextSendTime = Math.min(statistics.nextSendTime, Date.now() + delay);
}
statistics.tick = function() {
	if(Date.now() > statistics.nextSendTime) {
		if(!statistics.sessionStarted) {
			statistics.startSession();
		} else {
			statistics.saveStatistics();
		}
		statistics.nextSendTime = (Date.now() + core.sendStatisticsEvery);
	}
}
statistics.log = function(value) {
	value.frame = core.frame;
	statistics.gameLogs.push(value);
}
statistics.startSession = function() {
	core.log("#statistics Start Session");
	if(statistics.currentlySendingStatistics) {
		return;
	}
	statistics.currentlySendingStatistics = true;
	let user = storage.getObjectDirectly("user");
	let server = location.hostname.getUntil(".", 0);
	let userId = input.localUser.id;
	statistics.id = core.roomId * 100 + userId;
	let sendingSystemLogsUntil = statistics.systemLogs.length;
	http.postDirectly2(""+Platform.protocolAndHost()+":3114/startSession", ({id:statistics.id, gameId:core.gameId, roomId:core.roomId, userId:userId, userIndex:input.localUser.index, userEmail:user.email, version:_buildVersion, staging:Platform.isStaging, server:server, times:[statistics.loadTime, statistics.connectTime, statistics.cameraTime], systemLogs:statistics.systemLogs.slice(statistics.successfullySentSystemLogs)}), result => {
		statistics.successfullySentSystemLogs = sendingSystemLogsUntil;
		statistics.currentlySendingStatistics = false;
		statistics.sessionStarted = true;
	}, () => {
		statistics.currentlySendingStatistics = false;
	});
}
statistics.saveStatistics = function() {
	core.log("#statistics Send Statistics");
	if(statistics.currentlySendingStatistics) {
		return;
	}
	statistics.currentlySendingStatistics = true;
	let connections = [];
	for(let i=0, _subject=input.players, _len=_subject.length; i<_len; ++i) { let p = _subject[i]; {
		let internalUser = input.internalUsers[p.id];
		connections.push(internalUser.connectionType);
	}}
	for(let i=0, _subject=statistics.graphs, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		it.valuesToSend = it.values.slice(it.successfullySentUntil);
		it.sendingUntil = it.values.length;
	}}
	let sendingServerPingsUntil = statistics.serverPings.length;
	let sendingSystemLogsUntil = statistics.systemLogs.length;
	let sendingGameLogsUntil = statistics.gameLogs.length;
	http.postDirectly2(""+Platform.protocolAndHost()+":3114/saveStatistics", ({id:statistics.id, connections:connections, graphLabels:statistics.graphs.map((it,i) => it.label), graphs:statistics.graphs.map((it,i) => it.valuesToSend), serverPings:statistics.serverPings.slice(statistics.successfullySentServerPings), systemLogs:statistics.systemLogs.slice(statistics.successfullySentSystemLogs), gameLogs:statistics.gameLogs.slice(statistics.successfullySentGameLogs)}), result => {
		for(let i=0, _subject=statistics.graphs, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			it.successfullySentUntil = it.sendingUntil;
		}}
		statistics.successfullySentServerPings = sendingServerPingsUntil;
		statistics.successfullySentSystemLogs = sendingSystemLogsUntil;
		statistics.successfullySentGameLogs = sendingGameLogsUntil;
		statistics.currentlySendingStatistics = false;
	}, () => {
		statistics.currentlySendingStatistics = false;
	});
}
statistics.add = function(label, userIndex, value, color, set, isPerFrame) {
	if(userIndex != -1) {
		label += " #"+userIndex?.toString();
	}
	let s = statistics.graphs.find(a => a.label == label);
	if(!(s != null)) {
		statistics.graphs.push(s = new StatisticsGraph(userIndex, set, label, [], color, [], [], 0, 0));
		(set + 1 > statistics.sets ? statistics.sets = set + 1 : statistics.sets);
	}
	s.color = color;
	if(isPerFrame) {
		s.add(value);
	} else {
		s.addDirectly(value);
	}
}
statistics.addInfo = function(name, value) {
	let index = statistics.infoNames.indexOf(name);
	if(index == -1) {
		index = statistics.infoNames.length;
		statistics.infoNames.push(name);
	}
	statistics.infos.push(new StatisticsInfo(value, index, core.frame));
}
statistics.tickGraph = function() {
	input.onTouchDown(statistics.position, statistics.size, null, "auto", false, true, 0/*Left*/, 0/*Top*/, touch => {
		(statistics.currentSet = (((statistics.currentSet+1) % statistics.sets) + statistics.sets) % statistics.sets);
	});
	statistics.maxValue = 12;
	for(let i=0, _subject=statistics.graphs, _len=_subject.length; i<_len; ++i) { let s = _subject[i]; {
		if(s.set != statistics.currentSet) {
			continue;
		}
		let len = Math.min(s.values.length, 50);
		for(let i=0; i<len; ++i) {
			let value = s.values[s.values.length - 1 - i];
			if(value > statistics.maxValue) {
				statistics.maxValue = value;
			}
		}
	}}
	statistics.draw();
}
var networkVisualizer; if(!networkVisualizer) networkVisualizer = {};
networkVisualizer.init = function() {
	networkVisualizer.posForPlayer = [0, -10000, -10000, -10000, -10000, -10000];
}
networkVisualizer.draw = function() {
	if(core.simulateInputsForTesting) {
		for(let i=0, _subject=input.players, _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
			graphics.drawCircle(new Vector2(1110 + player.index * 20, -540 + networkVisualizer.posForPlayer[player.index], new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 1472, 1527, null, null)), new Vector2(20, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 1534, 1536, null, null)), player.color, null, 0, 0, 1.0, 0/*Clockwise*/, null, 0, 1.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 1461, 1550, null, null));
		}}
	}
	for(let i=0, _subject=input.players, _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		let internaluser = input.internalUsers[player.id];
		if((internaluser != null)) {
			let bufferY = 510 - networkVisualizer.getHeightForFrame(core.frame - internaluser.bufferFrames + 1);
			graphics.drawLine(new Vector2(960, bufferY, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 2020, 2033, null, null)), new Vector2(1100, bufferY, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 2037, 2051, null, null)), player.color, 3, null, 0, 1.0);
			graphics.drawText(internaluser.bufferFrames?.toString(), new Vector2(1110, bufferY, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 2119, 2134, null, null)), new Vector2(20, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 2141, 2143, null, null)), player.color, 0/*Left*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, 0, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 2078, 2169, null, null));
			graphics.drawRectangle(new Vector2(984 + player.index * 32, 510, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 2191, 2217, null, null)), new Vector2(24, networkVisualizer.getHeightForFrame(internaluser.inputFrame), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 2223, 2271, null, null)), player.color, null, 0, null, 0, 1.0, 1/*Center*/, 2/*Bottom*/, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 2177, 2300, null, null));
		}
	}}
	if(core.replayFrom != -1) {
		let bufferY = 510 - networkVisualizer.getHeightForFrame(core.replayFrom);
		graphics.drawLine(new Vector2(960, bufferY, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 2418, 2431, null, null)), new Vector2(1100, bufferY, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 2435, 2449, null, null)), Color.White, 3, null, 0, 1.0);
		graphics.drawText((core.frame - core.replayFrom)?.toString(), new Vector2(1110, bufferY, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 2519, 2534, null, null)), new Vector2(20, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 2541, 2543, null, null)), Color.White, 0/*Left*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, 0, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/statistics.l", 2474, 2568, null, null));
	}
}
networkVisualizer.tick = function() {
	if(core.simulateInputsForTesting) {
		for(let i=0, _subject=input.players, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			if(networkVisualizer.posForPlayer[it.index] == -10000) {
				networkVisualizer.posForPlayer[it.index] = networkVisualizer.posForPlayer[0];
			}
		}}
		for(let i=0, _subject=input.players, _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
			core.smooth(player, () => {
				input.onKeyDown3([player], (key,pressedBy,cmdOrCtrl,alt,shift) => {
					if((networkVisualizer.posForPlayer[player.index] += 2) > 1080) {
						networkVisualizer.posForPlayer[player.index] -= 1080;
					}
				});
			});
		}}
	}
	networkVisualizer.draw();
}
networkVisualizer.getHeightForFrame = function(frame) {
	return (50 + frame - core.frame) * 20;
}
function networkVisualizer_serialize_internal(buffer) {
	let _posForPlayer = networkVisualizer.posForPlayer
	if(_posForPlayer) {
		var index = _objectCacheIndex.get(_posForPlayer);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_posForPlayer, index = _objectCache.length);
			_objectCache.push(_posForPlayer);
			buffer.writeInt32(-index);
			_posForPlayer._objectIndex = index;
			buffer.writeInt32(_posForPlayer.length);
			for(let i=0, len=_posForPlayer.length; i<len; ++i) {
				buffer.writeInt32(_posForPlayer[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
function networkVisualizer_deserialize_internal(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		networkVisualizer.posForPlayer = _objectCache[index];
	} else {
		let _posForPlayer = networkVisualizer.posForPlayer
		if(!_posForPlayer || _posForPlayer._objectIndex != -index) networkVisualizer.posForPlayer = _posForPlayer = [];
		_objectCache[-index] = _posForPlayer;
		for(let i=0, len = _posForPlayer.length = buffer.readInt32(); i<len; ++i) {
				_posForPlayer[i] = buffer.readInt32();
		}
	}
}
function networkVisualizer_serialize_external(buffer) {
	buffer.writeString("posForPlayer");
	let _posForPlayer = networkVisualizer.posForPlayer
	let _posForPlayer_startPos = buffer.reserveSize();
	if(_posForPlayer) {
		var index = _objectCacheIndex.get(_posForPlayer);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_posForPlayer, index = _objectCache.length);
			_objectCache.push(_posForPlayer);
			buffer.writeInt32(-index);
			_posForPlayer._objectIndex = index;
			buffer.writeInt32(_posForPlayer.length);
			for(let i=0, len=_posForPlayer.length; i<len; ++i) {
				buffer.writeInt32(_posForPlayer[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_posForPlayer_startPos);
	buffer.writeString("");
}
function networkVisualizer_deserialize_external(buffer) {
	let posForPlayer_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "posForPlayer":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					networkVisualizer.posForPlayer = _objectCache[index];
				} else {
					let _posForPlayer = networkVisualizer.posForPlayer
					if(!_posForPlayer || _posForPlayer._objectIndex != -index) networkVisualizer.posForPlayer = _posForPlayer = [];
					_objectCache[-index] = _posForPlayer;
					for(let i=0, len = _posForPlayer.length = buffer.readInt32(); i<len; ++i) {
							_posForPlayer[i] = buffer.readInt32();
					}
				}
				posForPlayer_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!posForPlayer_is_set) networkVisualizer.posForPlayer = [0, -10000, -10000, -10000, -10000, -10000];
				return;
		}
	}
}
var file; if(!file) file = {};
file.saveText = function(filename, text) {
	var element = document.createElement("a");
	element.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(text));
	element.setAttribute("download", filename);
	element.style.display = "none";
	document.body.appendChild(element);
	element.click();
	document.body.removeChild(element);
}
file.saveBinary = function(filename, buffer) {
	var binary = "";
	var bytes = new Uint8Array(buffer.buffer);
	var len = bytes.byteLength;
	for (var i = 0; i < len; i++) {
		binary += String.fromCharCode(bytes[i]);
	}
	var base64 = window.btoa( binary );
	var dataUrl = "data:text/plain;base64," + base64;
	
	var element = document.createElement("a");
	element.setAttribute("href", dataUrl);
	element.setAttribute("download", filename);
	element.style.display = "none";
	document.body.appendChild(element);
	element.click();
	document.body.removeChild(element);
}
file.openBinary = function(then, $else) {
	fileInput = document.createElement("input")
	fileInput.type = "file"
	fileInput.style.display = "none"
	fileInput.onchange = e => {
		var file = e.target.files[0];
		if (!file) {
			$else?.("")
			return
		}
		var reader = new FileReader();
		reader.onload = function(e) {
			let buffer = new Buffer(e.target.result, 0, 0, 0);
			document.body.removeChild(fileInput);
			then(buffer);
		}
		reader.onabort = e => {
			$else?.(reader.error)
		}
		reader.onerror = e => {
			$else?.(reader.error)
		}
		reader.readAsArrayBuffer(file)
	}
	document.body.appendChild(fileInput)
	fileInput.click()
}
function HTMLElement(position, size, color) {
	this.type = "HTMLElement";
	this.position = position?.clone();
	this.size = size?.clone();
	this.color = color;
	this.element = null;
	HTMLElement.elements.push(this);
}
function new_HTMLElement_of_type(type) {
	switch(type) {
		case "HTMLElement": return new _HTMLElement();
		case "HTMLInput": return new _HTMLInput();
	}
}
HTMLElement.init = function() {
	HTMLElement.elements = [];
}
HTMLElement.prototype.tick = function() {
}
HTMLElement.clear = function() {
	if(HTMLElement.elements) {
		for(let el of HTMLElement.elements) {
			el.remove()
		}
	}
}
HTMLElement.prototype.clone = function() {
	let clone = new _HTMLElement();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.color = this.color;
	clone.element = this.element;
	return clone;
}
function _HTMLElement() {};
_HTMLElement.prototype = HTMLElement.prototype;
function HTMLElement_serialize_internal(buffer) {
	let _elements = HTMLElement.elements
	if(_elements) {
		var index = _objectCacheIndex.get(_elements);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_elements, index = _objectCache.length);
			_objectCache.push(_elements);
			buffer.writeInt32(-index);
			_elements._objectIndex = index;
			buffer.writeInt32(_elements.length);
			for(let i=0, len=_elements.length; i<len; ++i) {
				let _elements_item = _elements[i]
				if(_elements_item) {
					var index = _objectCacheIndex.get(_elements_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_elements_item, index = _objectCache.length);
						_objectCache.push(_elements_item);
						buffer.writeInt32(-index);
						buffer.writeString(_elements_item.type);
						_elements_item._objectIndex = index;
						_elements_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
function HTMLElement_deserialize_internal(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		HTMLElement.elements = _objectCache[index];
	} else {
		let _elements = HTMLElement.elements
		if(!_elements || _elements._objectIndex != -index) HTMLElement.elements = _elements = [];
		_objectCache[-index] = _elements;
		for(let i=0, len = _elements.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_elements[i] = _objectCache[index];
				} else {
					let _elements_item = _elements[i]
					let type = buffer.readString();
					if(!_elements_item || _elements_item._objectIndex != -index)
						_elements[i] = _elements_item = new_HTMLElement_of_type(type);
					_elements_item.type = type;
					(_objectCache[-index] = _elements_item).deserialize_internal(buffer);
				}
		}
	}
}
HTMLElement.prototype.serialize_internal = function(buffer) {
	(this.position || new _Vector2()).serialize_internal(buffer);
	(this.size || new _Vector2()).serialize_internal(buffer);
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
HTMLElement.prototype.deserialize_internal = function(buffer) {
	(this.position || (this.position = new _Vector2())).deserialize_internal(buffer);
	(this.size || (this.size = new _Vector2())).deserialize_internal(buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.color = _objectCache[index];
	} else {
		let color = this.color
		if(!color || color._objectIndex != -index)
			this.color = color = new _Color();
		(_objectCache[-index] = color).deserialize_internal(buffer);
	}
}
function HTMLElement_serialize_external(buffer) {
	buffer.writeString("elements");
	let _elements = HTMLElement.elements
	let _elements_startPos = buffer.reserveSize();
	if(_elements) {
		var index = _objectCacheIndex.get(_elements);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_elements, index = _objectCache.length);
			_objectCache.push(_elements);
			buffer.writeInt32(-index);
			_elements._objectIndex = index;
			buffer.writeInt32(_elements.length);
			for(let i=0, len=_elements.length; i<len; ++i) {
				let _elements_item = _elements[i]
				if(_elements_item) {
					var index = _objectCacheIndex.get(_elements_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_elements_item, index = _objectCache.length);
						_objectCache.push(_elements_item);
						buffer.writeInt32(-index);
						buffer.writeString(_elements_item.type);
						_elements_item._objectIndex = index;
						_elements_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_elements_startPos);
	buffer.writeString("");
}
function HTMLElement_deserialize_external(buffer) {
	let elements_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "elements":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					HTMLElement.elements = _objectCache[index];
				} else {
					let _elements = HTMLElement.elements
					if(!_elements || _elements._objectIndex != -index) HTMLElement.elements = _elements = [];
					_objectCache[-index] = _elements;
					for(let i=0, len = _elements.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_elements[i] = _objectCache[index];
							} else {
								let _elements_item = _elements[i]
								let type = buffer.readString();
								if(!_elements_item || _elements_item._objectIndex != -index)
									_elements[i] = _elements_item = new_HTMLElement_of_type(type);
								_elements_item.type = type;
								(_objectCache[-index] = _elements_item).deserialize_external(buffer);
							}
					}
				}
				elements_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!elements_is_set) HTMLElement.elements = [];
				return;
		}
	}
}
HTMLElement.prototype.serialize_external = function(buffer) {
	buffer.writeString("position");
	let position_startPos = buffer.reserveSize();
	(this.position || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(position_startPos);
	buffer.writeString("size");
	let size_startPos = buffer.reserveSize();
	(this.size || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(size_startPos);
	buffer.writeString("color");
	let color_startPos = buffer.reserveSize();
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(color_startPos);
	buffer.writeString("");
}
HTMLElement.prototype.deserialize_external = function(buffer) {
	let position_is_set = false, size_is_set = false, color_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "position":
				buffer.readInt32();
				(this.position || (this.position = new _Vector2())).deserialize_external(buffer);
				position_is_set = true;
				break;
			case "size":
				buffer.readInt32();
				(this.size || (this.size = new _Vector2())).deserialize_external(buffer);
				size_is_set = true;
				break;
			case "color":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.color = _objectCache[index];
				} else {
					let color = this.color
					if(!color || color._objectIndex != -index)
						this.color = color = new _Color();
					(_objectCache[-index] = color).deserialize_external(buffer);
				}
				color_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!position_is_set) this.position = new Vector2(0.0, 0.0, null);
				if(!size_is_set) this.size = new Vector2(1920, 100, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/browser.l", 4758, 4768, null, null));
				if(!color_is_set) this.color = null;
				return;
		}
	}
}
function IndexedDBIndex(name, keyPaths) {
	this.name = name;
	this.keyPaths = keyPaths;
	if(!(this.keyPaths != null && this.keyPaths.length != 0) ) {
		this.keyPaths.push(this.name);
	}
}
IndexedDBIndex.prototype.clone = function() {
	let clone = new _IndexedDBIndex();
	clone.name = this.name;
	clone.keyPaths = this.keyPaths;
	return clone;
}
function _IndexedDBIndex() {};
_IndexedDBIndex.prototype = IndexedDBIndex.prototype;
IndexedDBIndex.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.name);
	let keyPaths = this.keyPaths
	if(keyPaths) {
		var index = _objectCacheIndex.get(keyPaths);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(keyPaths, index = _objectCache.length);
			_objectCache.push(keyPaths);
			buffer.writeInt32(-index);
			keyPaths._objectIndex = index;
			buffer.writeInt32(keyPaths.length);
			for(let i=0, len=keyPaths.length; i<len; ++i) {
				buffer.writeString(keyPaths[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
IndexedDBIndex.prototype.deserialize_internal = function(buffer) {
	this.name = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.keyPaths = _objectCache[index];
	} else {
		let keyPaths = this.keyPaths
		if(!keyPaths || keyPaths._objectIndex != -index) this.keyPaths = keyPaths = [];
		_objectCache[-index] = keyPaths;
		for(let i=0, len = keyPaths.length = buffer.readInt32(); i<len; ++i) {
				keyPaths[i] = buffer.readString();
		}
	}
}
IndexedDBIndex.prototype.serialize_external = function(buffer) {
	buffer.writeString("name");
	buffer.writeString(this.name);
	buffer.writeString("keyPaths");
	let keyPaths = this.keyPaths
	let keyPaths_startPos = buffer.reserveSize();
	if(keyPaths) {
		var index = _objectCacheIndex.get(keyPaths);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(keyPaths, index = _objectCache.length);
			_objectCache.push(keyPaths);
			buffer.writeInt32(-index);
			keyPaths._objectIndex = index;
			buffer.writeInt32(keyPaths.length);
			for(let i=0, len=keyPaths.length; i<len; ++i) {
				buffer.writeString(keyPaths[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(keyPaths_startPos);
	buffer.writeString("");
}
IndexedDBIndex.prototype.deserialize_external = function(buffer) {
	let name_is_set = false, keyPaths_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "name":
				this.name = buffer.readString();
				name_is_set = true;
				break;
			case "keyPaths":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.keyPaths = _objectCache[index];
				} else {
					let keyPaths = this.keyPaths
					if(!keyPaths || keyPaths._objectIndex != -index) this.keyPaths = keyPaths = [];
					_objectCache[-index] = keyPaths;
					for(let i=0, len = keyPaths.length = buffer.readInt32(); i<len; ++i) {
							keyPaths[i] = buffer.readString();
					}
				}
				keyPaths_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!name_is_set) this.name = "";
				if(!keyPaths_is_set) this.keyPaths = [];
				return;
		}
	}
}
function IndexedDBStore(name, indices, keyPath, autoIncrement) {
	this.name = name;
	this.indices = indices;
	this.keyPath = keyPath;
	this.autoIncrement = autoIncrement;
	IndexedDB.stores.push(this);
	System.print(("Adding store "+this.name+" "+IndexedDB.stores.length?.toString()), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/browser.l", 7173, 7226, null, null));
}
IndexedDBStore.prototype.put = function(data, then, $else) {
	try {
		let trans = IndexedDB.db.transaction(this.name, "readwrite")
		trans.onerror = e => {
			core.log("Error in IndexedDB.save: "+trans.error)
			$else?.()
		}
		trans.objectStore(this.name).put(data).onsuccess = e => {
			then?.()
		}
	} catch(error) {
		core.onError(error)
		$else?.(error)
	}
}
IndexedDBStore.prototype.get = async function(id) {
	return new Promise((resolve, reject) => {
		try {
			let trans = IndexedDB.db.transaction(this.name, "readonly");
			let req = trans.objectStore(this.name).get(id);
			req.onsuccess = async e => resolve(req.result)
			req.onerror = e => { core.onError(e); reject(); }
		} catch(e) {
			core.onError(e);
			reject();
		}
	})
}
IndexedDBStore.prototype.get2 = function(id, then, $else) {
	try {
		let trans = IndexedDB.db.transaction(this.name, "readonly");
		let req = trans.objectStore(this.name).get(id);
		req.onsuccess = async e => {
			let result = req.result;
			if(result) {
				then(result);
			} else {
				$else?.();
			}
		}
		req.onerror = e => {
			core.onError(e);
			$else?.();
		}
	} catch(e) {
		core.onError(e);
		$else?.();
	}
}
IndexedDBStore.prototype.getAllFromIndex = async function(index, query) {
	return new Promise((resolve, reject) => {
		try {
			let trans = IndexedDB.db.transaction(this.name, "readonly");
			let req = trans.objectStore(this.name).index(index).getAll(query);
			req.onsuccess = async e => resolve(req.result)
			req.onerror = e => { core.onError(e); reject(); }
		} catch(e) {
			core.onError(e);
			reject();
		}
	})
}
IndexedDBStore.prototype.getAllFromIndex2 = function(index, query, then, $else) {
	try {
		let trans = IndexedDB.db.transaction(this.name, "readonly");
		let req = trans.objectStore(this.name).index(index).getAll(query);
		req.onsuccess = async e => {
			let result = req.result;
			if(result) {
				then(result);
			} else {
				$else?.();
			}
		}
		req.onerror = e => {
			core.onError(e);
			$else?.();
		}
	} catch(e) {
		core.onError(e);
		$else?.();
	}
}
IndexedDBStore.prototype.clone = function() {
	let clone = new _IndexedDBStore();
	clone.name = this.name;
	clone.indices = this.indices;
	clone.keyPath = this.keyPath;
	clone.autoIncrement = this.autoIncrement;
	return clone;
}
function _IndexedDBStore() {};
_IndexedDBStore.prototype = IndexedDBStore.prototype;
IndexedDBStore.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.name);
	let indices = this.indices
	if(indices) {
		var index = _objectCacheIndex.get(indices);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(indices, index = _objectCache.length);
			_objectCache.push(indices);
			buffer.writeInt32(-index);
			indices._objectIndex = index;
			buffer.writeInt32(indices.length);
			for(let i=0, len=indices.length; i<len; ++i) {
				let indices_item = indices[i]
				if(indices_item) {
					var index = _objectCacheIndex.get(indices_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(indices_item, index = _objectCache.length);
						_objectCache.push(indices_item);
						buffer.writeInt32(-index);
						indices_item._objectIndex = index;
						indices_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeString(this.keyPath);
	buffer.writeBool(this.autoIncrement);
}
IndexedDBStore.prototype.deserialize_internal = function(buffer) {
	this.name = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.indices = _objectCache[index];
	} else {
		let indices = this.indices
		if(!indices || indices._objectIndex != -index) this.indices = indices = [];
		_objectCache[-index] = indices;
		for(let i=0, len = indices.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					indices[i] = _objectCache[index];
				} else {
					let indices_item = indices[i]
					if(!indices_item || indices_item._objectIndex != -index)
						indices[i] = indices_item = new _IndexedDBIndex();
					(_objectCache[-index] = indices_item).deserialize_internal(buffer);
				}
		}
	}
	this.keyPath = buffer.readString();
	this.autoIncrement = buffer.readBool();
}
IndexedDBStore.prototype.serialize_external = function(buffer) {
	buffer.writeString("name");
	buffer.writeString(this.name);
	buffer.writeString("indices");
	let indices = this.indices
	let indices_startPos = buffer.reserveSize();
	if(indices) {
		var index = _objectCacheIndex.get(indices);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(indices, index = _objectCache.length);
			_objectCache.push(indices);
			buffer.writeInt32(-index);
			indices._objectIndex = index;
			buffer.writeInt32(indices.length);
			for(let i=0, len=indices.length; i<len; ++i) {
				let indices_item = indices[i]
				if(indices_item) {
					var index = _objectCacheIndex.get(indices_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(indices_item, index = _objectCache.length);
						_objectCache.push(indices_item);
						buffer.writeInt32(-index);
						indices_item._objectIndex = index;
						indices_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(indices_startPos);
	buffer.writeString("keyPath");
	buffer.writeString(this.keyPath);
	buffer.writeString("autoIncrement");
	buffer.writeInt32(1);
	buffer.writeBool(this.autoIncrement);
	buffer.writeString("");
}
IndexedDBStore.prototype.deserialize_external = function(buffer) {
	let name_is_set = false, indices_is_set = false, keyPath_is_set = false, autoIncrement_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "name":
				this.name = buffer.readString();
				name_is_set = true;
				break;
			case "indices":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.indices = _objectCache[index];
				} else {
					let indices = this.indices
					if(!indices || indices._objectIndex != -index) this.indices = indices = [];
					_objectCache[-index] = indices;
					for(let i=0, len = indices.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								indices[i] = _objectCache[index];
							} else {
								let indices_item = indices[i]
								if(!indices_item || indices_item._objectIndex != -index)
									indices[i] = indices_item = new _IndexedDBIndex();
								(_objectCache[-index] = indices_item).deserialize_external(buffer);
							}
					}
				}
				indices_is_set = true;
				break;
			case "keyPath":
				this.keyPath = buffer.readString();
				keyPath_is_set = true;
				break;
			case "autoIncrement":
				buffer.readInt32();
				this.autoIncrement = buffer.readBool();
				autoIncrement_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!name_is_set) this.name = "";
				if(!indices_is_set) this.indices = [];
				if(!keyPath_is_set) this.keyPath = "id";
				if(!autoIncrement_is_set) this.autoIncrement = false;
				return;
		}
	}
}
var IndexedDB; if(!IndexedDB) IndexedDB = {};
IndexedDB.init = function() {
	IndexedDB.db = null;
	IndexedDB.stores = [];
}
IndexedDB.start = async function(databaseName, version) {
	return new Promise((resolve, reject) => {
		try {
			System.print("IndexedDB: start stores:"+IndexedDB.stores.length);
			var request = indexedDB.open(databaseName, version)
			request.onupgradeneeded = e => {
				core.log("IndexedDB: upgradeneeded");
				IndexedDB.db = e.target.result;
				for(let store of IndexedDB.stores) {
					if(!IndexedDB.db.objectStoreNames.contains(store.name)) {
						let storeObject = IndexedDB.db.createObjectStore(store.name, { keyPath: store.keyPath, autoIncrement: store.autoIncrement });
						System.print("IndexedDB: created store "+store.name)
						for(let index of store.indices) {
							storeObject.createIndex(index.name, index.keyPaths.length == 1 ? index.keyPaths[0] : index.keyPaths)
						}
					}
				}
				System.print("IndexedDB: successfully upgraded to version "+version)
			}
			request.onsuccess = e => {
				System.print("IndexedDB: success");
				IndexedDB.db = e.target.result;
				for(let store of IndexedDB.stores) {
					store.db = IndexedDB.db
				}
				resolve();
			}
			request.onerror = e => {
				core.onError(request.error);
				reject(request.error);
			}
			core.log("IndexedDB: finished");
		} catch(e) {
			core.onError(e);
			reject(e);
		}
	})
}
IndexedDB.start2 = function(databaseName, version, success, $else) {
	try {
		System.print("IndexedDB: start stores:"+IndexedDB.stores.length);
		var request = indexedDB.open(databaseName, version)
		request.onupgradeneeded = e => {
			core.log("IndexedDB: upgradeneeded");
			IndexedDB.db = e.target.result;
			for(let store of IndexedDB.stores) {
				if(!IndexedDB.db.objectStoreNames.contains(store.name)) {
					let storeObject = IndexedDB.db.createObjectStore(store.name, { keyPath: store.keyPath, autoIncrement: store.autoIncrement });
					System.print("IndexedDB: created store "+store.name)
					for(let index of store.indices) {
						storeObject.createIndex(index.name, index.keyPaths)
					}
				}
			}
			System.print("IndexedDB: successfully upgraded to version "+version)
		}
		request.onsuccess = e => {
			System.print("IndexedDB: success");
			IndexedDB.db = e.target.result;
			for(let store of IndexedDB.stores) {
				store.db = IndexedDB.db
			}
			success?.();
		}
		request.onerror = e => {
			core.onError(request.error);
			$else?.(request.error);
		}
		core.log("IndexedDB: finished");
	} catch(e) {
		core.onError(e);
		$else?.(e);
	}
}
IndexedDB.open = function(storeName, id, then, $else) {
	try {
		let trans = IndexedDB.db.transaction(storeName, "readonly")
		let req = trans.objectStore(IndexedDB.storeName).get(id)
		req.onsuccess = async e => {
			let result = req.result
			if(result) {
				then(result)
			} else {
				$else?.()
			}
		}
		req.onerror = e => {
			core.log("Error in IndexedDB.open: "+req.error)
			$else?.()
		}
	} catch(e) {
		core.log("Error in IndexedDB.open: "+e.message)
		$else?.()
	}
}
IndexedDB.openBuffer = async function(storeName, id, then, $else) {
	try {
		let trans = IndexedDB.db.transaction(storeName, "readonly")
		let req = trans.objectStore(IndexedDB.storeName).get(id)
		req.onsuccess = async e => {
			let result = req.result
			if(result) {
				let arrayBuffer = await result.data.arrayBuffer()
				let buffer = new Buffer(arrayBuffer, 0, 0, 0)
				then(buffer)
			} else {
				$else?.()
			}
		}
		req.onerror = e => {
			core.log("Error in IndexedDB.open: "+req.error)
			$else?.()
		}
	} catch(e) {
		core.log("Error in IndexedDB.open: "+e.message)
		$else?.()
	}
}
IndexedDB.save = function(storeName, data, then, $else) {
	try {
		let trans = IndexedDB.db.transaction(storeName, "readwrite")
		trans.onerror = e => {
			core.log("Error in IndexedDB.save: "+trans.error)
			$else?.()
		}
		trans.objectStore(IndexedDB.storeName).put(data).onsuccess = e => {
			then?.()
		}
	} catch(e) {
		core.log("Error in IndexedDB.save: "+e.message)
		$else?.()
	}
}
IndexedDB.saveBuffer = function(storeName, id, buffer, then, $else) {
	try {
		let trans = IndexedDB.db.transaction(storeName, "readwrite")
		trans.onerror = e => {
			core.log("Error in IndexedDB.save: "+trans.error)
			$else?.()
		}
		let dataView = new DataView(buffer.buffer, 0, buffer.writePos)
		let data = new Blob([dataView])
		trans.objectStore(IndexedDB.storeName).put({id, data}).onsuccess = e => {
			then?.()
		}
	} catch(e) {
		core.log("Error in IndexedDB.save: "+e.message)
		$else?.()
	}
}
function RoomInfo(time, userId) {
	this.time = time;
	this.userId = userId;
}
RoomInfo.prototype.clone = function() {
	let clone = new _RoomInfo();
	clone.time = this.time;
	clone.userId = this.userId;
	return clone;
}
function _RoomInfo() {};
_RoomInfo.prototype = RoomInfo.prototype;
var core; if(!core) core = {};
core.targetFps = 30;
core.frameTime = 1000 / core.targetFps;
core.chunkSize = 256;
core.init = function() {
	core.eventStreamVersion = 2;
	core.sendInterval = 1;
	core.enabledMilestones = true;
	core.milestoneInterval = 1800;
	core.smoothStrength = 90;
	core.smoothTouchPosition = true;
	core.everybodyCanClickForEverybody = false;
	core.simulateConnection = true;
	core.simulateInputsForTesting = false;
	core.simulateRollback = false;
	core.drawPointsForTesting = false;
	core.sendStatisticsEvery = (2*60000);
	core.muteInvisibleUsers = false;
	core.testLobby = false;
	core.enableVideoForStaging = true;
	core.enableAudioForStaging = false;
	core.sendInputsMode = 1/*Peer*/;
	core.mode = 0/*None*/;
	core.errorMessage = "";
	core.startTime = 0.0;
	core.serverStartTime = 0.0;
	core.frame = 0;
	core.frames = 0;
	core.frameWithNewWatches = 0;
	core.watchIndex = 0;
	core.startInLobby = false;
	core.joinFrame = 0;
	core.isPremiere = false;
	core.account = null;
	core.checksums = [];
	core.lastChecksumFrame = 0;
	core.inputStore = new IndexedDBStore("input", [new IndexedDBIndex("roomId", [])], "id", false);
	core.roomStore = new IndexedDBStore("room", [], "id", false);
	core.lastPingTime = 0.0;
	core.animationStartFrame = 0;
	core.now = 0.0;
	core.prevLogTime = 0.0;
	core.logs = "";
	core.lastNetworkFrame = 0.0;
	core.lastAnimationFrame = 0.0;
	core.drawTime = 0.0;
	core.tickTime = 0.0;
	core.restoreTime = 0.0;
	core.replayTime = 0.0;
	core.saveTime = 0.0;
	core.displayItems = 0;
	core.tickMessageSize = 0;
	core.verbose = false;
	core.replayFrom = -1;
	core.drawTimes = new RollingList(30, 1);
	core.tickTimes = new RollingList(30, 1);
	core.frameTimes = new RollingList(150, 1);
	core.lastSendFrame = 0;
	core.snapshot = new Buffer(null, 1024, 0, 0);
	core.secondSnapshotForTesting = new Buffer(null, 1024, 0, 0);
	core.snapshotFrame = -1;
	core.nextSnapshotFrame = -1;
	core.milestones = [];
	core.serializeLogs = [];
	core.snapshotBuffer = new Buffer(null, 1024, 0, 0);
	core.eventStreamSnapshotBuffer = new Buffer(null, 1024, 0, 0);
	core.roomString = "";
	core.roomId = 0;
	core.gameId = "";
	core.localUserId = 0;
	core.snapshotLogWithWrongChecksum = "";
}
core.startConnected = function(frame) {
	if(core.mode == 3/*Connected*/) {
		return;
	}
	core.account = Platform.getLocalStorageObject("user") || new UserAccount("", 0/*English*/, "", "", "");
	if(!core.account._id) {
		core.account._id = core.generateObjectId();
		Platform.setLocalStorageObject("user", core.account, null, null);
	}
	core.log("startConnected"+", joinFrame: "+core.joinFrame?.toString()+", this.frame: "+core.frame?.toString()+", this.frames: "+core.frames?.toString());
	if(core.frames == 0) {
		core.log("handleJoin"+", frame: "+frame?.toString());
		input.localUser.startInputFrame(0);
		input.handleJoin(frame, core.account);
	}
	core.mode = 3/*Connected*/;
	input.localUser.collectInputs = true;
	core.snapshotFrame = -1;
	core.nextSnapshotFrame = 0;
	core.checkSaveState();
	core.log("Start"+", input.localUser.id: "+input.localUser.id?.toString()+", frame: "+frame?.toString()+", startTime: "+core.startTime.toString()+", serverStartTime: "+core.serverStartTime.toString());
}
core.generateObjectId = function() {
	const timestamp = Math.floor(new Date().getTime() / 1000).toString(16);
	const machineIdentifier = Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
	const processIdentifier = Math.floor(Math.random() * 0xFFFF).toString(16).padStart(4, '0');
	const counter = Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
	return (timestamp + machineIdentifier + processIdentifier + counter).toLowerCase();
}
core.startLocal = function() {
	core.mode = 2/*Local*/;
	input.internalUsers.length = 0;
	math.setRandomSeed(math.generateRandomSeed());
	core.stop();
}
core.stop = function() {
	for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if((it != null)) {
			it.inputs.reset();
			it.startInputFrame(0);
		}
	}}
	core.startTime = core.serverStartTime = Date.now();
	core.frames = 0;
	core.frameWithNewWatches = 0;
	core.watchIndex = 0;
	core.startInLobby = false;
	core.errorMessage = "";
	audio.stop();
	core.isPremiere = true;
	core.startTime = core.serverStartTime = Date.now();
	core.reset();
	core.animationFrame();
}
core.record = function() {
	core.frames = core.frameWithNewWatches = core.frame;
	for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if((it != null)) {
			it.inputs.writePos = it.inputs.readPos;
			it.startInputFrame(core.frame);
		}
	}}
	if(Platform.isDebug) {
		Platform.sendFrame(core.frame, core.frames);
	}
}
core.reset = function() {
	input.players.length = 0;
	input.playersById.length = 0;
	input.host = null;
	input.playersToRemove.length = 0;
	core.errorMessage = "";
	HTMLElement.clear();
	math.randomValueIndex = 0;
	core.frame = 0;
	core.watchIndex = 0;
	input.isCertain = true;
	lobby.inLobby = core.startInLobby;
	Time.now = core.serverStartTime;
	core.snapshotFrame = -1;
	core.checksums.length = 0;
	core.lastChecksumFrame = -1;
	audio.stop();
	core.initAll();
	if(!core.startInLobby || core.testLobby) {
		for(let i=0; i<Platform.userCount; ++i) {
			if(!(input.internalUsers[i] != null)) {
				input.internalUsers[i] = new InternalUser(i, true, 0, 0, "", "", true, -1, 0, [], new Buffer(null, 1024, 0, 0), 0, null, [], null, 0, null, [], "", false, false, false, 0, "", Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, 0, 0);
			}
		}
		if(input.internalUsers.length > Platform.userCount) {
			input.internalUsers.splice(Platform.userCount, input.internalUsers.length-Platform.userCount);
		}
		for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let internalUser = _subject[i]; {
			let user = new Player("", 0/*English*/, "", "", [], internalUser.id, i, null, null, 0, new Vector2(0.0, 0.0, null), false);
			input.playersById[internalUser.id] = user;
			input.players.push(user);
		}}
		let localUserId = (input.localUser?.id < input.internalUsers.length ? input.localUser.id : 0);
		input.localUser = input.internalUsers[localUserId];
		input.localPlayer = input.playersById[localUserId];
		input.updatePlayers();
		core.account = new UserAccount("", 0/*English*/, "", "", "");
	}
	for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if((it != null)) {
			it.inputs.readPos = 0;
		}
	}}
	if(!core.startInLobby && !core.testLobby) {
		core.startApp();
	}
	if(core.simulateRollback) {
		core.checkSaveState();
	}
}
core.restart = function() {
	if(!input.isCertain) {
		return;
	}
	let hostPlayerId = ((input.host != null) ? input.host.id : -1);
	Framework.clear(true);
	Platform.fastForward = false;
	let prevLanguage = Loca.language;
	core.initAll();
	Loca.setLanguage(prevLanguage, null);
	let newPlayers = [];
	for(let i=0, _subject=input.players, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let user = it.cloneBaseData();
		input.playersById[it.id] = user;
		newPlayers.push(user);
	}}
	input.players = newPlayers;
	let localUserId = (input.localUser?.id < input.internalUsers.length ? input.localUser.id : 0);
	input.localUser = input.internalUsers[localUserId];
	input.localPlayer = input.playersById[localUserId];
	input.host = (hostPlayerId != -1 ? input.playersById[hostPlayerId] : null);
	input.updatePlayers();
	core.startApp();
}
core.goToFrame = function(targetFrame, replayFromStart) {
	core.isPremiere = false;
	if(replayFromStart) {
		core.frameWithNewWatches = 0;
		core.reset();
	} else {
		if(targetFrame < core.frame) {
			let milestoneIndex = (core.enabledMilestones ? Math.floor(targetFrame / core.milestoneInterval) - 1 : -1);
			if(0 <= milestoneIndex && milestoneIndex < core.milestones.length) {
				let milestone = core.milestones[milestoneIndex];
				core.frame = (milestoneIndex + 1) * core.milestoneInterval;
				core.rewind(milestone);
			} else {
				core.reset();
			}
		}
	}
	core.replay(core.frame, targetFrame);
	core.adjustStartTime();
	core.animationFrame();
	core.isPremiere = true;
}
core.smooth = function(player, $do) {
	let user = input.internalUsers[player.id];
	if((user != null) && (user.local || core.frame <= user.smoothFrame)) {
		$do();
	}
}
core.animationFrame = function() {
	core.now = Date.now();
	if(core.lastAnimationFrame) {
		core.frameTimes.add(core.now - core.lastAnimationFrame);
	}
	ServerNetwork.tick();
	PeerNetwork.tick();
	statistics.tick();
	if(core.mode == 0/*None*/ || core.mode == 1/*Ping*/) {
		return;
	}
	let targetFrame = Math.floor((core.now - core.startTime) / core.frameTime) + 1;
	if(core.verbose) {
		core.log(("----- #"+core.frame?.toString()+" -> #"+targetFrame?.toString()+" -----"));
	}
	if(core.mode == 2/*Local*/ && targetFrame > core.frame + core.targetFps * 2) {
		let prevTargetFrame = targetFrame;
		targetFrame = core.frame;
		core.startTime = Math.round(core.now - targetFrame * core.frameTime);
		core.log(("Paused "+(prevTargetFrame - core.frame)?.toString()+" frames, adjusting startTime. prevTargetTime:"+prevTargetFrame?.toString()+" frame:"+core.frame?.toString()+" targetFrame:"+Math.floor((core.now - core.startTime) / core.frameTime)?.toString()));
	}
	if(core.frame < targetFrame) {
		if(core.simulateInputsForTesting && (input.localUser != null) && input.localUser.collectInputs) {
			for(let i=core.frame; i<targetFrame; ++i) {
				input.handleKeyEvent(5/*KeyDown*/, 135/*F24*/, "");
			}
		}
		core.animationStartFrame = core.frame;
		try {
			core.sendInputs(targetFrame - 1);
			core.checkRewindAndReplayState();
		} catch(error) {
			core.onError(error);
		}
		while(core.frame < targetFrame) {
			if(Platform.mode == 4/*Record*/) {
				for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let user = _subject[i]; {
					if(user?.local) {
						user.startInputFrame(core.frame + 1);
					}
				}}
			}
			core.step(false, core.frame == targetFrame - 1);
			core.collectStatistics();
			core.lastNetworkFrame = core.now;
		}
		if((IndexedDB.db != null)) {
			core.storeInputsToDB(input.localUser);
			core.storeRoomToDB();
		}
	}
	core.lastAnimationFrame = core.now;
	if(Platform.mode == 3/*Play*/ && core.frame >= core.frames) {
		Platform.record();
	}
	if(Date.now() - core.lastPingTime > 1000) {
		core.lastPingTime = Date.now();
		PeerNetwork.ping();
	}
}
core.log = function(text) {
	if(Time.now > core.prevLog + 3000) core.logs += "\n"
	core.prevLog = Time.now
	
	let str = new Date().hourMinuteSecondMillisecondString() + " " + text
	statistics.systemLogs.push(str)
	console.log(str)
	core.logs += str + "\n"
}
core.collectStatistics = function() {
	if(core.mode == 3/*Connected*/ && input.players.length > 1 && core.frame > core.joinFrame + 120) {
		for(let i=0, _subject=input.players, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			let internalUser = input.internalUsers[it.id];
			if(!internalUser.local) {
				internalUser.collectStatistics(core.frame);
				statistics.add("input", it.index, core.frame - internalUser.inputFrame, it.color, 0, true);
				statistics.add("smooth", it.index, core.frame - internalUser.smoothFrame, it.color, 1, true);
				statistics.add("delta", it.index, internalUser.certainFrame - internalUser.prevCertainFrame, it.color, 2, true);
			}
		}}
		if(core.replayFrom != -1) {
			statistics.add("replay", -1, core.frame - core.replayFrom, Color.Gray, 0, true);
		}
	} else {
		if(core.mode == 2/*Local*/ && core.simulateRollback) {
			for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
				it.simulateRollback(core.frame);
			}}
		}
	}
	statistics.add("memory", -1, (performance.memory ? performance.memory.usedJSHeapSize : 0), Color.Yellow, 4, true);
	statistics.add("snapshotSize", -1, core.snapshot.writePos, Color.Red, 5, true);
	statistics.add("inputs", -1, input.localUser?.inputs.writePos, Color.Blue, 6, true);
	statistics.add("drawTime", -1, core.drawTime, Color.Blue, 7, true);
	statistics.add("tickTime", -1, core.tickTime, Color.Red, 7, true);
	statistics.add("restoreTime", -1, core.restoreTime, Color.Green, 7, true);
	statistics.add("replayTime", -1, core.replayTime, Color.Yellow, 7, true);
	statistics.add("saveTime", -1, core.saveTime, Color.White, 7, true);
}
core.connectionStates = function() {
	let result = "";
	for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(!it.local) {
			if(result) {
				result += ", ";
			}
			result += it.connectionState;
		}
	}}
	return result;
}
core.sendInputs = function(inputFrame) {
	if(core.mode != 3/*Connected*/) {
		return;
	}
	if(core.frame >= core.lastSendFrame + core.sendInterval) {
		if(core.sendInputsMode == 1/*Peer*/) {
			PeerNetwork.sendInputs(inputFrame);
		}
		if(core.sendInputsMode == 2/*Server*/) {
			ServerNetwork.sendInputs(inputFrame);
		}
		core.lastSendFrame = core.frame;
	}
}
core.switchToPlayer = function(player) {
	if(!(player != null)) {
		return;
	}
	let prevPlayer = input.localPlayer;
	input.localPlayer = player;
	input.localUser = input.internalUsers.find(a => (a != null) && a.id == player.id);
	for(let i=0, _subject=prevPlayer.touches, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		input.handleUpdateTouchAfterSwitchingUser(it.id, it.referencePosition);
	}}
}
core.switchSendInterval = function(sendInterval) {
	core.sendInterval = sendInterval;
	ServerNetwork.sendSwitch(core.sendInputsMode, sendInterval);
}
core.switchSendInputMode = function(sendInputsMode) {
	core.sendInputsMode = sendInputsMode;
	ServerNetwork.sendSwitch(sendInputsMode, core.sendInterval);
}
core.step = function(fastForward, draw) {
	try {
		if(core.verbose) {
			core.log(("#"+core.frame?.toString()+((fastForward ? " fastForward" : ""))+((draw ? " draw" : ""))));
		}
		Time.now = (core.serverStartTime + Math.round(core.frame * core.frameTime));
		Platform.fastForward = fastForward;
		let certainFrame = input.internalUsers.min3(a => Math.min(a.inputFrame, a.smoothFrame), int.maxValue, 0, a => a != null);
		input.isCertain = core.frame <= certainFrame;
		if(Platform.isDebug && !fastForward) {
			Platform.sendFrame(core.frame, Math.max(core.frame + 1, core.frames));
		}
		core.checkSaveState();
		input.updateGameControllers();
		input.parseInputs(core.frame);
		Physics.step();
		core.tick(draw);
		if((HTMLElement.elements != null && HTMLElement.elements.length != 0) ) {
			for(let i=0, _subject=HTMLElement.elements, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
				it.tick();
			}}
		}
		input.removePlayersIfNecessary();
	} catch(error) {
		core.onError(error);
	}
	for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if((it != null)) {
			it.clearEvent();
		}
	}}
	for(let i=0, _subject=input.players, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		it.postprocessEvents();
	}}
	core.frame++;
	if(core.frames < core.frame) {
		core.frames = core.frame;
	}
	if(core.frame > core.frameWithNewWatches) {
		core.frameWithNewWatches = core.frame;
	}
}
core.tick = function(draw) {
	Platform.isDrawing = draw;
	graphics.startFrame();
	if(draw && !Platform.waitingForInitialData) {
		if(input.showPointers || Platform.mode == 3/*Play*/) {
			for(let i=0, _subject=input.players, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
				graphics.drawPointer(it, (Platform.mode == 3/*Play*/ ? input.showPointersDuringPlaybackMode : input.showPointersMode), null);
			}}
		}
	}
	audio.startFrame();
	if(Platform.showDebugInfo) {
		if(draw) {
			statistics.tickGraph();
		}
		networkVisualizer.tick();
	}
	try {
		Framework.tick();
		core.tickTimes.add(core.tickTime = Time.measure(() => {
			if(lobby.inLobby) {
				lobby.tick();
			} else {
				if(awardScreen.active) {
					awardScreen.tick();
				} else {
					core.appTick();
				}
			}
		}));
	} catch(error) {
		core.onError(error);
	}
	if(draw && !Platform.waitingForInitialData) {
		core.drawTimes.add(core.drawTime = Time.measure(() => {
			graphics.finishFrame();
		}));
		if(Platform.mode != 1/*Manipulator*/) {
			input.updateCursor();
		}
	}
	audio.finishFrame();
}
core.appTick = function() {
	if(app.tick) app.tick();
}
core.appDebugString = function() {
	(app.debugString || "")
}
core.checkRewindAndReplayState = function() {
	if((core.mode != 3/*Connected*/ && !core.simulateRollback) || input.internalUsers.length == 1) {
		return;
	}
	if(core.mode == 2/*Local*/ && core.simulateRollback) {
		core.nextSnapshotFrame = core.frame - 5;
	} else {
		core.nextSnapshotFrame = (input.internalUsers.min3(a => Math.min(a.smoothFrame, a.inputFrame), int.maxValue, 0, a => (a != null) && !a.local)) + 1;
	}
	if(core.snapshotFrame != -1) {
		if(core.verbose) {
			core.log("rewindAndReplayState"+", snapshotFrame: "+core.snapshotFrame?.toString()+", frame: "+core.frame?.toString()+", nextSnapshotFrame: "+core.nextSnapshotFrame?.toString());
			for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
				core.log(("\t<"+it.id?.toString()+">")+", .smoothFrame: "+it.smoothFrame?.toString()+", .inputFrame: "+it.inputFrame?.toString()+", .local: "+it.local);
			}}
		}
		let prevSnapshotFrame = core.snapshotFrame;
		core.snapshotFrame = -1;
		core.rewind(core.snapshot);
		core.replay(prevSnapshotFrame, core.frame);
	}
}
core.rewind = function(snapshot) {
	core.restoreTime = Time.measure(() => {
		snapshot.rewind();
		deserialize_internal(snapshot);
		let userCount = snapshot.readInt();
		for(let i=0; i<userCount; ++i) {
			let user = input.internalUsers[i];
			user.inputs.readPos = snapshot.readInt();
		}
	});
}
core.replay = function(from, to) {
	core.replayTime = Time.measure(() => {
		core.frame = core.replayFrom = from;
		while(core.frame < to) {
			core.step(true, false);
		}
	});
}
core.checkSaveState = function() {
	if(core.enabledMilestones && input.isCertain && core.frame > 0 && (((core.frame % core.milestoneInterval) + core.milestoneInterval) % core.milestoneInterval) == 0) {
		let buffer = new Buffer(null, 1024, 0, 0);
		core.saveState(buffer);
		let milestoneIndex = Math.floor(core.frame / core.milestoneInterval) - 1;
		core.milestones[milestoneIndex] = buffer;
		System.watch(("Milestone "+milestoneIndex?.toString()), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/core.l", 18285, 18319, null, null));
	}
	if((core.mode == 3/*Connected*/ || core.simulateRollback) && core.snapshotFrame == -1 && core.frame >= core.nextSnapshotFrame) {
		core.snapshotFrame = core.frame;
		core.saveState(core.snapshot);
	}
}
core.saveState = function(snapshot) {
	snapshot.reset();
	core.saveTime = Time.measure(() => {
		serialize_internal(snapshot);
		if(Platform.logSerialize) {
			core.serializeLogs[(((core.frame % 100) + 100) % 100)] = _serializeLog;
		}
	});
	if(core.simulateRollback) {
		deserialize_internal(snapshot);
		serialize_internal(core.secondSnapshotForTesting);
		if(snapshot.notEqual(core.secondSnapshotForTesting)) {
			core.onError(new Error("Inconsistent serialization", ""));
		}
	}
	snapshot.writeInt(input.internalUsers.length);
	for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		snapshot.writeInt(it.inputs.readPos);
	}}
	if(input.players.length >= 2 && input.isCertain) {
		let myChecksum = snapshot.checksum();
		let theirChecksum = core.checksums[core.frame];
		if(core.verbose) {
			core.log(("<"+input.localUser.id?.toString()+"*> #"+core.frame?.toString()+" "+myChecksum.toString()+" writePos:"+snapshot.writePos?.toString()));
		}
		if(!theirChecksum) {
			core.checksums[core.frame] = myChecksum;
		} else {
			if(!(Math.abs(theirChecksum - myChecksum) < 0.00001)) {
				core.onWrongChecksum(core.frame, myChecksum, theirChecksum);
			}
		}
		core.lastChecksumFrame = core.frame;
	}
}
core.startApp = function() {
	lobby.inLobby = false
	if(app.start) app.start()
}
core.adjustStartTime = function() {
	core.startTime = Math.round(Date.now() - core.frame * core.frameTime - (core.frameTime * .5));
}
core.adjustStartTimeIfNeeded = function() {
	if(Platform.mode < 3/*Play*/) {
		core.adjustStartTime();
	}
}
core.saveEventStreamAndLogs = function() {
	if(input.isCertain) {
		core.saveEventStream();
		setTimeout(() => {
			core.saveLogs();
		}, (1*1000));
	}
}
core.saveLogs = function() {
	file.saveText(""+input.localUser.id?.toString()+" "+_appName+" "+new Date().invariantDayMonthYearHourMinuteSecondString(Loca.language)+" v"+_buildVersion?.toString()+".csv", core.logs);
}
core.saveEventStream = function() {
	let buffer = new Buffer(null, 1024, 0, 0);
	buffer.writeInt(core.eventStreamVersion);
	core.eventStreamSnapshotBuffer.reset();
	serialize_internal(core.eventStreamSnapshotBuffer);
	buffer.writeBuffer(core.eventStreamSnapshotBuffer);
	buffer.writeInt(core.frame - 1);
	buffer.writeInt(core.frames);
	buffer.writeString(math.randomSeed);
	buffer.writeBool(core.startInLobby);
	buffer.writeBool(Platform.isStaging);
	let userCount = input.internalUsers.count(a => a != null);
	buffer.writeInt8(userCount);
	for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if((it != null)) {
			buffer.writeInt(it.id);
			buffer.writeBool(it.local);
			buffer.writeBuffer(it.inputs);
		}
	}}
	buffer.writeInt(core.milestones.length);
	for(let i=0, _subject=core.milestones, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		buffer.writeBuffer(it);
	}}
	let date = new Date();
	file.saveBinary(""+_appName+" "+date.dayShortMonthNameYearString(Loca.language)+" "+date.hourMinuteSecondString(Loca.language)+" v"+_buildVersion?.toString()+".state", buffer);
}
core.storeRoomToDB = function() {
	core.roomStore.put(({id:core.roomId, frame:core.frame, frames:core.frames, eventStreamVersion:core.eventStreamVersion, randomSeed:math.randomSeed, startInLobby:core.startInLobby, isStaging:Platform.isStaging, localUserId:input.localUser.id}), null, null);
}
core.storeInputsToDB = function(user) {
	let inputs = user.inputs;
	if(inputs.writePos > user.storedInputsUpTo) {
		let start = inputs.writePos - ((((inputs.writePos % core.chunkSize) + core.chunkSize) % core.chunkSize));
		let id = ""+core.roomId?.toString()+"-"+user.id?.toString()+"-"+start?.toString();
		System.print(("["+core.frame?.toString()+"] <"+user.id?.toString()+"> Storing inputs "+id+" ("+start?.toString()+" to "+inputs.writePos?.toString()+")"), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/core.l", 21667, 21747, null, null));
		core.inputStore.put(({id:id, roomId:core.roomId, userId:user.id, start:start, inputs:inputs.buffer.slice(start, inputs.writePos)}), () => {
			System.print(("["+core.frame?.toString()+"] <"+user.id?.toString()+"> Storing inputs successful"), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/core.l", 21862, 21917, null, null));
		}, error => {
			System.print(("["+core.frame?.toString()+"] <"+user.id?.toString()+"> Storing inputs failed"), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/core.l", 21930, 21981, null, null));
		});
		user.storedInputsUpTo = inputs.writePos;
	}
}
core.openFromDB = async function() {
	await IndexedDB.start((Platform.isStaging ? "up4playing-"+core.localUserId?.toString() : "up4playing"), 2);
	let room = await core.roomStore.get(core.roomId);
	let targetFrame = room.frame - 1;
	core.frames = room.frames;
	let randomSeed = room.randomSeed;
	core.startInLobby = room.startInLobby;
	Platform.isStaging = room.isStaging;
	core.localUserId = room.localUserId;
	System.print(("#database opening from db "+JSON.stringify(room)), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/core.l", 22386, 22440, null, null));
	let result = await core.inputStore.getAllFromIndex("roomId", core.roomId);
	result.orderBy(a => a.start);
	for(let i=0, _subject=result, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let userId = it.userId;
		let start = it.start;
		let inputs = it.inputs;
		let user = (input.internalUsers.hasOwnProperty(it.userId) ? input.internalUsers[it.userId] : input.internalUsers[it.userId] = new InternalUser(it.userId, it.userId == core.localUserId, 0, 0, "", "", true, -1, 0, [], new Buffer(null, 1024, 0, 0), 0, null, [], null, 0, null, [], "", false, false, false, 0, "", Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, 0, 0));
		if(user.local) {
			input.localUser = user;
		}
		user.inputs.insertArrayBuffer(it.inputs);
		System.print("#database"+", userId: "+userId?.toString()+", start: "+start?.toString()+", inputs.toString(): "+inputs.toString(), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/core.l", 22809, 22860, null, null));
	}}
	System.print("#database"+", input.localUser.inputs.toString: "+input.localUser.inputs.toString(), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/core.l", 22863, 22913, null, null));
	for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if((it != null)) {
			it.startInputFrame(core.frames);
		}
	}}
	math.setRandomSeed(randomSeed);
	core.replay(0, targetFrame);
}
core.openState = function() {
	file.openBinary(buffer => {
		let version = buffer.readInt();
		let finalSnapshot = new Buffer(null, 1024, 0, 0);
		buffer.readBuffer(finalSnapshot, 0);
		input.handleSetState(finalSnapshot);
	}, null);
}
core.openEventStream = function() {
	Platform.pause();
	file.openBinary(buffer => {
		let version = buffer.readInt();
		if(version >= 2) {
			let finalSnapshot = new Buffer(null, 1024, 0, 0);
			buffer.readBuffer(finalSnapshot, 0);
		}
		let targetFrame = buffer.readInt();
		core.frames = buffer.readInt();
		let randomSeed = buffer.readString();
		core.startInLobby = buffer.readBool();
		Platform.isStaging = buffer.readBool();
		let userCount = buffer.readInt8();
		input.internalUsers.length = 0;
		for(let i=0; i<userCount; ++i) {
			let user = new InternalUser(buffer.readInt(), buffer.readBool(), 0, 0, "", "", false, -1, 0, [], new Buffer(null, 1024, 0, 0), 0, null, [], null, 0, null, [], "", false, false, false, 0, "", Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, 0, 0);
			if(user.local) {
				input.localUser = user;
			}
			buffer.readBuffer(user.inputs, 0);
			input.internalUsers[user.id] = user;
		}
		if(version >= 2) {
			core.milestones.length = 0;
			let milestoneCount = buffer.readInt();
			for(let i=0; i<milestoneCount; ++i) {
				let milestone = new Buffer(null, 1024, 0, 0);
				buffer.readBuffer(milestone, 0);
				core.milestones.push(milestone);
			}
		}
		for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			if((it != null)) {
				it.collectInputs = true;
				if(Platform.isDebug) {
					it.local = true;
				}
				it.startInputFrame(core.frames);
			}
		}}
		math.setRandomSeed(randomSeed);
		if(Platform.isDebug) {
			Platform.sendClearTimeline();
		}
		core.frame = int.maxValue;
		core.goToFrame(targetFrame, false);
		if(Platform.isDebug) {
			Platform.sendFrame(targetFrame, core.frames);
		}
	}, null);
}
core.join = async function(gameId, roomString, userId) {
	statistics.scheduleSendIn((30*1000));
	core.isPremiere = true;
	core.initAll();
	core.log((""+location.href));
	core.log((""+new Date().dayMonthYearHourMinuteSecondString(Loca.language)+" v"+_buildVersion?.toString()));
	core.log((""+navigator.userAgent.replace(/,/g," ")?.toString()));
	core.startInLobby = true;
	core.gameId = gameId;
	core.roomString = roomString;
	core.roomId = parseInt(roomString);
	core.localUserId = userId;
	core.frame = 0;
	core.frames = 0;
	try {
		await core.openFromDB();
	} catch(error) {
		input.localUser = new InternalUser(core.localUserId, true, 0, 0, "", "", false, -1, 0, [], new Buffer(null, 1024, 0, 0), 0, null, [], null, 0, null, [], "", false, false, true, 0, "", Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, 0, 0);
	}
	await PeerNetwork.setupLocalMedia(!Platform.isStaging || core.enableVideoForStaging, !Platform.isStaging || core.enableAudioForStaging);
	ServerNetwork.setup();
	lobby.enableFullscreen = !Platform.isStaging;
}
core.initAll = function() {
	init()
	graphics.updateBaseMatrix();
}
core.storeUserId = function() {
	Platform.setLocalStorageObject("room" + core.roomId?.toString(), new RoomInfo(Date.now(), input.localUser.id), null, null);
}
core.onWrongChecksum = function(frame, mine, theirs) {
	let message = " Out of sync. frame:"+frame?.toString()+" mine:"+mine.toString()+" theirs:"+theirs.toString();
	let serializeLog = core.serializeLogs[(((frame % 100) + 100) % 100)];
	core.log("message: "+message);
	if(!core.snapshotLogWithWrongChecksum) {
		core.snapshotLogWithWrongChecksum = "frame:"+frame?.toString()+" mine:"+mine.toString()+" theirs:"+theirs.toString()+"\n"+serializeLog;
		core.log(("\n"+serializeLog));
	}
	core.onError(new Error(message, ""));
}
core.onError = function(error) {
	core.errorMessage = error.stack;
	core.log((""+core.errorMessage));
	if(window._sendErrorToEditor) _sendErrorToEditor(error)
	else console.error(error);
}
var Snapshot; if(!Snapshot) Snapshot = {};
Snapshot.init = function() {
	Snapshot.autoSaveCount = 0;
	Snapshot.lastSnapshotSize = 0;
	Snapshot.snapshots = new Buffer(null, 1024, 0, 0);
	Snapshot.snapshotStarts = [];
	Snapshot.snapshotEvery = 100;
	Snapshot.autoSaveAtEndOfStep = false;
}
Snapshot.toString = function(value) {
	let buffer = new Buffer(null, 1024, 0, 0);
	setup_serialize();
	value.serialize_external(buffer);
	return btoa(String.fromCharCode(...new Uint8Array(buffer.buffer, 0, buffer.writePos))); 
}
Snapshot.fromString = function(value, base64String) {
	let bytes = Uint8Array.from(atob(base64String), c => c.charCodeAt(0))
	let buffer = new Buffer(bytes.buffer,0,0,0);
	setup_deserialize();
	value.deserialize_external(buffer);
}
Snapshot.fromBase64 = function(value, base64String) {
	let bytes = Uint8Array.from(atob(base64String), c => c.charCodeAt(0))
	let buffer = new Buffer(bytes.buffer,0,0,0);
	setup_deserialize();
	value.deserialize_internal(buffer);
}
Snapshot.save = function() {
	let buffer = new Buffer(null, 1024, 0, 0);
	serialize_internal(buffer);
	return buffer;
}
Snapshot.restore = function(buffer) {
	deserialize_internal(buffer);
}
Snapshot.autoSave = function() {
	Snapshot.autoSaveAtEndOfStep = true;
}
function StatisticsGraph(userIndex, set, label, values, color, recentValues, valuesToSend, sendingUntil, successfullySentUntil) {
	this.userIndex = userIndex;
	this.set = set;
	this.label = label;
	this.values = values;
	this.color = color;
	this.recentValues = recentValues;
	this.valuesToSend = valuesToSend;
	this.sendingUntil = sendingUntil;
	this.successfullySentUntil = successfullySentUntil;
}
StatisticsGraph.prototype.lastValue = function() {
	return (this.values.length > 0 ? this.values[this.values.length - 1] : 0);
}
StatisticsGraph.prototype.add = function(value) {
	this.recentValues.push(value);
	if(this.recentValues.length >= statistics.framesPerValue) {
		this.values.push(this.recentValues.max2(a => a, -Number.MAX_VALUE, 0));
		this.recentValues.length = 0;
	}
}
StatisticsGraph.prototype.addDirectly = function(value) {
	this.values.push(value);
}
StatisticsGraph.prototype.clone = function() {
	let clone = new _StatisticsGraph();
	clone.userIndex = this.userIndex;
	clone.set = this.set;
	clone.label = this.label;
	clone.values = this.values;
	clone.color = this.color;
	clone.recentValues = this.recentValues;
	clone.valuesToSend = this.valuesToSend;
	clone.sendingUntil = this.sendingUntil;
	clone.successfullySentUntil = this.successfullySentUntil;
	return clone;
}
function _StatisticsGraph() {};
_StatisticsGraph.prototype = StatisticsGraph.prototype;
StatisticsGraph.prototype.serialize_internal = function(buffer) {
	buffer.writeInt32(this.userIndex);
	buffer.writeInt32(this.set);
	buffer.writeString(this.label);
	let values = this.values
	if(values) {
		var index = _objectCacheIndex.get(values);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(values, index = _objectCache.length);
			_objectCache.push(values);
			buffer.writeInt32(-index);
			values._objectIndex = index;
			buffer.writeInt32(values.length);
			for(let i=0, len=values.length; i<len; ++i) {
				buffer.writeFloat64(values[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let recentValues = this.recentValues
	if(recentValues) {
		var index = _objectCacheIndex.get(recentValues);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(recentValues, index = _objectCache.length);
			_objectCache.push(recentValues);
			buffer.writeInt32(-index);
			recentValues._objectIndex = index;
			buffer.writeInt32(recentValues.length);
			for(let i=0, len=recentValues.length; i<len; ++i) {
				buffer.writeFloat64(recentValues[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let valuesToSend = this.valuesToSend
	if(valuesToSend) {
		var index = _objectCacheIndex.get(valuesToSend);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(valuesToSend, index = _objectCache.length);
			_objectCache.push(valuesToSend);
			buffer.writeInt32(-index);
			valuesToSend._objectIndex = index;
			buffer.writeInt32(valuesToSend.length);
			for(let i=0, len=valuesToSend.length; i<len; ++i) {
				buffer.writeFloat64(valuesToSend[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.sendingUntil);
	buffer.writeInt32(this.successfullySentUntil);
}
StatisticsGraph.prototype.deserialize_internal = function(buffer) {
	this.userIndex = buffer.readInt32();
	this.set = buffer.readInt32();
	this.label = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.values = _objectCache[index];
	} else {
		let values = this.values
		if(!values || values._objectIndex != -index) this.values = values = [];
		_objectCache[-index] = values;
		for(let i=0, len = values.length = buffer.readInt32(); i<len; ++i) {
				values[i] = buffer.readFloat64();
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.color = _objectCache[index];
	} else {
		let color = this.color
		if(!color || color._objectIndex != -index)
			this.color = color = new _Color();
		(_objectCache[-index] = color).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.recentValues = _objectCache[index];
	} else {
		let recentValues = this.recentValues
		if(!recentValues || recentValues._objectIndex != -index) this.recentValues = recentValues = [];
		_objectCache[-index] = recentValues;
		for(let i=0, len = recentValues.length = buffer.readInt32(); i<len; ++i) {
				recentValues[i] = buffer.readFloat64();
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.valuesToSend = _objectCache[index];
	} else {
		let valuesToSend = this.valuesToSend
		if(!valuesToSend || valuesToSend._objectIndex != -index) this.valuesToSend = valuesToSend = [];
		_objectCache[-index] = valuesToSend;
		for(let i=0, len = valuesToSend.length = buffer.readInt32(); i<len; ++i) {
				valuesToSend[i] = buffer.readFloat64();
		}
	}
	this.sendingUntil = buffer.readInt32();
	this.successfullySentUntil = buffer.readInt32();
}
StatisticsGraph.prototype.serialize_external = function(buffer) {
	buffer.writeString("userIndex");
	buffer.writeInt32(4);
	buffer.writeInt32(this.userIndex);
	buffer.writeString("set");
	buffer.writeInt32(4);
	buffer.writeInt32(this.set);
	buffer.writeString("label");
	buffer.writeString(this.label);
	buffer.writeString("values");
	let values = this.values
	let values_startPos = buffer.reserveSize();
	if(values) {
		var index = _objectCacheIndex.get(values);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(values, index = _objectCache.length);
			_objectCache.push(values);
			buffer.writeInt32(-index);
			values._objectIndex = index;
			buffer.writeInt32(values.length);
			for(let i=0, len=values.length; i<len; ++i) {
				buffer.writeFloat64(values[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(values_startPos);
	buffer.writeString("color");
	let color_startPos = buffer.reserveSize();
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(color_startPos);
	buffer.writeString("recentValues");
	let recentValues = this.recentValues
	let recentValues_startPos = buffer.reserveSize();
	if(recentValues) {
		var index = _objectCacheIndex.get(recentValues);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(recentValues, index = _objectCache.length);
			_objectCache.push(recentValues);
			buffer.writeInt32(-index);
			recentValues._objectIndex = index;
			buffer.writeInt32(recentValues.length);
			for(let i=0, len=recentValues.length; i<len; ++i) {
				buffer.writeFloat64(recentValues[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(recentValues_startPos);
	buffer.writeString("valuesToSend");
	let valuesToSend = this.valuesToSend
	let valuesToSend_startPos = buffer.reserveSize();
	if(valuesToSend) {
		var index = _objectCacheIndex.get(valuesToSend);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(valuesToSend, index = _objectCache.length);
			_objectCache.push(valuesToSend);
			buffer.writeInt32(-index);
			valuesToSend._objectIndex = index;
			buffer.writeInt32(valuesToSend.length);
			for(let i=0, len=valuesToSend.length; i<len; ++i) {
				buffer.writeFloat64(valuesToSend[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(valuesToSend_startPos);
	buffer.writeString("sendingUntil");
	buffer.writeInt32(4);
	buffer.writeInt32(this.sendingUntil);
	buffer.writeString("successfullySentUntil");
	buffer.writeInt32(4);
	buffer.writeInt32(this.successfullySentUntil);
	buffer.writeString("");
}
StatisticsGraph.prototype.deserialize_external = function(buffer) {
	let userIndex_is_set = false, set_is_set = false, label_is_set = false, values_is_set = false, color_is_set = false, recentValues_is_set = false, valuesToSend_is_set = false, sendingUntil_is_set = false, successfullySentUntil_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "userIndex":
				buffer.readInt32();
				this.userIndex = buffer.readInt32();
				userIndex_is_set = true;
				break;
			case "set":
				buffer.readInt32();
				this.set = buffer.readInt32();
				set_is_set = true;
				break;
			case "label":
				this.label = buffer.readString();
				label_is_set = true;
				break;
			case "values":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.values = _objectCache[index];
				} else {
					let values = this.values
					if(!values || values._objectIndex != -index) this.values = values = [];
					_objectCache[-index] = values;
					for(let i=0, len = values.length = buffer.readInt32(); i<len; ++i) {
							values[i] = buffer.readFloat64();
					}
				}
				values_is_set = true;
				break;
			case "color":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.color = _objectCache[index];
				} else {
					let color = this.color
					if(!color || color._objectIndex != -index)
						this.color = color = new _Color();
					(_objectCache[-index] = color).deserialize_external(buffer);
				}
				color_is_set = true;
				break;
			case "recentValues":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.recentValues = _objectCache[index];
				} else {
					let recentValues = this.recentValues
					if(!recentValues || recentValues._objectIndex != -index) this.recentValues = recentValues = [];
					_objectCache[-index] = recentValues;
					for(let i=0, len = recentValues.length = buffer.readInt32(); i<len; ++i) {
							recentValues[i] = buffer.readFloat64();
					}
				}
				recentValues_is_set = true;
				break;
			case "valuesToSend":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.valuesToSend = _objectCache[index];
				} else {
					let valuesToSend = this.valuesToSend
					if(!valuesToSend || valuesToSend._objectIndex != -index) this.valuesToSend = valuesToSend = [];
					_objectCache[-index] = valuesToSend;
					for(let i=0, len = valuesToSend.length = buffer.readInt32(); i<len; ++i) {
							valuesToSend[i] = buffer.readFloat64();
					}
				}
				valuesToSend_is_set = true;
				break;
			case "sendingUntil":
				buffer.readInt32();
				this.sendingUntil = buffer.readInt32();
				sendingUntil_is_set = true;
				break;
			case "successfullySentUntil":
				buffer.readInt32();
				this.successfullySentUntil = buffer.readInt32();
				successfullySentUntil_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!userIndex_is_set) this.userIndex = -1;
				if(!set_is_set) this.set = 0;
				if(!label_is_set) this.label = null;
				if(!values_is_set) this.values = [];
				if(!color_is_set) this.color = null;
				if(!recentValues_is_set) this.recentValues = [];
				if(!valuesToSend_is_set) this.valuesToSend = [];
				if(!sendingUntil_is_set) this.sendingUntil = 0;
				if(!successfullySentUntil_is_set) this.successfullySentUntil = 0;
				return;
		}
	}
}
function StatisticsInfo(value, index, frame) {
	this.value = value;
	this.index = index;
	this.frame = frame;
}
StatisticsInfo.prototype.clone = function() {
	let clone = new _StatisticsInfo();
	clone.value = this.value;
	clone.index = this.index;
	clone.frame = this.frame;
	return clone;
}
function _StatisticsInfo() {};
_StatisticsInfo.prototype = StatisticsInfo.prototype;
StatisticsInfo.prototype.serialize_internal = function(buffer) {
	buffer.writeFloat64(this.value);
	buffer.writeInt32(this.index);
	buffer.writeInt32(this.frame);
}
StatisticsInfo.prototype.deserialize_internal = function(buffer) {
	this.value = buffer.readFloat64();
	this.index = buffer.readInt32();
	this.frame = buffer.readInt32();
}
StatisticsInfo.prototype.serialize_external = function(buffer) {
	buffer.writeString("value");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.value);
	buffer.writeString("index");
	buffer.writeInt32(4);
	buffer.writeInt32(this.index);
	buffer.writeString("frame");
	buffer.writeInt32(4);
	buffer.writeInt32(this.frame);
	buffer.writeString("");
}
StatisticsInfo.prototype.deserialize_external = function(buffer) {
	let value_is_set = false, index_is_set = false, frame_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "value":
				buffer.readInt32();
				this.value = buffer.readFloat64();
				value_is_set = true;
				break;
			case "index":
				buffer.readInt32();
				this.index = buffer.readInt32();
				index_is_set = true;
				break;
			case "frame":
				buffer.readInt32();
				this.frame = buffer.readInt32();
				frame_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!value_is_set) this.value = 0.0;
				if(!index_is_set) this.index = 0;
				if(!frame_is_set) this.frame = 0;
				return;
		}
	}
}
function AStarNode(pos, combinedCost, travelCostSoFar, distanceToTarget, cost, visited, exploredAllNeighbors, previousNode) {
	this.pos = pos?.clone();
	this.combinedCost = combinedCost;
	this.travelCostSoFar = travelCostSoFar;
	this.distanceToTarget = distanceToTarget;
	this.cost = cost;
	this.visited = visited;
	this.exploredAllNeighbors = exploredAllNeighbors;
	this.previousNode = previousNode;
}
AStarNode.prototype.clone = function() {
	let clone = new _AStarNode();
	clone.pos = this.pos.clone();
	clone.combinedCost = this.combinedCost;
	clone.travelCostSoFar = this.travelCostSoFar;
	clone.distanceToTarget = this.distanceToTarget;
	clone.cost = this.cost;
	clone.visited = this.visited;
	clone.exploredAllNeighbors = this.exploredAllNeighbors;
	clone.previousNode = this.previousNode;
	return clone;
}
function _AStarNode() {};
_AStarNode.prototype = AStarNode.prototype;
AStarNode.prototype.serialize_internal = function(buffer) {
	(this.pos || new _IntVector2()).serialize_internal(buffer);
	buffer.writeInt32(this.combinedCost);
	buffer.writeInt32(this.travelCostSoFar);
	buffer.writeInt32(this.distanceToTarget);
	buffer.writeInt32(this.cost);
	buffer.writeBool(this.visited);
	buffer.writeBool(this.exploredAllNeighbors);
	let previousNode = this.previousNode
	if(previousNode) {
		var index = _objectCacheIndex.get(previousNode);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(previousNode, index = _objectCache.length);
			_objectCache.push(previousNode);
			buffer.writeInt32(-index);
			previousNode._objectIndex = index;
			previousNode.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
AStarNode.prototype.deserialize_internal = function(buffer) {
	(this.pos || (this.pos = new _IntVector2())).deserialize_internal(buffer);
	this.combinedCost = buffer.readInt32();
	this.travelCostSoFar = buffer.readInt32();
	this.distanceToTarget = buffer.readInt32();
	this.cost = buffer.readInt32();
	this.visited = buffer.readBool();
	this.exploredAllNeighbors = buffer.readBool();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.previousNode = _objectCache[index];
	} else {
		let previousNode = this.previousNode
		if(!previousNode || previousNode._objectIndex != -index)
			this.previousNode = previousNode = new _AStarNode();
		(_objectCache[-index] = previousNode).deserialize_internal(buffer);
	}
}
AStarNode.prototype.serialize_external = function(buffer) {
	buffer.writeString("pos");
	let pos_startPos = buffer.reserveSize();
	(this.pos || new _IntVector2()).serialize_external(buffer);
	buffer.writeSize(pos_startPos);
	buffer.writeString("combinedCost");
	buffer.writeInt32(4);
	buffer.writeInt32(this.combinedCost);
	buffer.writeString("travelCostSoFar");
	buffer.writeInt32(4);
	buffer.writeInt32(this.travelCostSoFar);
	buffer.writeString("distanceToTarget");
	buffer.writeInt32(4);
	buffer.writeInt32(this.distanceToTarget);
	buffer.writeString("cost");
	buffer.writeInt32(4);
	buffer.writeInt32(this.cost);
	buffer.writeString("visited");
	buffer.writeInt32(1);
	buffer.writeBool(this.visited);
	buffer.writeString("exploredAllNeighbors");
	buffer.writeInt32(1);
	buffer.writeBool(this.exploredAllNeighbors);
	buffer.writeString("previousNode");
	let previousNode_startPos = buffer.reserveSize();
	let previousNode = this.previousNode
	if(previousNode) {
		var index = _objectCacheIndex.get(previousNode);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(previousNode, index = _objectCache.length);
			_objectCache.push(previousNode);
			buffer.writeInt32(-index);
			previousNode._objectIndex = index;
			previousNode.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(previousNode_startPos);
	buffer.writeString("");
}
AStarNode.prototype.deserialize_external = function(buffer) {
	let pos_is_set = false, combinedCost_is_set = false, travelCostSoFar_is_set = false, distanceToTarget_is_set = false, cost_is_set = false, visited_is_set = false, exploredAllNeighbors_is_set = false, previousNode_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "pos":
				buffer.readInt32();
				(this.pos || (this.pos = new _IntVector2())).deserialize_external(buffer);
				pos_is_set = true;
				break;
			case "combinedCost":
				buffer.readInt32();
				this.combinedCost = buffer.readInt32();
				combinedCost_is_set = true;
				break;
			case "travelCostSoFar":
				buffer.readInt32();
				this.travelCostSoFar = buffer.readInt32();
				travelCostSoFar_is_set = true;
				break;
			case "distanceToTarget":
				buffer.readInt32();
				this.distanceToTarget = buffer.readInt32();
				distanceToTarget_is_set = true;
				break;
			case "cost":
				buffer.readInt32();
				this.cost = buffer.readInt32();
				cost_is_set = true;
				break;
			case "visited":
				buffer.readInt32();
				this.visited = buffer.readBool();
				visited_is_set = true;
				break;
			case "exploredAllNeighbors":
				buffer.readInt32();
				this.exploredAllNeighbors = buffer.readBool();
				exploredAllNeighbors_is_set = true;
				break;
			case "previousNode":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.previousNode = _objectCache[index];
				} else {
					let previousNode = this.previousNode
					if(!previousNode || previousNode._objectIndex != -index)
						this.previousNode = previousNode = new _AStarNode();
					(_objectCache[-index] = previousNode).deserialize_external(buffer);
				}
				previousNode_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!pos_is_set) this.pos = new IntVector2(0, 0, null);
				if(!combinedCost_is_set) this.combinedCost = 0;
				if(!travelCostSoFar_is_set) this.travelCostSoFar = 0;
				if(!distanceToTarget_is_set) this.distanceToTarget = 0;
				if(!cost_is_set) this.cost = 1;
				if(!visited_is_set) this.visited = false;
				if(!exploredAllNeighbors_is_set) this.exploredAllNeighbors = false;
				if(!previousNode_is_set) this.previousNode = null;
				return;
		}
	}
}
function BinaryHeap(content) {
	this.content = content;
}
BinaryHeap.prototype.push = function(element) {
	this.content.push(element);
	this.sinkDown(this.content.length - 1);
}
BinaryHeap.prototype.pop = function() {
	let result = this.content[0];
	let end = this.content.pop();
	if(this.content.length > 0) {
		this.content[0] = end;
		this.bubbleUp(0);
	}
	return result;
}
BinaryHeap.prototype.remove = function(node) {
	let i = this.content.indexOf(node);
	let end = this.content.pop();
	if(i != this.content.length - 1) {
		this.content[i] = end;
		if(end.combinedCost < node.combinedCost) {
			this.sinkDown(i);
		} else {
			this.bubbleUp(i);
		}
	}
}
BinaryHeap.prototype.size = function() {
	return this.content.length;
}
BinaryHeap.prototype.rescoreElement = function(node) {
	this.sinkDown(this.content.indexOf(node));
}
BinaryHeap.prototype.sinkDown = function(number) {
	let n = number;
	let element = this.content[n];
	while((n > 0)) {
		let parentN = (((n + 1) >> 1)) - 1;
		let parent = this.content[parentN];
		if(element.combinedCost < parent.combinedCost) {
			this.content[parentN] = element;
			this.content[n] = parent;
			n = parentN;
		} else {
			break;
		}
	}
}
BinaryHeap.prototype.bubbleUp = function(number) {
	let n = number;
	let length = this.content.length, element = this.content[n], elemScore = element.combinedCost;
	while(true) {
		let child2N = ((n + 1) << 1);
		let child1N = child2N - 1;
		let swap = -1;
		let child1Score = 0;
		if(child1N < length) {
			let child1 = this.content[child1N];
			child1Score = child1.combinedCost;
			if(child1Score < elemScore) {
				swap = child1N;
			}
		}
		if(child2N < length) {
			let child2 = this.content[child2N];
			let child2Score = child2.combinedCost;
			if(child2Score < ((swap == -1 ? elemScore : child1Score))) {
				swap = child2N;
			}
		}
		if(swap != -1) {
			this.content[n] = this.content[swap];
			this.content[swap] = element;
			n = swap;
		} else {
			break;
		}
	}
}
BinaryHeap.prototype.clone = function() {
	let clone = new _BinaryHeap();
	clone.content = this.content;
	return clone;
}
function _BinaryHeap() {};
_BinaryHeap.prototype = BinaryHeap.prototype;
BinaryHeap.prototype.serialize_internal = function(buffer) {
	let content = this.content
	if(content) {
		var index = _objectCacheIndex.get(content);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(content, index = _objectCache.length);
			_objectCache.push(content);
			buffer.writeInt32(-index);
			content._objectIndex = index;
			buffer.writeInt32(content.length);
			for(let i=0, len=content.length; i<len; ++i) {
				let content_item = content[i]
				if(content_item) {
					var index = _objectCacheIndex.get(content_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(content_item, index = _objectCache.length);
						_objectCache.push(content_item);
						buffer.writeInt32(-index);
						content_item._objectIndex = index;
						content_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
BinaryHeap.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this.content = _objectCache[index];
	} else {
		let content = this.content
		if(!content || content._objectIndex != -index) this.content = content = [];
		_objectCache[-index] = content;
		for(let i=0, len = content.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					content[i] = _objectCache[index];
				} else {
					let content_item = content[i]
					if(!content_item || content_item._objectIndex != -index)
						content[i] = content_item = new _AStarNode();
					(_objectCache[-index] = content_item).deserialize_internal(buffer);
				}
		}
	}
}
BinaryHeap.prototype.serialize_external = function(buffer) {
	buffer.writeString("content");
	let content = this.content
	let content_startPos = buffer.reserveSize();
	if(content) {
		var index = _objectCacheIndex.get(content);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(content, index = _objectCache.length);
			_objectCache.push(content);
			buffer.writeInt32(-index);
			content._objectIndex = index;
			buffer.writeInt32(content.length);
			for(let i=0, len=content.length; i<len; ++i) {
				let content_item = content[i]
				if(content_item) {
					var index = _objectCacheIndex.get(content_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(content_item, index = _objectCache.length);
						_objectCache.push(content_item);
						buffer.writeInt32(-index);
						content_item._objectIndex = index;
						content_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(content_startPos);
	buffer.writeString("");
}
BinaryHeap.prototype.deserialize_external = function(buffer) {
	let content_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "content":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.content = _objectCache[index];
				} else {
					let content = this.content
					if(!content || content._objectIndex != -index) this.content = content = [];
					_objectCache[-index] = content;
					for(let i=0, len = content.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								content[i] = _objectCache[index];
							} else {
								let content_item = content[i]
								if(!content_item || content_item._objectIndex != -index)
									content[i] = content_item = new _AStarNode();
								(_objectCache[-index] = content_item).deserialize_external(buffer);
							}
					}
				}
				content_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!content_is_set) this.content = [];
				return;
		}
	}
}
function BoxCollider(position, size, radius, right, bottom, left, top, rightLine, bottomLine, leftLine, topLine, bottomRight, bottomLeft, topLeft, topRight) {
	this.position = position?.clone();
	this.size = size?.clone();
	this.rightLine = rightLine;
	this.bottomLine = bottomLine;
	this.leftLine = leftLine;
	this.topLine = topLine;
	this.bottomRight = bottomRight;
	this.bottomLeft = bottomLeft;
	this.topLeft = topLeft;
	this.topRight = topRight;
	if(left) {
		this.leftLine = new Line(position.plus(new Vector2(-(size.x / 2 + radius), -(size.y / 2 + ((this.topLeft ? radius : 0))), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 3339, 3398, null, null))), position.plus(new Vector2(-(size.x / 2 + radius), (size.y / 2 + ((this.bottomLeft ? radius : 0))), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 3420, 3479, null, null))), 2/*Segment*/);
	}
	if(right) {
		this.rightLine = new Line(position.plus(new Vector2((size.x / 2 + radius), -(size.y / 2 + ((this.topRight ? radius : 0))), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 3546, 3605, null, null))), position.plus(new Vector2((size.x / 2 + radius), (size.y / 2 + ((this.bottomRight ? radius : 0))), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 3627, 3686, null, null))), 2/*Segment*/);
	}
	if(top) {
		this.topLine = new Line(position.plus(new Vector2(-(size.x / 2 + ((this.topLeft ? radius : 0))), -(size.y / 2 + radius), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 3749, 3806, null, null))), position.plus(new Vector2((size.x / 2 + ((this.topRight ? radius : 0))), -(size.y / 2 + radius), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 3828, 3885, null, null))), 2/*Segment*/);
	}
	if(bottom) {
		this.bottomLine = new Line(position.plus(new Vector2(-(size.x / 2 + ((this.bottomLeft ? radius : 0))), (size.y / 2 + radius), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 3954, 4013, null, null))), position.plus(new Vector2((size.x / 2 + ((this.bottomRight ? radius : 0))), (size.y / 2 + radius), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 4035, 4094, null, null))), 2/*Segment*/);
	}
}
BoxCollider.prototype.clone = function() {
	let clone = new _BoxCollider();
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.rightLine = this.rightLine;
	clone.bottomLine = this.bottomLine;
	clone.leftLine = this.leftLine;
	clone.topLine = this.topLine;
	clone.bottomRight = this.bottomRight;
	clone.bottomLeft = this.bottomLeft;
	clone.topLeft = this.topLeft;
	clone.topRight = this.topRight;
	return clone;
}
function _BoxCollider() {};
_BoxCollider.prototype = BoxCollider.prototype;
BoxCollider.prototype.serialize_internal = function(buffer) {
	(this.position || new _Vector2()).serialize_internal(buffer);
	(this.size || new _Vector2()).serialize_internal(buffer);
	let rightLine = this.rightLine
	if(rightLine) {
		var index = _objectCacheIndex.get(rightLine);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(rightLine, index = _objectCache.length);
			_objectCache.push(rightLine);
			buffer.writeInt32(-index);
			rightLine._objectIndex = index;
			rightLine.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let bottomLine = this.bottomLine
	if(bottomLine) {
		var index = _objectCacheIndex.get(bottomLine);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(bottomLine, index = _objectCache.length);
			_objectCache.push(bottomLine);
			buffer.writeInt32(-index);
			bottomLine._objectIndex = index;
			bottomLine.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let leftLine = this.leftLine
	if(leftLine) {
		var index = _objectCacheIndex.get(leftLine);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(leftLine, index = _objectCache.length);
			_objectCache.push(leftLine);
			buffer.writeInt32(-index);
			leftLine._objectIndex = index;
			leftLine.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let topLine = this.topLine
	if(topLine) {
		var index = _objectCacheIndex.get(topLine);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(topLine, index = _objectCache.length);
			_objectCache.push(topLine);
			buffer.writeInt32(-index);
			topLine._objectIndex = index;
			topLine.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeBool(this.bottomRight);
	buffer.writeBool(this.bottomLeft);
	buffer.writeBool(this.topLeft);
	buffer.writeBool(this.topRight);
}
BoxCollider.prototype.deserialize_internal = function(buffer) {
	(this.position || (this.position = new _Vector2())).deserialize_internal(buffer);
	(this.size || (this.size = new _Vector2())).deserialize_internal(buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.rightLine = _objectCache[index];
	} else {
		let rightLine = this.rightLine
		if(!rightLine || rightLine._objectIndex != -index)
			this.rightLine = rightLine = new _Line();
		(_objectCache[-index] = rightLine).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.bottomLine = _objectCache[index];
	} else {
		let bottomLine = this.bottomLine
		if(!bottomLine || bottomLine._objectIndex != -index)
			this.bottomLine = bottomLine = new _Line();
		(_objectCache[-index] = bottomLine).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.leftLine = _objectCache[index];
	} else {
		let leftLine = this.leftLine
		if(!leftLine || leftLine._objectIndex != -index)
			this.leftLine = leftLine = new _Line();
		(_objectCache[-index] = leftLine).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.topLine = _objectCache[index];
	} else {
		let topLine = this.topLine
		if(!topLine || topLine._objectIndex != -index)
			this.topLine = topLine = new _Line();
		(_objectCache[-index] = topLine).deserialize_internal(buffer);
	}
	this.bottomRight = buffer.readBool();
	this.bottomLeft = buffer.readBool();
	this.topLeft = buffer.readBool();
	this.topRight = buffer.readBool();
}
BoxCollider.prototype.serialize_external = function(buffer) {
	buffer.writeString("position");
	let position_startPos = buffer.reserveSize();
	(this.position || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(position_startPos);
	buffer.writeString("size");
	let size_startPos = buffer.reserveSize();
	(this.size || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(size_startPos);
	buffer.writeString("rightLine");
	let rightLine_startPos = buffer.reserveSize();
	let rightLine = this.rightLine
	if(rightLine) {
		var index = _objectCacheIndex.get(rightLine);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(rightLine, index = _objectCache.length);
			_objectCache.push(rightLine);
			buffer.writeInt32(-index);
			rightLine._objectIndex = index;
			rightLine.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(rightLine_startPos);
	buffer.writeString("bottomLine");
	let bottomLine_startPos = buffer.reserveSize();
	let bottomLine = this.bottomLine
	if(bottomLine) {
		var index = _objectCacheIndex.get(bottomLine);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(bottomLine, index = _objectCache.length);
			_objectCache.push(bottomLine);
			buffer.writeInt32(-index);
			bottomLine._objectIndex = index;
			bottomLine.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(bottomLine_startPos);
	buffer.writeString("leftLine");
	let leftLine_startPos = buffer.reserveSize();
	let leftLine = this.leftLine
	if(leftLine) {
		var index = _objectCacheIndex.get(leftLine);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(leftLine, index = _objectCache.length);
			_objectCache.push(leftLine);
			buffer.writeInt32(-index);
			leftLine._objectIndex = index;
			leftLine.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(leftLine_startPos);
	buffer.writeString("topLine");
	let topLine_startPos = buffer.reserveSize();
	let topLine = this.topLine
	if(topLine) {
		var index = _objectCacheIndex.get(topLine);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(topLine, index = _objectCache.length);
			_objectCache.push(topLine);
			buffer.writeInt32(-index);
			topLine._objectIndex = index;
			topLine.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(topLine_startPos);
	buffer.writeString("bottomRight");
	buffer.writeInt32(1);
	buffer.writeBool(this.bottomRight);
	buffer.writeString("bottomLeft");
	buffer.writeInt32(1);
	buffer.writeBool(this.bottomLeft);
	buffer.writeString("topLeft");
	buffer.writeInt32(1);
	buffer.writeBool(this.topLeft);
	buffer.writeString("topRight");
	buffer.writeInt32(1);
	buffer.writeBool(this.topRight);
	buffer.writeString("");
}
BoxCollider.prototype.deserialize_external = function(buffer) {
	let position_is_set = false, size_is_set = false, rightLine_is_set = false, bottomLine_is_set = false, leftLine_is_set = false, topLine_is_set = false, bottomRight_is_set = false, bottomLeft_is_set = false, topLeft_is_set = false, topRight_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "position":
				buffer.readInt32();
				(this.position || (this.position = new _Vector2())).deserialize_external(buffer);
				position_is_set = true;
				break;
			case "size":
				buffer.readInt32();
				(this.size || (this.size = new _Vector2())).deserialize_external(buffer);
				size_is_set = true;
				break;
			case "rightLine":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.rightLine = _objectCache[index];
				} else {
					let rightLine = this.rightLine
					if(!rightLine || rightLine._objectIndex != -index)
						this.rightLine = rightLine = new _Line();
					(_objectCache[-index] = rightLine).deserialize_external(buffer);
				}
				rightLine_is_set = true;
				break;
			case "bottomLine":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.bottomLine = _objectCache[index];
				} else {
					let bottomLine = this.bottomLine
					if(!bottomLine || bottomLine._objectIndex != -index)
						this.bottomLine = bottomLine = new _Line();
					(_objectCache[-index] = bottomLine).deserialize_external(buffer);
				}
				bottomLine_is_set = true;
				break;
			case "leftLine":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.leftLine = _objectCache[index];
				} else {
					let leftLine = this.leftLine
					if(!leftLine || leftLine._objectIndex != -index)
						this.leftLine = leftLine = new _Line();
					(_objectCache[-index] = leftLine).deserialize_external(buffer);
				}
				leftLine_is_set = true;
				break;
			case "topLine":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.topLine = _objectCache[index];
				} else {
					let topLine = this.topLine
					if(!topLine || topLine._objectIndex != -index)
						this.topLine = topLine = new _Line();
					(_objectCache[-index] = topLine).deserialize_external(buffer);
				}
				topLine_is_set = true;
				break;
			case "bottomRight":
				buffer.readInt32();
				this.bottomRight = buffer.readBool();
				bottomRight_is_set = true;
				break;
			case "bottomLeft":
				buffer.readInt32();
				this.bottomLeft = buffer.readBool();
				bottomLeft_is_set = true;
				break;
			case "topLeft":
				buffer.readInt32();
				this.topLeft = buffer.readBool();
				topLeft_is_set = true;
				break;
			case "topRight":
				buffer.readInt32();
				this.topRight = buffer.readBool();
				topRight_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!position_is_set) this.position = new Vector2(0.0, 0.0, null);
				if(!size_is_set) this.size = new Vector2(0.0, 0.0, null);
				if(!rightLine_is_set) this.rightLine = null;
				if(!bottomLine_is_set) this.bottomLine = null;
				if(!leftLine_is_set) this.leftLine = null;
				if(!topLine_is_set) this.topLine = null;
				if(!bottomRight_is_set) this.bottomRight = true;
				if(!bottomLeft_is_set) this.bottomLeft = true;
				if(!topLeft_is_set) this.topLeft = true;
				if(!topRight_is_set) this.topRight = true;
				return;
		}
	}
}
var algorithms; if(!algorithms) algorithms = {};
algorithms.init = function() {
	algorithms.showColliders = false;
	algorithms.log = false;
}
algorithms.findPath = function(startPos, endPos, size, getNeighbors, heuristic) {
	let grid = [];
	for(let i=0; i<size.x; ++i) { let x = i; {
		grid[x] = [];
		for(let i=0; i<size.y; ++i) { let y = i; {
			grid[x][y] = new AStarNode(new IntVector2(x, y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 4563, 4568, null, null)), 0, 0, 0, 1, false, false, null);
		}}
	}}
	let diagonal = false;
	let start = grid[startPos.x][startPos.y];
	let end = grid[endPos.x][endPos.y];
	let openHeap = new BinaryHeap([]);
	openHeap.push(start);
	while(openHeap.size() > 0) {
		let currentNode = openHeap.pop();
		if(currentNode == end) {
			let curr = currentNode;
			let result = [];
			while((curr.previousNode != null)) {
				result.push(curr);
				curr = curr.previousNode;
			}
			result.push(curr);
			return result.reverse();
		}
		currentNode.exploredAllNeighbors = true;
		let neighbors = getNeighbors(grid, currentNode.pos.x, currentNode.pos.y);
		for(let i=0; i<neighbors.length; ++i) {
			let neighbor = neighbors[i];
			if(neighbor.exploredAllNeighbors) {
				continue;
			}
			let travelCostUpToThisNeighbor = currentNode.travelCostSoFar + neighbor.cost;
			let beenVisited = neighbor.visited;
			if(!beenVisited || travelCostUpToThisNeighbor < neighbor.travelCostSoFar) {
				neighbor.visited = true;
				neighbor.previousNode = currentNode;
				neighbor.distanceToTarget = neighbor.distanceToTarget || heuristic(neighbor.pos, end.pos);
				neighbor.travelCostSoFar = travelCostUpToThisNeighbor;
				neighbor.combinedCost = neighbor.travelCostSoFar + neighbor.distanceToTarget;
				if(!beenVisited) {
					openHeap.push(neighbor);
				} else {
					openHeap.rescoreElement(neighbor);
				}
			}
		}
	}
	return [];
}
algorithms.resolveCollision = function(sourcePosition, targetPosition, colliders, radius, slideThreshold) {
	let threshold = radius + slideThreshold;
	let primarilyX = Math.abs(targetPosition.x - sourcePosition.x) > Math.abs(targetPosition.y - sourcePosition.y);
	let movement = new Line(sourcePosition, targetPosition, 2/*Segment*/);
	let hasCollided = false;
	for(let i=0, _subject=colliders, _len=_subject.length; i<_len; ++i) { let c = _subject[i]; {
		if((c.leftLine != null) && movement.end.x > movement.start.x) {
			let line = c.leftLine;
			let p = movement.intersectionWith(line);
			if(p?.toBool()) {
				hasCollided = true;
				if(c.topLeft && (p.y - line.start.y) <= threshold) {
					if(algorithms.log) {
						System.watch("Move Right, Hit TopLeft Corner", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 7961, 7999, null, null));
					}
					if(primarilyX) {
						targetPosition.y = Math.min(targetPosition.y, line.start.y - 1);
					} else {
						targetPosition.x = Math.min(targetPosition.x, line.start.x - 1);
					}
				} else {
					if(c.bottomLeft && (line.end.y - p.y) <= threshold) {
						if(algorithms.log) {
							System.watch("Move Right, Hit BottomLeft Corner", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 8524, 8565, null, null));
						}
						if(primarilyX) {
							targetPosition.y = Math.max(targetPosition.y, line.end.y + 1);
						} else {
							targetPosition.x = Math.min(targetPosition.x, line.end.x - 1);
						}
					} else {
						if(algorithms.log) {
							System.watch("Move Right, Hit Left Side", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 9033, 9066, null, null));
						}
						targetPosition.x = Math.min(targetPosition.x, line.end.x - 1);
					}
				}
			}
		} else {
			if((c.rightLine != null) && movement.end.x < movement.start.x) {
				let line = c.rightLine;
				let p = movement.intersectionWith(line);
				if(p?.toBool()) {
					hasCollided = true;
					if(c.topRight && (p.y - line.start.y) <= threshold) {
						if(algorithms.log) {
							System.watch("Move Left, Hit TopRight Corner", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 9531, 9569, null, null));
						}
						if(primarilyX) {
							targetPosition.y = Math.min(targetPosition.y, line.start.y - 1);
						} else {
							targetPosition.x = Math.max(targetPosition.x, line.start.x + 1);
						}
					} else {
						if(c.bottomRight && (line.end.y - p.y) <= threshold) {
							if(algorithms.log) {
								System.watch("Move Left, Hit BottomRight Corner", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 10200, 10241, null, null));
							}
							if(primarilyX) {
								targetPosition.y = Math.max(targetPosition.y, line.end.y + 1);
							} else {
								targetPosition.x = Math.max(targetPosition.x, line.end.x + 1);
							}
						} else {
							if(algorithms.log) {
								System.watch("Move Left, Hit Right Side", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 10811, 10844, null, null));
							}
							targetPosition.x = Math.max(targetPosition.x, line.end.x + 1);
						}
					}
				}
			}
		}
		if((c.topLine != null) && movement.end.y > movement.start.y) {
			let line = c.topLine;
			let p = movement.intersectionWith(line);
			if(p?.toBool()) {
				hasCollided = true;
				if(c.topLeft && (p.x - line.start.x) <= threshold) {
					if(algorithms.log) {
						System.watch("Move Down, Hit TopLeft Corner", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 11317, 11354, null, null));
					}
					if(primarilyX) {
						targetPosition.y = Math.min(targetPosition.y, line.start.y - 1);
					} else {
						targetPosition.x = Math.min(targetPosition.x, line.start.x - 1);
					}
				} else {
					if(c.topRight && (line.end.x - p.x) <= threshold) {
						if(algorithms.log) {
							System.watch("Move Down, Hit TopRight Corner", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 11877, 11915, null, null));
						}
						if(primarilyX) {
							targetPosition.y = Math.min(targetPosition.y, line.end.y - 1);
						} else {
							targetPosition.x = Math.max(targetPosition.x, line.end.x + 1);
						}
					} else {
						if(algorithms.log) {
							System.watch("Move Down, Hit Top Side", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 12484, 12515, null, null));
						}
						targetPosition.y = Math.min(targetPosition.y, line.end.y - 1);
					}
				}
			}
		} else {
			if((c.bottomLine != null) && movement.end.y < movement.start.y) {
				let line = c.bottomLine;
				let p = movement.intersectionWith(line);
				if(p?.toBool()) {
					hasCollided = true;
					if(c.bottomLeft && (p.x - line.start.x) <= threshold) {
						if(algorithms.log) {
							System.watch("Move Up, Hit BottomLeft Corner", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 13082, 13120, null, null));
						}
						if(primarilyX) {
							targetPosition.y = Math.max(targetPosition.y, line.start.y + 1);
						} else {
							targetPosition.x = Math.min(targetPosition.x, line.start.x - 1);
						}
					} else {
						if(c.bottomRight && (line.end.x - p.x) <= threshold) {
							if(algorithms.log) {
								System.watch("Move Up, Hit BottomRight Corner", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 13650, 13689, null, null));
							}
							if(primarilyX) {
								targetPosition.y = Math.max(targetPosition.y, line.end.y + 1);
							} else {
								targetPosition.x = Math.max(targetPosition.x, line.end.x + 1);
							}
						} else {
							if(algorithms.log) {
								System.watch("Move Up, Hit Bottom Side", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 14259, 14291, null, null));
							}
							targetPosition.y = Math.max(targetPosition.y, line.end.y + 1);
						}
					}
				}
			}
		}
	}}
	let iterations = 0;
	while(hasCollided) {
		primarilyX = Math.abs(targetPosition.x - sourcePosition.x) > Math.abs(targetPosition.y - sourcePosition.y);
		movement = new Line(sourcePosition, targetPosition, 2/*Segment*/);
		hasCollided = false;
		if(++iterations > 3) {
			return sourcePosition;
		}
		for(let i=0, _subject=colliders, _len=_subject.length; i<_len; ++i) { let c = _subject[i]; {
			if((c.leftLine != null) && movement.end.x > movement.start.x) {
				let line = c.leftLine;
				let p = movement.intersectionWith(line);
				if(p?.toBool()) {
					hasCollided = true;
					if(algorithms.log) {
						System.watch("Check after collision, Hit Left Side", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 15397, 15441, null, null));
					}
					targetPosition.x = Math.min(targetPosition.x, line.end.x - 1);
				}
			} else {
				if((c.rightLine != null) && movement.end.x < movement.start.x) {
					let line = c.rightLine;
					let p = movement.intersectionWith(line);
					if(p?.toBool()) {
						hasCollided = true;
						if(algorithms.log) {
							System.watch("Check after collision, Hit Right Side", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 15855, 15900, null, null));
						}
						targetPosition.x = Math.max(targetPosition.x, line.end.x + 1);
					}
				}
			}
			if((c.topLine != null) && movement.end.y > movement.start.y) {
				let line = c.topLine;
				let p = movement.intersectionWith(line);
				if(p?.toBool()) {
					hasCollided = true;
					if(algorithms.log) {
						System.watch("Check after collision, Hit Top Side", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 16323, 16366, null, null));
					}
					targetPosition.y = Math.min(targetPosition.y, line.end.y - 1);
				}
			} else {
				if((c.bottomLine != null) && movement.end.y < movement.start.y) {
					let line = c.bottomLine;
					let p = movement.intersectionWith(line);
					if(p?.toBool()) {
						hasCollided = true;
						if(algorithms.log) {
							System.watch("Check after collision, Hit Bottom Side", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/game.l", 16822, 16868, null, null));
						}
						targetPosition.y = Math.max(targetPosition.y, line.end.y + 1);
					}
				}
			}
		}}
	}
	return targetPosition;
}
function algorithms_serialize_internal(buffer) {
	buffer.writeBool(algorithms.showColliders);
	buffer.writeBool(algorithms.log);
}
function algorithms_deserialize_internal(buffer) {
	algorithms.showColliders = buffer.readBool();
	algorithms.log = buffer.readBool();
}
function algorithms_serialize_external(buffer) {
	buffer.writeString("showColliders");
	buffer.writeInt32(1);
	buffer.writeBool(algorithms.showColliders);
	buffer.writeString("log");
	buffer.writeInt32(1);
	buffer.writeBool(algorithms.log);
	buffer.writeString("");
}
function algorithms_deserialize_external(buffer) {
	let showColliders_is_set = false, log_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "showColliders":
				buffer.readInt32();
				algorithms.showColliders = buffer.readBool();
				showColliders_is_set = true;
				break;
			case "log":
				buffer.readInt32();
				algorithms.log = buffer.readBool();
				log_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!showColliders_is_set) algorithms.showColliders = false;
				if(!log_is_set) algorithms.log = false;
				return;
		}
	}
}
function PriorityQueue(content) {
	this.content = content;
}
PriorityQueue.prototype.push = function(element) {
	this.content.push(element);
	this.sinkDown(this.content.length - 1);
}
PriorityQueue.prototype.pop = function() {
	let result = this.content[0];
	let end = this.content.pop();
	if(this.content.length > 0) {
		this.content[0] = end;
		this.bubbleUp(0);
	}
	return result;
}
PriorityQueue.prototype.remove = function(node) {
	let i = this.content.indexOf(node);
	let end = this.content.pop();
	if(i != this.content.length - 1) {
		this.content[i] = end;
		if(end.combinedCost < node.combinedCost) {
			this.sinkDown(i);
		} else {
			this.bubbleUp(i);
		}
	}
}
PriorityQueue.prototype.size = function() {
	return this.content.length;
}
PriorityQueue.prototype.rescoreElement = function(node) {
	this.sinkDown(this.content.indexOf(node));
}
PriorityQueue.prototype.sinkDown = function(number) {
	let n = number;
	let element = this.content[n];
	while((n > 0)) {
		let parentN = (((n + 1) >> 1)) - 1;
		let parent = this.content[parentN];
		if(element.combinedCost < parent.combinedCost) {
			this.content[parentN] = element;
			this.content[n] = parent;
			n = parentN;
		} else {
			break;
		}
	}
}
PriorityQueue.prototype.bubbleUp = function(number) {
	let n = number;
	let length = this.content.length, element = this.content[n], elemScore = element.combinedCost;
	while(true) {
		let child2N = ((n + 1) << 1);
		let child1N = child2N - 1;
		let swap = -1;
		let child1Score = 0.0;
		if(child1N < length) {
			let child1 = this.content[child1N];
			child1Score = child1.combinedCost;
			if(child1Score < elemScore) {
				swap = child1N;
			}
		}
		if(child2N < length) {
			let child2 = this.content[child2N];
			let child2Score = child2.combinedCost;
			if(child2Score < ((swap == -1 ? elemScore : child1Score))) {
				swap = child2N;
			}
		}
		if(swap != -1) {
			this.content[n] = this.content[swap];
			this.content[swap] = element;
			n = swap;
		} else {
			break;
		}
	}
}
PriorityQueue.prototype.clone = function() {
	let clone = new _PriorityQueue();
	clone.content = this.content;
	return clone;
}
function _PriorityQueue() {};
_PriorityQueue.prototype = PriorityQueue.prototype;
PriorityQueue.prototype.serialize_internal = function(buffer) {
	let content = this.content
	if(content) {
		var index = _objectCacheIndex.get(content);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(content, index = _objectCache.length);
			_objectCache.push(content);
			buffer.writeInt32(-index);
			content._objectIndex = index;
			buffer.writeInt32(content.length);
			for(let i=0, len=content.length; i<len; ++i) {
				let content_item = content[i]
				if(content_item) {
					var index = _objectCacheIndex.get(content_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(content_item, index = _objectCache.length);
						_objectCache.push(content_item);
						buffer.writeInt32(-index);
						content_item._objectIndex = index;
						content_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
PriorityQueue.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this.content = _objectCache[index];
	} else {
		let content = this.content
		if(!content || content._objectIndex != -index) this.content = content = [];
		_objectCache[-index] = content;
		for(let i=0, len = content.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					content[i] = _objectCache[index];
				} else {
					let content_item = content[i]
					if(!content_item || content_item._objectIndex != -index)
						content[i] = content_item = new _PathfindingNode();
					(_objectCache[-index] = content_item).deserialize_internal(buffer);
				}
		}
	}
}
PriorityQueue.prototype.serialize_external = function(buffer) {
	buffer.writeString("content");
	let content = this.content
	let content_startPos = buffer.reserveSize();
	if(content) {
		var index = _objectCacheIndex.get(content);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(content, index = _objectCache.length);
			_objectCache.push(content);
			buffer.writeInt32(-index);
			content._objectIndex = index;
			buffer.writeInt32(content.length);
			for(let i=0, len=content.length; i<len; ++i) {
				let content_item = content[i]
				if(content_item) {
					var index = _objectCacheIndex.get(content_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(content_item, index = _objectCache.length);
						_objectCache.push(content_item);
						buffer.writeInt32(-index);
						content_item._objectIndex = index;
						content_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(content_startPos);
	buffer.writeString("");
}
PriorityQueue.prototype.deserialize_external = function(buffer) {
	let content_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "content":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.content = _objectCache[index];
				} else {
					let content = this.content
					if(!content || content._objectIndex != -index) this.content = content = [];
					_objectCache[-index] = content;
					for(let i=0, len = content.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								content[i] = _objectCache[index];
							} else {
								let content_item = content[i]
								if(!content_item || content_item._objectIndex != -index)
									content[i] = content_item = new _PathfindingNode();
								(_objectCache[-index] = content_item).deserialize_external(buffer);
							}
					}
				}
				content_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!content_is_set) this.content = [];
				return;
		}
	}
}
function PathfindingNeighbor(node, cost) {
	this.node = node;
	this.cost = cost;
}
PathfindingNeighbor.prototype.clone = function() {
	let clone = new _PathfindingNeighbor();
	clone.node = this.node;
	clone.cost = this.cost;
	return clone;
}
function _PathfindingNeighbor() {};
_PathfindingNeighbor.prototype = PathfindingNeighbor.prototype;
PathfindingNeighbor.prototype.serialize_internal = function(buffer) {
	let node = this.node
	if(node) {
		var index = _objectCacheIndex.get(node);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(node, index = _objectCache.length);
			_objectCache.push(node);
			buffer.writeInt32(-index);
			node._objectIndex = index;
			node.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeFloat64(this.cost);
}
PathfindingNeighbor.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this.node = _objectCache[index];
	} else {
		let node = this.node
		if(!node || node._objectIndex != -index)
			this.node = node = new _PathfindingNode();
		(_objectCache[-index] = node).deserialize_internal(buffer);
	}
	this.cost = buffer.readFloat64();
}
PathfindingNeighbor.prototype.serialize_external = function(buffer) {
	buffer.writeString("node");
	let node_startPos = buffer.reserveSize();
	let node = this.node
	if(node) {
		var index = _objectCacheIndex.get(node);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(node, index = _objectCache.length);
			_objectCache.push(node);
			buffer.writeInt32(-index);
			node._objectIndex = index;
			node.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(node_startPos);
	buffer.writeString("cost");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.cost);
	buffer.writeString("");
}
PathfindingNeighbor.prototype.deserialize_external = function(buffer) {
	let node_is_set = false, cost_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "node":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.node = _objectCache[index];
				} else {
					let node = this.node
					if(!node || node._objectIndex != -index)
						this.node = node = new _PathfindingNode();
					(_objectCache[-index] = node).deserialize_external(buffer);
				}
				node_is_set = true;
				break;
			case "cost":
				buffer.readInt32();
				this.cost = buffer.readFloat64();
				cost_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!node_is_set) this.node = null;
				if(!cost_is_set) this.cost = 0.0;
				return;
		}
	}
}
function PathfindingNode(location, combinedCost, travelCostSoFar, distanceToTarget, visitedInSearchNumber, exploredAllNeighbors, previousNode, neighbors) {
	this.location = location?.clone();
	this.combinedCost = combinedCost;
	this.travelCostSoFar = travelCostSoFar;
	this.distanceToTarget = distanceToTarget;
	this.visitedInSearchNumber = visitedInSearchNumber;
	this.exploredAllNeighbors = exploredAllNeighbors;
	this.previousNode = previousNode;
	this.neighbors = neighbors;
}
PathfindingNode.init = function() {
	PathfindingNode.searchNumber = 0;
}
PathfindingNode.prototype.findPathTo = function(target) {
	let seachNumber = ++PathfindingNode.searchNumber;
	this.combinedCost = 0;
	this.travelCostSoFar = 0;
	this.previousNode = null;
	let openHeap = new PriorityQueue([]);
	openHeap.push(this);
	while(openHeap.size() > 0) {
		let currentNode = openHeap.pop();
		if(currentNode == target) {
			let curr = currentNode;
			let result = [];
			while((curr.previousNode != null)) {
				result.push(curr);
				curr = curr.previousNode;
			}
			result.push(curr);
			return result.reverse();
		}
		currentNode.exploredAllNeighbors = true;
		currentNode.visitedInSearchNumber = seachNumber;
		let neighbors = currentNode.neighbors;
		for(let i=0; i<neighbors.length; ++i) {
			let neighbor = neighbors[i];
			let neighborNode = neighbor.node;
			let beenVisited = neighborNode.visitedInSearchNumber == seachNumber;
			if(!beenVisited) {
				neighborNode.distanceToTarget = neighborNode.location.manhattanDistanceTo(target.location);
				neighborNode.visitedInSearchNumber = seachNumber;
				neighborNode.exploredAllNeighbors = false;
			}
			if(neighborNode.exploredAllNeighbors) {
				continue;
			}
			if(!neighbor.cost) {
				neighbor.cost = currentNode.location.distanceTo(neighborNode.location);
			}
			let travelCostUpToThisNeighbor = currentNode.travelCostSoFar + neighbor.cost;
			if(!beenVisited || travelCostUpToThisNeighbor < neighborNode.travelCostSoFar) {
				neighborNode.previousNode = currentNode;
				neighborNode.travelCostSoFar = travelCostUpToThisNeighbor;
				neighborNode.combinedCost = neighborNode.travelCostSoFar + neighborNode.distanceToTarget;
				if(!beenVisited) {
					openHeap.push(neighborNode);
				} else {
					openHeap.rescoreElement(neighborNode);
				}
			}
		}
	}
	return [];
}
PathfindingNode.prototype.clone = function() {
	let clone = new _PathfindingNode();
	clone.location = this.location.clone();
	clone.combinedCost = this.combinedCost;
	clone.travelCostSoFar = this.travelCostSoFar;
	clone.distanceToTarget = this.distanceToTarget;
	clone.visitedInSearchNumber = this.visitedInSearchNumber;
	clone.exploredAllNeighbors = this.exploredAllNeighbors;
	clone.previousNode = this.previousNode;
	clone.neighbors = this.neighbors;
	return clone;
}
function _PathfindingNode() {};
_PathfindingNode.prototype = PathfindingNode.prototype;
PathfindingNode.prototype.serialize_internal = function(buffer) {
	(this.location || new _Vector2()).serialize_internal(buffer);
	buffer.writeFloat64(this.combinedCost);
	buffer.writeFloat64(this.travelCostSoFar);
	buffer.writeFloat64(this.distanceToTarget);
	buffer.writeInt32(this.visitedInSearchNumber);
	buffer.writeBool(this.exploredAllNeighbors);
	let previousNode = this.previousNode
	if(previousNode) {
		var index = _objectCacheIndex.get(previousNode);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(previousNode, index = _objectCache.length);
			_objectCache.push(previousNode);
			buffer.writeInt32(-index);
			previousNode._objectIndex = index;
			previousNode.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let neighbors = this.neighbors
	if(neighbors) {
		var index = _objectCacheIndex.get(neighbors);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(neighbors, index = _objectCache.length);
			_objectCache.push(neighbors);
			buffer.writeInt32(-index);
			neighbors._objectIndex = index;
			buffer.writeInt32(neighbors.length);
			for(let i=0, len=neighbors.length; i<len; ++i) {
				let neighbors_item = neighbors[i]
				if(neighbors_item) {
					var index = _objectCacheIndex.get(neighbors_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(neighbors_item, index = _objectCache.length);
						_objectCache.push(neighbors_item);
						buffer.writeInt32(-index);
						neighbors_item._objectIndex = index;
						neighbors_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
PathfindingNode.prototype.deserialize_internal = function(buffer) {
	(this.location || (this.location = new _Vector2())).deserialize_internal(buffer);
	this.combinedCost = buffer.readFloat64();
	this.travelCostSoFar = buffer.readFloat64();
	this.distanceToTarget = buffer.readFloat64();
	this.visitedInSearchNumber = buffer.readInt32();
	this.exploredAllNeighbors = buffer.readBool();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.previousNode = _objectCache[index];
	} else {
		let previousNode = this.previousNode
		if(!previousNode || previousNode._objectIndex != -index)
			this.previousNode = previousNode = new _PathfindingNode();
		(_objectCache[-index] = previousNode).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.neighbors = _objectCache[index];
	} else {
		let neighbors = this.neighbors
		if(!neighbors || neighbors._objectIndex != -index) this.neighbors = neighbors = [];
		_objectCache[-index] = neighbors;
		for(let i=0, len = neighbors.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					neighbors[i] = _objectCache[index];
				} else {
					let neighbors_item = neighbors[i]
					if(!neighbors_item || neighbors_item._objectIndex != -index)
						neighbors[i] = neighbors_item = new _PathfindingNeighbor();
					(_objectCache[-index] = neighbors_item).deserialize_internal(buffer);
				}
		}
	}
}
PathfindingNode.prototype.serialize_external = function(buffer) {
	buffer.writeString("location");
	let location_startPos = buffer.reserveSize();
	(this.location || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(location_startPos);
	buffer.writeString("combinedCost");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.combinedCost);
	buffer.writeString("travelCostSoFar");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.travelCostSoFar);
	buffer.writeString("distanceToTarget");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.distanceToTarget);
	buffer.writeString("visitedInSearchNumber");
	buffer.writeInt32(4);
	buffer.writeInt32(this.visitedInSearchNumber);
	buffer.writeString("exploredAllNeighbors");
	buffer.writeInt32(1);
	buffer.writeBool(this.exploredAllNeighbors);
	buffer.writeString("previousNode");
	let previousNode_startPos = buffer.reserveSize();
	let previousNode = this.previousNode
	if(previousNode) {
		var index = _objectCacheIndex.get(previousNode);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(previousNode, index = _objectCache.length);
			_objectCache.push(previousNode);
			buffer.writeInt32(-index);
			previousNode._objectIndex = index;
			previousNode.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(previousNode_startPos);
	buffer.writeString("neighbors");
	let neighbors = this.neighbors
	let neighbors_startPos = buffer.reserveSize();
	if(neighbors) {
		var index = _objectCacheIndex.get(neighbors);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(neighbors, index = _objectCache.length);
			_objectCache.push(neighbors);
			buffer.writeInt32(-index);
			neighbors._objectIndex = index;
			buffer.writeInt32(neighbors.length);
			for(let i=0, len=neighbors.length; i<len; ++i) {
				let neighbors_item = neighbors[i]
				if(neighbors_item) {
					var index = _objectCacheIndex.get(neighbors_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(neighbors_item, index = _objectCache.length);
						_objectCache.push(neighbors_item);
						buffer.writeInt32(-index);
						neighbors_item._objectIndex = index;
						neighbors_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(neighbors_startPos);
	buffer.writeString("");
}
PathfindingNode.prototype.deserialize_external = function(buffer) {
	let location_is_set = false, combinedCost_is_set = false, travelCostSoFar_is_set = false, distanceToTarget_is_set = false, visitedInSearchNumber_is_set = false, exploredAllNeighbors_is_set = false, previousNode_is_set = false, neighbors_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "location":
				buffer.readInt32();
				(this.location || (this.location = new _Vector2())).deserialize_external(buffer);
				location_is_set = true;
				break;
			case "combinedCost":
				buffer.readInt32();
				this.combinedCost = buffer.readFloat64();
				combinedCost_is_set = true;
				break;
			case "travelCostSoFar":
				buffer.readInt32();
				this.travelCostSoFar = buffer.readFloat64();
				travelCostSoFar_is_set = true;
				break;
			case "distanceToTarget":
				buffer.readInt32();
				this.distanceToTarget = buffer.readFloat64();
				distanceToTarget_is_set = true;
				break;
			case "visitedInSearchNumber":
				buffer.readInt32();
				this.visitedInSearchNumber = buffer.readInt32();
				visitedInSearchNumber_is_set = true;
				break;
			case "exploredAllNeighbors":
				buffer.readInt32();
				this.exploredAllNeighbors = buffer.readBool();
				exploredAllNeighbors_is_set = true;
				break;
			case "previousNode":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.previousNode = _objectCache[index];
				} else {
					let previousNode = this.previousNode
					if(!previousNode || previousNode._objectIndex != -index)
						this.previousNode = previousNode = new _PathfindingNode();
					(_objectCache[-index] = previousNode).deserialize_external(buffer);
				}
				previousNode_is_set = true;
				break;
			case "neighbors":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.neighbors = _objectCache[index];
				} else {
					let neighbors = this.neighbors
					if(!neighbors || neighbors._objectIndex != -index) this.neighbors = neighbors = [];
					_objectCache[-index] = neighbors;
					for(let i=0, len = neighbors.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								neighbors[i] = _objectCache[index];
							} else {
								let neighbors_item = neighbors[i]
								if(!neighbors_item || neighbors_item._objectIndex != -index)
									neighbors[i] = neighbors_item = new _PathfindingNeighbor();
								(_objectCache[-index] = neighbors_item).deserialize_external(buffer);
							}
					}
				}
				neighbors_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!location_is_set) this.location = new Vector2(0.0, 0.0, null);
				if(!combinedCost_is_set) this.combinedCost = 0.0;
				if(!travelCostSoFar_is_set) this.travelCostSoFar = 0.0;
				if(!distanceToTarget_is_set) this.distanceToTarget = 0.0;
				if(!visitedInSearchNumber_is_set) this.visitedInSearchNumber = 0;
				if(!exploredAllNeighbors_is_set) this.exploredAllNeighbors = false;
				if(!previousNode_is_set) this.previousNode = null;
				if(!neighbors_is_set) this.neighbors = [];
				return;
		}
	}
}
function InternalUser(id, local, connectionId, index, _id, name, collectInputs, inputFrame, receivedMyInputsUpToPos, lastTouchMoveIndex, inputs, storedInputsUpTo, mediaStream, videoElements, audioElement, videoElementIndex, peerConnection, dataChannels, connectionType, offerByMe, receivedAnswer, connected, connectionTries, connectionState, startToConnectTime, startDataChannelTime, lastIncomingMessageTime, certainFrame, prevCertainFrame) {
	this.id = id;
	this.local = local;
	this.connectionId = connectionId;
	this.index = index;
	this._id = _id;
	this.name = name;
	this.collectInputs = collectInputs;
	this.inputFrame = inputFrame;
	this.receivedMyInputsUpToPos = receivedMyInputsUpToPos;
	this.lastTouchMoveIndex = lastTouchMoveIndex;
	this.inputs = inputs;
	this.storedInputsUpTo = storedInputsUpTo;
	this.downTouches = [];
	this.movingTouches = [];
	this.upTouches = [];
	this.wheelEvents = [];
	this.downKeys = [];
	this.upKeys = [];
	this.pressedKeys = [];
	this.textInputs = [];
	this.textCompositions = [];
	this.navigations = [];
	this.mediaStream = mediaStream;
	this.videoElements = videoElements;
	this.audioElement = audioElement;
	this.videoElementIndex = videoElementIndex;
	this.peerConnection = peerConnection;
	this.dataChannels = dataChannels;
	this.connectionType = connectionType;
	this.offerByMe = offerByMe;
	this.receivedAnswer = receivedAnswer;
	this.connected = connected;
	this.connectionTries = connectionTries;
	this.connectionState = connectionState;
	this.startToConnectTime = startToConnectTime;
	this.startDataChannelTime = startDataChannelTime;
	this.lastIncomingMessageTime = lastIncomingMessageTime;
	this.aheadHistory = [];
	this.maxAheadHistory = [];
	this.bufferFrames = 0;
	this.smoothFrame = int.maxValue;
	this.certainFrame = certainFrame;
	this.prevCertainFrame = prevCertainFrame;
}
InternalUser.prototype.startInputFrame = function(index) {
	this.lastTouchMoveIndex.length = 0;
	this.inputFrame = index;
}
InternalUser.prototype.clearEvent = function() {
	this.downTouches.length = 0;
	this.movingTouches.length = 0;
	this.upTouches.length = 0;
	this.wheelEvents.length = 0;
	this.textCompositions.length = 0;
	this.textInputs.length = 0;
	this.downKeys.length = 0;
	this.upKeys.length = 0;
	this.pressedKeys.length = 0;
	this.navigations.length = 0;
}
InternalUser.prototype.collectStatistics = function(frame) {
	let ahead = frame - this.inputFrame;
	if(ahead < 50) {
		this.aheadHistory.push(ahead)
		if(this.aheadHistory.length > 10 * core.targetFps) this.aheadHistory.splice(0, 1);
	}
	let maxAhead = this.aheadHistory.percentile(80);
	this.maxAheadHistory.push(maxAhead)
	if(this.maxAheadHistory.length > 10 * 60 * core.targetFps) this.maxAheadHistory.splice(0, 1);
	this.bufferFrames = Math.ceil(this.maxAheadHistory.average3());
	this.smoothFrame = frame - this.bufferFrames;
	this.prevCertainFrame = this.certainFrame;
	this.certainFrame = Math.min(this.inputFrame, this.smoothFrame);
}
InternalUser.prototype.simulateRollback = function(frame) {
	this.bufferFrames = 5;
	this.smoothFrame = frame - this.bufferFrames;
}
InternalUser.prototype.clone = function() {
	let clone = new _InternalUser();
	clone.id = this.id;
	clone.local = this.local;
	clone.connectionId = this.connectionId;
	clone.index = this.index;
	clone._id = this._id;
	clone.name = this.name;
	clone.collectInputs = this.collectInputs;
	clone.inputFrame = this.inputFrame;
	clone.receivedMyInputsUpToPos = this.receivedMyInputsUpToPos;
	clone.lastTouchMoveIndex = this.lastTouchMoveIndex;
	clone.inputs = this.inputs;
	clone.storedInputsUpTo = this.storedInputsUpTo;
	clone.downTouches = this.downTouches;
	clone.movingTouches = this.movingTouches;
	clone.upTouches = this.upTouches;
	clone.wheelEvents = this.wheelEvents;
	clone.downKeys = this.downKeys;
	clone.upKeys = this.upKeys;
	clone.pressedKeys = this.pressedKeys;
	clone.textInputs = this.textInputs;
	clone.textCompositions = this.textCompositions;
	clone.navigations = this.navigations;
	clone.mediaStream = this.mediaStream;
	clone.videoElements = this.videoElements;
	clone.audioElement = this.audioElement;
	clone.videoElementIndex = this.videoElementIndex;
	clone.peerConnection = this.peerConnection;
	clone.dataChannels = this.dataChannels;
	clone.connectionType = this.connectionType;
	clone.offerByMe = this.offerByMe;
	clone.receivedAnswer = this.receivedAnswer;
	clone.connected = this.connected;
	clone.connectionTries = this.connectionTries;
	clone.connectionState = this.connectionState;
	clone.startToConnectTime = this.startToConnectTime;
	clone.startDataChannelTime = this.startDataChannelTime;
	clone.lastIncomingMessageTime = this.lastIncomingMessageTime;
	clone.aheadHistory = this.aheadHistory;
	clone.maxAheadHistory = this.maxAheadHistory;
	clone.bufferFrames = this.bufferFrames;
	clone.smoothFrame = this.smoothFrame;
	clone.certainFrame = this.certainFrame;
	clone.prevCertainFrame = this.prevCertainFrame;
	return clone;
}
function _InternalUser() {};
_InternalUser.prototype = InternalUser.prototype;
function UserAccount(_id, language, email, name, colorPreferences) {
	this._id = _id;
	this.language = language;
	this.email = email;
	this.name = name;
	this.colorPreferences = colorPreferences;
}
UserAccount.prototype.clone = function() {
	let clone = new _UserAccount();
	clone._id = this._id;
	clone.language = this.language;
	clone.email = this.email;
	clone.name = this.name;
	clone.colorPreferences = this.colorPreferences;
	return clone;
}
function _UserAccount() {};
_UserAccount.prototype = UserAccount.prototype;
UserAccount.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this._id);
	buffer.writeInt32(this.language);
	buffer.writeString(this.email);
	buffer.writeString(this.name);
	buffer.writeString(this.colorPreferences);
}
UserAccount.prototype.deserialize_internal = function(buffer) {
	this._id = buffer.readString();
	this.language = buffer.readInt32();
	this.email = buffer.readString();
	this.name = buffer.readString();
	this.colorPreferences = buffer.readString();
}
UserAccount.prototype.serialize_external = function(buffer) {
	buffer.writeString("_id");
	buffer.writeString(this._id);
	buffer.writeString("language");
	buffer.writeInt32(4);
	buffer.writeInt32(this.language);
	buffer.writeString("email");
	buffer.writeString(this.email);
	buffer.writeString("name");
	buffer.writeString(this.name);
	buffer.writeString("colorPreferences");
	buffer.writeString(this.colorPreferences);
	buffer.writeString("");
}
UserAccount.prototype.deserialize_external = function(buffer) {
	let _id_is_set = false, language_is_set = false, email_is_set = false, name_is_set = false, colorPreferences_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "_id":
				this._id = buffer.readString();
				_id_is_set = true;
				break;
			case "language":
				buffer.readInt32();
				this.language = buffer.readInt32();
				language_is_set = true;
				break;
			case "email":
				this.email = buffer.readString();
				email_is_set = true;
				break;
			case "name":
				this.name = buffer.readString();
				name_is_set = true;
				break;
			case "colorPreferences":
				this.colorPreferences = buffer.readString();
				colorPreferences_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!_id_is_set) this._id = "";
				if(!language_is_set) this.language = 0/*English*/;
				if(!email_is_set) this.email = "";
				if(!name_is_set) this.name = "";
				if(!colorPreferences_is_set) this.colorPreferences = "";
				return;
		}
	}
}
function Touch(id, by, phase, type, referencePosition, referenceStartPosition, smoothPosition, isDown, handled) {
	this.id = id;
	this.by = by;
	this.phase = phase;
	this.type = type;
	this.referencePosition = referencePosition?.clone();
	this.referenceStartPosition = referenceStartPosition?.clone();
	this.smoothPosition = smoothPosition?.clone();
	this.isDown = isDown;
	this.handled = handled;
}
Touch.prototype.position = function() {
	return this.referencePosition.getRelativeTo(graphics.localMatrix);
}
Touch.prototype.startPosition = function() {
	return this.referenceStartPosition.getRelativeTo(graphics.localMatrix);
}
Touch.prototype.markAsHandled = function() {
	this.handled = true;
}
Touch.prototype.clone = function() {
	let clone = new _Touch();
	clone.id = this.id;
	clone.by = this.by;
	clone.phase = this.phase;
	clone.type = this.type;
	clone.referencePosition = this.referencePosition.clone();
	clone.referenceStartPosition = this.referenceStartPosition.clone();
	clone.smoothPosition = this.smoothPosition.clone();
	clone.isDown = this.isDown;
	clone.handled = this.handled;
	return clone;
}
function _Touch() {};
_Touch.prototype = Touch.prototype;
Touch.prototype.serialize_internal = function(buffer) {
	buffer.writeInt32(this.id);
	let by = this.by
	if(by) {
		var index = _objectCacheIndex.get(by);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(by, index = _objectCache.length);
			_objectCache.push(by);
			buffer.writeInt32(-index);
			by._objectIndex = index;
			by.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.phase);
	buffer.writeInt32(this.type);
	(this.referencePosition || new _Vector2()).serialize_internal(buffer);
	(this.referenceStartPosition || new _Vector2()).serialize_internal(buffer);
	(this.smoothPosition || new _Vector2()).serialize_internal(buffer);
	buffer.writeBool(this.isDown);
	buffer.writeBool(this.handled);
}
Touch.prototype.deserialize_internal = function(buffer) {
	this.id = buffer.readInt32();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.by = _objectCache[index];
	} else {
		let by = this.by
		if(!by || by._objectIndex != -index)
			this.by = by = new _Player();
		(_objectCache[-index] = by).deserialize_internal(buffer);
	}
	this.phase = buffer.readInt32();
	this.type = buffer.readInt32();
	(this.referencePosition || (this.referencePosition = new _Vector2())).deserialize_internal(buffer);
	(this.referenceStartPosition || (this.referenceStartPosition = new _Vector2())).deserialize_internal(buffer);
	(this.smoothPosition || (this.smoothPosition = new _Vector2())).deserialize_internal(buffer);
	this.isDown = buffer.readBool();
	this.handled = buffer.readBool();
}
Touch.prototype.serialize_external = function(buffer) {
	buffer.writeString("id");
	buffer.writeInt32(4);
	buffer.writeInt32(this.id);
	buffer.writeString("by");
	let by_startPos = buffer.reserveSize();
	let by = this.by
	if(by) {
		var index = _objectCacheIndex.get(by);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(by, index = _objectCache.length);
			_objectCache.push(by);
			buffer.writeInt32(-index);
			by._objectIndex = index;
			by.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(by_startPos);
	buffer.writeString("phase");
	buffer.writeInt32(4);
	buffer.writeInt32(this.phase);
	buffer.writeString("type");
	buffer.writeInt32(4);
	buffer.writeInt32(this.type);
	buffer.writeString("referencePosition");
	let referencePosition_startPos = buffer.reserveSize();
	(this.referencePosition || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(referencePosition_startPos);
	buffer.writeString("referenceStartPosition");
	let referenceStartPosition_startPos = buffer.reserveSize();
	(this.referenceStartPosition || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(referenceStartPosition_startPos);
	buffer.writeString("smoothPosition");
	let smoothPosition_startPos = buffer.reserveSize();
	(this.smoothPosition || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(smoothPosition_startPos);
	buffer.writeString("isDown");
	buffer.writeInt32(1);
	buffer.writeBool(this.isDown);
	buffer.writeString("handled");
	buffer.writeInt32(1);
	buffer.writeBool(this.handled);
	buffer.writeString("");
}
Touch.prototype.deserialize_external = function(buffer) {
	let id_is_set = false, by_is_set = false, phase_is_set = false, type_is_set = false, referencePosition_is_set = false, referenceStartPosition_is_set = false, smoothPosition_is_set = false, isDown_is_set = false, handled_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "id":
				buffer.readInt32();
				this.id = buffer.readInt32();
				id_is_set = true;
				break;
			case "by":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.by = _objectCache[index];
				} else {
					let by = this.by
					if(!by || by._objectIndex != -index)
						this.by = by = new _Player();
					(_objectCache[-index] = by).deserialize_external(buffer);
				}
				by_is_set = true;
				break;
			case "phase":
				buffer.readInt32();
				this.phase = buffer.readInt32();
				phase_is_set = true;
				break;
			case "type":
				buffer.readInt32();
				this.type = buffer.readInt32();
				type_is_set = true;
				break;
			case "referencePosition":
				buffer.readInt32();
				(this.referencePosition || (this.referencePosition = new _Vector2())).deserialize_external(buffer);
				referencePosition_is_set = true;
				break;
			case "referenceStartPosition":
				buffer.readInt32();
				(this.referenceStartPosition || (this.referenceStartPosition = new _Vector2())).deserialize_external(buffer);
				referenceStartPosition_is_set = true;
				break;
			case "smoothPosition":
				buffer.readInt32();
				(this.smoothPosition || (this.smoothPosition = new _Vector2())).deserialize_external(buffer);
				smoothPosition_is_set = true;
				break;
			case "isDown":
				buffer.readInt32();
				this.isDown = buffer.readBool();
				isDown_is_set = true;
				break;
			case "handled":
				buffer.readInt32();
				this.handled = buffer.readBool();
				handled_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!id_is_set) this.id = 0;
				if(!by_is_set) this.by = null;
				if(!phase_is_set) this.phase = 0/*Still*/;
				if(!type_is_set) this.type = 0/*Left*/;
				if(!referencePosition_is_set) this.referencePosition = new Vector2(0.0, 0.0, null);
				if(!referenceStartPosition_is_set) this.referenceStartPosition = new Vector2(0.0, 0.0, null);
				if(!smoothPosition_is_set) this.smoothPosition = new Vector2(0.0, 0.0, null);
				if(!isDown_is_set) this.isDown = false;
				if(!handled_is_set) this.handled = false;
				return;
		}
	}
}
function ScrollEvent(userId, delta, isPinch, referencePosition, handled) {
	this.userId = userId;
	this.delta = delta?.clone();
	this.isPinch = isPinch;
	this.referencePosition = referencePosition?.clone();
	this.handled = handled;
}
ScrollEvent.prototype.position = function() {
	return this.referencePosition.getRelativeTo(graphics.localMatrix);
}
ScrollEvent.prototype.markAsHandled = function() {
	this.handled = true;
}
ScrollEvent.prototype.clone = function() {
	let clone = new _ScrollEvent();
	clone.userId = this.userId;
	clone.delta = this.delta.clone();
	clone.isPinch = this.isPinch;
	clone.referencePosition = this.referencePosition.clone();
	clone.handled = this.handled;
	return clone;
}
function _ScrollEvent() {};
_ScrollEvent.prototype = ScrollEvent.prototype;
function DigitalButton(name, key, state, prevState) {
	this.name = name;
	this.key = key;
	this.state = state;
	this.prevState = prevState;
}
DigitalButton.prototype.down = function() {
	return this.state && !this.prevState;
}
DigitalButton.prototype.up = function() {
	return !this.state && this.prevState;
}
DigitalButton.prototype.toString = function() {
	return this.name;
}
DigitalButton.prototype.assign = function(name, key) {
	this.name = name;
	this.key = key;
	this.state = false;
	this.prevState = false;
}
DigitalButton.prototype.startFrame = function() {
	this.prevState = this.state;
	this.state = false;
}
DigitalButton.prototype.clone = function() {
	let clone = new _DigitalButton();
	clone.name = this.name;
	clone.key = this.key;
	clone.state = this.state;
	clone.prevState = this.prevState;
	return clone;
}
function _DigitalButton() {};
_DigitalButton.prototype = DigitalButton.prototype;
DigitalButton.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.name);
	buffer.writeInt32(this.key);
	buffer.writeBool(this.state);
	buffer.writeBool(this.prevState);
}
DigitalButton.prototype.deserialize_internal = function(buffer) {
	this.name = buffer.readString();
	this.key = buffer.readInt32();
	this.state = buffer.readBool();
	this.prevState = buffer.readBool();
}
DigitalButton.prototype.serialize_external = function(buffer) {
	buffer.writeString("name");
	buffer.writeString(this.name);
	buffer.writeString("key");
	buffer.writeInt32(4);
	buffer.writeInt32(this.key);
	buffer.writeString("state");
	buffer.writeInt32(1);
	buffer.writeBool(this.state);
	buffer.writeString("prevState");
	buffer.writeInt32(1);
	buffer.writeBool(this.prevState);
	buffer.writeString("");
}
DigitalButton.prototype.deserialize_external = function(buffer) {
	let name_is_set = false, key_is_set = false, state_is_set = false, prevState_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "name":
				this.name = buffer.readString();
				name_is_set = true;
				break;
			case "key":
				buffer.readInt32();
				this.key = buffer.readInt32();
				key_is_set = true;
				break;
			case "state":
				buffer.readInt32();
				this.state = buffer.readBool();
				state_is_set = true;
				break;
			case "prevState":
				buffer.readInt32();
				this.prevState = buffer.readBool();
				prevState_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!name_is_set) this.name = "";
				if(!key_is_set) this.key = 0/*None*/;
				if(!state_is_set) this.state = false;
				if(!prevState_is_set) this.prevState = false;
				return;
		}
	}
}
function ControllerButtonPlayerAndIndex(userId, buttonIndex) {
	this.userId = userId;
	this.buttonIndex = buttonIndex;
}
ControllerButtonPlayerAndIndex.prototype.clone = function() {
	let clone = new _ControllerButtonPlayerAndIndex();
	clone.userId = this.userId;
	clone.buttonIndex = this.buttonIndex;
	return clone;
}
function _ControllerButtonPlayerAndIndex() {};
_ControllerButtonPlayerAndIndex.prototype = ControllerButtonPlayerAndIndex.prototype;
function GameController(inMotion, type) {
	this.leftStick = new Vector2(0.0, 0.0, null);
	this.rightStick = new Vector2(0.0, 0.0, null);
	this.up = new DigitalButton("", 0/*None*/, false, false);
	this.right = new DigitalButton("", 0/*None*/, false, false);
	this.down = new DigitalButton("", 0/*None*/, false, false);
	this.left = new DigitalButton("", 0/*None*/, false, false);
	this.a = new DigitalButton("", 0/*None*/, false, false);
	this.b = new DigitalButton("", 0/*None*/, false, false);
	this.x = new DigitalButton("", 0/*None*/, false, false);
	this.y = new DigitalButton("", 0/*None*/, false, false);
	this.menu = new DigitalButton("", 0/*None*/, false, false);
	this.buttons = [new DigitalButton("None", 0/*None*/, false, false), this.up, this.right, this.down, this.left, this.a, this.b, this.x, this.y, this.menu];
	this.inMotion = inMotion;
	this.type = type;
}
GameController.deadZone = .1;
GameController.prototype.startFrame = function() {
	this.leftStick.x = 0;
	this.leftStick.y = 0;
	this.rightStick.x = 0;
	this.rightStick.y = 0;
	for(let i=0, _subject=this.buttons, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		it.startFrame();
	}}
}
GameController.prototype.clone = function() {
	let clone = new _GameController();
	clone.leftStick = this.leftStick.clone();
	clone.rightStick = this.rightStick.clone();
	clone.up = this.up;
	clone.right = this.right;
	clone.down = this.down;
	clone.left = this.left;
	clone.a = this.a;
	clone.b = this.b;
	clone.x = this.x;
	clone.y = this.y;
	clone.menu = this.menu;
	clone.buttons = this.buttons;
	clone.inMotion = this.inMotion;
	clone.type = this.type;
	return clone;
}
function _GameController() {};
_GameController.prototype = GameController.prototype;
GameController.prototype.serialize_internal = function(buffer) {
	(this.leftStick || new _Vector2()).serialize_internal(buffer);
	(this.rightStick || new _Vector2()).serialize_internal(buffer);
	let up = this.up
	if(up) {
		var index = _objectCacheIndex.get(up);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(up, index = _objectCache.length);
			_objectCache.push(up);
			buffer.writeInt32(-index);
			up._objectIndex = index;
			up.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let right = this.right
	if(right) {
		var index = _objectCacheIndex.get(right);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(right, index = _objectCache.length);
			_objectCache.push(right);
			buffer.writeInt32(-index);
			right._objectIndex = index;
			right.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let down = this.down
	if(down) {
		var index = _objectCacheIndex.get(down);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(down, index = _objectCache.length);
			_objectCache.push(down);
			buffer.writeInt32(-index);
			down._objectIndex = index;
			down.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let left = this.left
	if(left) {
		var index = _objectCacheIndex.get(left);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(left, index = _objectCache.length);
			_objectCache.push(left);
			buffer.writeInt32(-index);
			left._objectIndex = index;
			left.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let a = this.a
	if(a) {
		var index = _objectCacheIndex.get(a);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(a, index = _objectCache.length);
			_objectCache.push(a);
			buffer.writeInt32(-index);
			a._objectIndex = index;
			a.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let b = this.b
	if(b) {
		var index = _objectCacheIndex.get(b);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(b, index = _objectCache.length);
			_objectCache.push(b);
			buffer.writeInt32(-index);
			b._objectIndex = index;
			b.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let x = this.x
	if(x) {
		var index = _objectCacheIndex.get(x);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(x, index = _objectCache.length);
			_objectCache.push(x);
			buffer.writeInt32(-index);
			x._objectIndex = index;
			x.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let y = this.y
	if(y) {
		var index = _objectCacheIndex.get(y);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(y, index = _objectCache.length);
			_objectCache.push(y);
			buffer.writeInt32(-index);
			y._objectIndex = index;
			y.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let menu = this.menu
	if(menu) {
		var index = _objectCacheIndex.get(menu);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(menu, index = _objectCache.length);
			_objectCache.push(menu);
			buffer.writeInt32(-index);
			menu._objectIndex = index;
			menu.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let buttons = this.buttons
	if(buttons) {
		var index = _objectCacheIndex.get(buttons);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(buttons, index = _objectCache.length);
			_objectCache.push(buttons);
			buffer.writeInt32(-index);
			buttons._objectIndex = index;
			buffer.writeInt32(buttons.length);
			for(let i=0, len=buttons.length; i<len; ++i) {
				let buttons_item = buttons[i]
				if(buttons_item) {
					var index = _objectCacheIndex.get(buttons_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(buttons_item, index = _objectCache.length);
						_objectCache.push(buttons_item);
						buffer.writeInt32(-index);
						buttons_item._objectIndex = index;
						buttons_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeBool(this.inMotion);
	buffer.writeInt32(this.type);
}
GameController.prototype.deserialize_internal = function(buffer) {
	(this.leftStick || (this.leftStick = new _Vector2())).deserialize_internal(buffer);
	(this.rightStick || (this.rightStick = new _Vector2())).deserialize_internal(buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.up = _objectCache[index];
	} else {
		let up = this.up
		if(!up || up._objectIndex != -index)
			this.up = up = new _DigitalButton();
		(_objectCache[-index] = up).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.right = _objectCache[index];
	} else {
		let right = this.right
		if(!right || right._objectIndex != -index)
			this.right = right = new _DigitalButton();
		(_objectCache[-index] = right).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.down = _objectCache[index];
	} else {
		let down = this.down
		if(!down || down._objectIndex != -index)
			this.down = down = new _DigitalButton();
		(_objectCache[-index] = down).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.left = _objectCache[index];
	} else {
		let left = this.left
		if(!left || left._objectIndex != -index)
			this.left = left = new _DigitalButton();
		(_objectCache[-index] = left).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.a = _objectCache[index];
	} else {
		let a = this.a
		if(!a || a._objectIndex != -index)
			this.a = a = new _DigitalButton();
		(_objectCache[-index] = a).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.b = _objectCache[index];
	} else {
		let b = this.b
		if(!b || b._objectIndex != -index)
			this.b = b = new _DigitalButton();
		(_objectCache[-index] = b).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.x = _objectCache[index];
	} else {
		let x = this.x
		if(!x || x._objectIndex != -index)
			this.x = x = new _DigitalButton();
		(_objectCache[-index] = x).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.y = _objectCache[index];
	} else {
		let y = this.y
		if(!y || y._objectIndex != -index)
			this.y = y = new _DigitalButton();
		(_objectCache[-index] = y).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.menu = _objectCache[index];
	} else {
		let menu = this.menu
		if(!menu || menu._objectIndex != -index)
			this.menu = menu = new _DigitalButton();
		(_objectCache[-index] = menu).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.buttons = _objectCache[index];
	} else {
		let buttons = this.buttons
		if(!buttons || buttons._objectIndex != -index) this.buttons = buttons = [];
		_objectCache[-index] = buttons;
		for(let i=0, len = buttons.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					buttons[i] = _objectCache[index];
				} else {
					let buttons_item = buttons[i]
					if(!buttons_item || buttons_item._objectIndex != -index)
						buttons[i] = buttons_item = new _DigitalButton();
					(_objectCache[-index] = buttons_item).deserialize_internal(buffer);
				}
		}
	}
	this.inMotion = buffer.readBool();
	this.type = buffer.readInt32();
}
GameController.prototype.serialize_external = function(buffer) {
	buffer.writeString("leftStick");
	let leftStick_startPos = buffer.reserveSize();
	(this.leftStick || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(leftStick_startPos);
	buffer.writeString("rightStick");
	let rightStick_startPos = buffer.reserveSize();
	(this.rightStick || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(rightStick_startPos);
	buffer.writeString("up");
	let up_startPos = buffer.reserveSize();
	let up = this.up
	if(up) {
		var index = _objectCacheIndex.get(up);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(up, index = _objectCache.length);
			_objectCache.push(up);
			buffer.writeInt32(-index);
			up._objectIndex = index;
			up.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(up_startPos);
	buffer.writeString("right");
	let right_startPos = buffer.reserveSize();
	let right = this.right
	if(right) {
		var index = _objectCacheIndex.get(right);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(right, index = _objectCache.length);
			_objectCache.push(right);
			buffer.writeInt32(-index);
			right._objectIndex = index;
			right.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(right_startPos);
	buffer.writeString("down");
	let down_startPos = buffer.reserveSize();
	let down = this.down
	if(down) {
		var index = _objectCacheIndex.get(down);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(down, index = _objectCache.length);
			_objectCache.push(down);
			buffer.writeInt32(-index);
			down._objectIndex = index;
			down.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(down_startPos);
	buffer.writeString("left");
	let left_startPos = buffer.reserveSize();
	let left = this.left
	if(left) {
		var index = _objectCacheIndex.get(left);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(left, index = _objectCache.length);
			_objectCache.push(left);
			buffer.writeInt32(-index);
			left._objectIndex = index;
			left.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(left_startPos);
	buffer.writeString("a");
	let a_startPos = buffer.reserveSize();
	let a = this.a
	if(a) {
		var index = _objectCacheIndex.get(a);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(a, index = _objectCache.length);
			_objectCache.push(a);
			buffer.writeInt32(-index);
			a._objectIndex = index;
			a.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(a_startPos);
	buffer.writeString("b");
	let b_startPos = buffer.reserveSize();
	let b = this.b
	if(b) {
		var index = _objectCacheIndex.get(b);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(b, index = _objectCache.length);
			_objectCache.push(b);
			buffer.writeInt32(-index);
			b._objectIndex = index;
			b.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(b_startPos);
	buffer.writeString("x");
	let x_startPos = buffer.reserveSize();
	let x = this.x
	if(x) {
		var index = _objectCacheIndex.get(x);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(x, index = _objectCache.length);
			_objectCache.push(x);
			buffer.writeInt32(-index);
			x._objectIndex = index;
			x.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(x_startPos);
	buffer.writeString("y");
	let y_startPos = buffer.reserveSize();
	let y = this.y
	if(y) {
		var index = _objectCacheIndex.get(y);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(y, index = _objectCache.length);
			_objectCache.push(y);
			buffer.writeInt32(-index);
			y._objectIndex = index;
			y.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(y_startPos);
	buffer.writeString("menu");
	let menu_startPos = buffer.reserveSize();
	let menu = this.menu
	if(menu) {
		var index = _objectCacheIndex.get(menu);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(menu, index = _objectCache.length);
			_objectCache.push(menu);
			buffer.writeInt32(-index);
			menu._objectIndex = index;
			menu.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(menu_startPos);
	buffer.writeString("buttons");
	let buttons = this.buttons
	let buttons_startPos = buffer.reserveSize();
	if(buttons) {
		var index = _objectCacheIndex.get(buttons);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(buttons, index = _objectCache.length);
			_objectCache.push(buttons);
			buffer.writeInt32(-index);
			buttons._objectIndex = index;
			buffer.writeInt32(buttons.length);
			for(let i=0, len=buttons.length; i<len; ++i) {
				let buttons_item = buttons[i]
				if(buttons_item) {
					var index = _objectCacheIndex.get(buttons_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(buttons_item, index = _objectCache.length);
						_objectCache.push(buttons_item);
						buffer.writeInt32(-index);
						buttons_item._objectIndex = index;
						buttons_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(buttons_startPos);
	buffer.writeString("inMotion");
	buffer.writeInt32(1);
	buffer.writeBool(this.inMotion);
	buffer.writeString("type");
	buffer.writeInt32(4);
	buffer.writeInt32(this.type);
	buffer.writeString("");
}
GameController.prototype.deserialize_external = function(buffer) {
	let leftStick_is_set = false, rightStick_is_set = false, up_is_set = false, right_is_set = false, down_is_set = false, left_is_set = false, a_is_set = false, b_is_set = false, x_is_set = false, y_is_set = false, menu_is_set = false, buttons_is_set = false, inMotion_is_set = false, type_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "leftStick":
				buffer.readInt32();
				(this.leftStick || (this.leftStick = new _Vector2())).deserialize_external(buffer);
				leftStick_is_set = true;
				break;
			case "rightStick":
				buffer.readInt32();
				(this.rightStick || (this.rightStick = new _Vector2())).deserialize_external(buffer);
				rightStick_is_set = true;
				break;
			case "up":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.up = _objectCache[index];
				} else {
					let up = this.up
					if(!up || up._objectIndex != -index)
						this.up = up = new _DigitalButton();
					(_objectCache[-index] = up).deserialize_external(buffer);
				}
				up_is_set = true;
				break;
			case "right":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.right = _objectCache[index];
				} else {
					let right = this.right
					if(!right || right._objectIndex != -index)
						this.right = right = new _DigitalButton();
					(_objectCache[-index] = right).deserialize_external(buffer);
				}
				right_is_set = true;
				break;
			case "down":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.down = _objectCache[index];
				} else {
					let down = this.down
					if(!down || down._objectIndex != -index)
						this.down = down = new _DigitalButton();
					(_objectCache[-index] = down).deserialize_external(buffer);
				}
				down_is_set = true;
				break;
			case "left":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.left = _objectCache[index];
				} else {
					let left = this.left
					if(!left || left._objectIndex != -index)
						this.left = left = new _DigitalButton();
					(_objectCache[-index] = left).deserialize_external(buffer);
				}
				left_is_set = true;
				break;
			case "a":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.a = _objectCache[index];
				} else {
					let a = this.a
					if(!a || a._objectIndex != -index)
						this.a = a = new _DigitalButton();
					(_objectCache[-index] = a).deserialize_external(buffer);
				}
				a_is_set = true;
				break;
			case "b":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.b = _objectCache[index];
				} else {
					let b = this.b
					if(!b || b._objectIndex != -index)
						this.b = b = new _DigitalButton();
					(_objectCache[-index] = b).deserialize_external(buffer);
				}
				b_is_set = true;
				break;
			case "x":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.x = _objectCache[index];
				} else {
					let x = this.x
					if(!x || x._objectIndex != -index)
						this.x = x = new _DigitalButton();
					(_objectCache[-index] = x).deserialize_external(buffer);
				}
				x_is_set = true;
				break;
			case "y":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.y = _objectCache[index];
				} else {
					let y = this.y
					if(!y || y._objectIndex != -index)
						this.y = y = new _DigitalButton();
					(_objectCache[-index] = y).deserialize_external(buffer);
				}
				y_is_set = true;
				break;
			case "menu":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.menu = _objectCache[index];
				} else {
					let menu = this.menu
					if(!menu || menu._objectIndex != -index)
						this.menu = menu = new _DigitalButton();
					(_objectCache[-index] = menu).deserialize_external(buffer);
				}
				menu_is_set = true;
				break;
			case "buttons":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.buttons = _objectCache[index];
				} else {
					let buttons = this.buttons
					if(!buttons || buttons._objectIndex != -index) this.buttons = buttons = [];
					_objectCache[-index] = buttons;
					for(let i=0, len = buttons.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								buttons[i] = _objectCache[index];
							} else {
								let buttons_item = buttons[i]
								if(!buttons_item || buttons_item._objectIndex != -index)
									buttons[i] = buttons_item = new _DigitalButton();
								(_objectCache[-index] = buttons_item).deserialize_external(buffer);
							}
					}
				}
				buttons_is_set = true;
				break;
			case "inMotion":
				buffer.readInt32();
				this.inMotion = buffer.readBool();
				inMotion_is_set = true;
				break;
			case "type":
				buffer.readInt32();
				this.type = buffer.readInt32();
				type_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!leftStick_is_set) this.leftStick = new Vector2(0.0, 0.0, null);
				if(!rightStick_is_set) this.rightStick = new Vector2(0.0, 0.0, null);
				if(!up_is_set) this.up = new DigitalButton("", 0/*None*/, false, false);
				if(!right_is_set) this.right = new DigitalButton("", 0/*None*/, false, false);
				if(!down_is_set) this.down = new DigitalButton("", 0/*None*/, false, false);
				if(!left_is_set) this.left = new DigitalButton("", 0/*None*/, false, false);
				if(!a_is_set) this.a = new DigitalButton("", 0/*None*/, false, false);
				if(!b_is_set) this.b = new DigitalButton("", 0/*None*/, false, false);
				if(!x_is_set) this.x = new DigitalButton("", 0/*None*/, false, false);
				if(!y_is_set) this.y = new DigitalButton("", 0/*None*/, false, false);
				if(!menu_is_set) this.menu = new DigitalButton("", 0/*None*/, false, false);
				if(!buttons_is_set) this.buttons = [new DigitalButton("None", 0/*None*/, false, false), this.up, this.right, this.down, this.left, this.a, this.b, this.x, this.y, this.menu];
				if(!inMotion_is_set) this.inMotion = false;
				if(!type_is_set) this.type = 0/*Keyboard*/;
				return;
		}
	}
}
function InternetGamePadButton(pressed, touched, value) {
	this.pressed = pressed;
	this.touched = touched;
	this.value = value;
}
InternetGamePadButton.prototype.clone = function() {
	let clone = new _InternetGamePadButton();
	clone.pressed = this.pressed;
	clone.touched = this.touched;
	clone.value = this.value;
	return clone;
}
function _InternetGamePadButton() {};
_InternetGamePadButton.prototype = InternetGamePadButton.prototype;
InternetGamePadButton.prototype.serialize_internal = function(buffer) {
	buffer.writeBool(this.pressed);
	buffer.writeBool(this.touched);
	buffer.writeFloat64(this.value);
}
InternetGamePadButton.prototype.deserialize_internal = function(buffer) {
	this.pressed = buffer.readBool();
	this.touched = buffer.readBool();
	this.value = buffer.readFloat64();
}
InternetGamePadButton.prototype.serialize_external = function(buffer) {
	buffer.writeString("pressed");
	buffer.writeInt32(1);
	buffer.writeBool(this.pressed);
	buffer.writeString("touched");
	buffer.writeInt32(1);
	buffer.writeBool(this.touched);
	buffer.writeString("value");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.value);
	buffer.writeString("");
}
InternetGamePadButton.prototype.deserialize_external = function(buffer) {
	let pressed_is_set = false, touched_is_set = false, value_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "pressed":
				buffer.readInt32();
				this.pressed = buffer.readBool();
				pressed_is_set = true;
				break;
			case "touched":
				buffer.readInt32();
				this.touched = buffer.readBool();
				touched_is_set = true;
				break;
			case "value":
				buffer.readInt32();
				this.value = buffer.readFloat64();
				value_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!pressed_is_set) this.pressed = false;
				if(!touched_is_set) this.touched = false;
				if(!value_is_set) this.value = 0.0;
				return;
		}
	}
}
function InternetGamePad(axes, buttons, id) {
	this.axes = axes;
	this.buttons = buttons;
	this.id = id;
}
InternetGamePad.prototype.clone = function() {
	let clone = new _InternetGamePad();
	clone.axes = this.axes;
	clone.buttons = this.buttons;
	clone.id = this.id;
	return clone;
}
function _InternetGamePad() {};
_InternetGamePad.prototype = InternetGamePad.prototype;
InternetGamePad.prototype.serialize_internal = function(buffer) {
	let axes = this.axes
	if(axes) {
		var index = _objectCacheIndex.get(axes);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(axes, index = _objectCache.length);
			_objectCache.push(axes);
			buffer.writeInt32(-index);
			axes._objectIndex = index;
			buffer.writeInt32(axes.length);
			for(let i=0, len=axes.length; i<len; ++i) {
				buffer.writeFloat64(axes[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let buttons = this.buttons
	if(buttons) {
		var index = _objectCacheIndex.get(buttons);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(buttons, index = _objectCache.length);
			_objectCache.push(buttons);
			buffer.writeInt32(-index);
			buttons._objectIndex = index;
			buffer.writeInt32(buttons.length);
			for(let i=0, len=buttons.length; i<len; ++i) {
				let buttons_item = buttons[i]
				if(buttons_item) {
					var index = _objectCacheIndex.get(buttons_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(buttons_item, index = _objectCache.length);
						_objectCache.push(buttons_item);
						buffer.writeInt32(-index);
						buttons_item._objectIndex = index;
						buttons_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeString(this.id);
}
InternetGamePad.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this.axes = _objectCache[index];
	} else {
		let axes = this.axes
		if(!axes || axes._objectIndex != -index) this.axes = axes = [];
		_objectCache[-index] = axes;
		for(let i=0, len = axes.length = buffer.readInt32(); i<len; ++i) {
				axes[i] = buffer.readFloat64();
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.buttons = _objectCache[index];
	} else {
		let buttons = this.buttons
		if(!buttons || buttons._objectIndex != -index) this.buttons = buttons = [];
		_objectCache[-index] = buttons;
		for(let i=0, len = buttons.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					buttons[i] = _objectCache[index];
				} else {
					let buttons_item = buttons[i]
					if(!buttons_item || buttons_item._objectIndex != -index)
						buttons[i] = buttons_item = new _InternetGamePadButton();
					(_objectCache[-index] = buttons_item).deserialize_internal(buffer);
				}
		}
	}
	this.id = buffer.readString();
}
InternetGamePad.prototype.serialize_external = function(buffer) {
	buffer.writeString("axes");
	let axes = this.axes
	let axes_startPos = buffer.reserveSize();
	if(axes) {
		var index = _objectCacheIndex.get(axes);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(axes, index = _objectCache.length);
			_objectCache.push(axes);
			buffer.writeInt32(-index);
			axes._objectIndex = index;
			buffer.writeInt32(axes.length);
			for(let i=0, len=axes.length; i<len; ++i) {
				buffer.writeFloat64(axes[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(axes_startPos);
	buffer.writeString("buttons");
	let buttons = this.buttons
	let buttons_startPos = buffer.reserveSize();
	if(buttons) {
		var index = _objectCacheIndex.get(buttons);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(buttons, index = _objectCache.length);
			_objectCache.push(buttons);
			buffer.writeInt32(-index);
			buttons._objectIndex = index;
			buffer.writeInt32(buttons.length);
			for(let i=0, len=buttons.length; i<len; ++i) {
				let buttons_item = buttons[i]
				if(buttons_item) {
					var index = _objectCacheIndex.get(buttons_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(buttons_item, index = _objectCache.length);
						_objectCache.push(buttons_item);
						buffer.writeInt32(-index);
						buttons_item._objectIndex = index;
						buttons_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(buttons_startPos);
	buffer.writeString("id");
	buffer.writeString(this.id);
	buffer.writeString("");
}
InternetGamePad.prototype.deserialize_external = function(buffer) {
	let axes_is_set = false, buttons_is_set = false, id_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "axes":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.axes = _objectCache[index];
				} else {
					let axes = this.axes
					if(!axes || axes._objectIndex != -index) this.axes = axes = [];
					_objectCache[-index] = axes;
					for(let i=0, len = axes.length = buffer.readInt32(); i<len; ++i) {
							axes[i] = buffer.readFloat64();
					}
				}
				axes_is_set = true;
				break;
			case "buttons":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.buttons = _objectCache[index];
				} else {
					let buttons = this.buttons
					if(!buttons || buttons._objectIndex != -index) this.buttons = buttons = [];
					_objectCache[-index] = buttons;
					for(let i=0, len = buttons.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								buttons[i] = _objectCache[index];
							} else {
								let buttons_item = buttons[i]
								if(!buttons_item || buttons_item._objectIndex != -index)
									buttons[i] = buttons_item = new _InternetGamePadButton();
								(_objectCache[-index] = buttons_item).deserialize_external(buffer);
							}
					}
				}
				buttons_is_set = true;
				break;
			case "id":
				this.id = buffer.readString();
				id_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!axes_is_set) this.axes = [];
				if(!buttons_is_set) this.buttons = [];
				if(!id_is_set) this.id = "";
				return;
		}
	}
}
var input; if(!input) input = {};
input.switchPerspectiveTo = function(player) {
	System.watch(("Switching to "+player?.toString()), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 14146, 14175, null, null));
	input.showPerspectiveOf = player;
	if(Platform.mode == 3/*Play*/ || Platform.mode == 0/*Pause*/) {
		core.switchToPlayer(player);
	}
}
input.textInput = function() {
	let localPlayer = input.playersById[input.localUser.id];
	return localPlayer.textInput;
}
input.init = function() {
	input.internalUsers = [];
	input.localUser = null;
	input.localPlayer = null;
	input.isCertain = false;
	input.controllerButtonMap = new Map();
	input.players = [];
	input.active = true;
	input.host = null;
	input.showPerspectiveOf = null;
	input.playersById = [];
	input.cursor = "pointer";
	input.showPointers = true;
	input.showPointersMode = 2/*Remote*/;
	input.showPointersDuringPlaybackMode = 3/*LocalAndRemote*/;
	input.enableClickingWithAltKey = false;
	input.ignoreFirstClick = false;
	input.generateIntegrationTest = 0/*None*/;
	input.integrationTest = "";
	input.playersToRemove = [];
	input.isTextInputActive = false;
	input.initHandlers();
}
input.logicalToPixelPosition = function(pos) {
	let p = pos.getTransformed(graphics.totalMatrix)
	return new Vector2(p.x/Platform.pixelRatio, p.y/Platform.pixelRatio, null)
}
input.initHandlers = function() {
	let pointerX = 0, pointerY = 0, clickWithAltKeyX = 0, clickWithAltKeyY = 0
	window.onpointerdown = e => {
		if(e.button == 0 && Platform.mode == 0) {
			Platform.record();
			if(input.ignoreFirstClick) return;
		}
		input.handleTouchEvent(1, e.pageX, e.pageY, e.pointerType, e.pointerId, e.button, e.shiftKey, e.altKey, e.ctrlKey || e.metaKey);
	}
	window.onpointermove = e => {
		pointerX = e.pageX; pointerY = e.pageY;
		input.handleTouchEvent(2, e.pageX, e.pageY, e.pointerType, e.pointerId, e.button, e.shiftKey, e.altKey, e.ctrlKey || e.metaKey);
	}
	window.onpointerup = e => {
		input.handleTouchEvent(3, e.pageX, e.pageY, e.pointerType, e.pointerId, e.button, e.shiftKey, e.altKey, e.ctrlKey || e.metaKey);
	}
	window.oncontextmenu = e => {
		e.preventDefault();
		e.stopPropagation();
		return false;
	}
	window.onkeydown = e => {
		let keyCode = e.keyCode
		let key = e.key
		let ctrlOrCmd = e.ctrlKey || e.metaKey
		if(window.require && key == "t" && e.metaKey && e.shiftKey)
			Platform.openDevTools();
		else
		if(ctrlOrCmd && key == "s") {
			
			core.saveEventStream();
			e.preventDefault();
		}
		else
		if(ctrlOrCmd && key == "o") {
			
			if(Platform.isDebug) core.openEventStream();
			else core.openState();
			e.preventDefault();
		}
		else
		if(ctrlOrCmd && key == "l") {
			
			statistics.saveStatistics()
			core.saveLogs();
			e.preventDefault();
		}
		else
		if((key == "F1" || key == "F2" || key == "F3" || key == "F4") && !ctrlOrCmd && Platform.isDebug) {
			let index = key[1] - "1"
			core.switchToPlayer(input.players[index]);
			e.preventDefault();
		}
		else
		if((key >= "1" && key <= "0") && (e.altKey || e.ctrlKey)) {
			let index = key - "0"
			if(e.altKey) { core.save(index); e.preventDefault(); } else
			if(e.ctrlKey) { core.restore(index); e.preventDefault(); }
		}
		else
		
		if(ctrlOrCmd && key == "F1") {/*keep room, keep userId, keep master*/ ServerNetwork.sendReload(false, false, true ); e.preventDefault();} else
		if(ctrlOrCmd && key == "F2") {/*keep room, keep userId, everybody*/ ServerNetwork.sendReload(false, false, false); e.preventDefault();} else
		if(ctrlOrCmd && key == "F3") {/*new room, keep userId, everybody*/ ServerNetwork.sendReload(true, false, false); e.preventDefault();} else
		if(ctrlOrCmd && key == "F4") {/*new room, new userId, everybody*/ ServerNetwork.sendReload(true, true, false); e.preventDefault();} else
		
		
		if(ctrlOrCmd && key == "F5") {core.switchSendInterval( 3); e.preventDefault();} else
		if(ctrlOrCmd && key == "F6") {core.switchSendInterval(10); e.preventDefault();} else
		if(ctrlOrCmd && key == "F7") {core.switchSendInterval(20); e.preventDefault();} else
		if(ctrlOrCmd && key == "F8") {core.switchSendInterval(30); e.preventDefault();} else
		if(ctrlOrCmd && key == "F9") {core.switchSendInterval(40); e.preventDefault();} else
			
		if(ctrlOrCmd && key == "F10") {core.switchSendInputMode(1); e.preventDefault();} else
		if(ctrlOrCmd && key == "F11") {core.switchSendInputMode(2); e.preventDefault();} else
			
		if(key == "F9") {
			if(e.shiftKey) { core.saveLogs(); }
			else { Platform.toggleDebugInfo(); }
			e.preventDefault();
		} else if(key == "F10") { 
			Platform.toggleSmallScreen();
		} else if(key == "F11") { 
			graphics.copyScreenshotToClipboard();
		} else if(key == "Alt" && input.enableClickingWithAltKey) {
			clickWithAltKeyX = pointerX; clickWithAltKeyY = pointerY;
			input.handleTouchEvent(1, clickWithAltKeyX, clickWithAltKeyY, "touch", /*pointerId*/127, /*button*/0, /*shift*/false, /*alt*/false, /*ctrl*/false);
		} else {
			let typedKey = key && key.length == 1 && !e.ctrlKey && !e.metaKey && !e.altKey? key : ""
			input.handleKeyEvent(5, keyCode, typedKey)
			if(keyCode == 9) e.preventDefault();
		}
	}
	window.onkeyup = e => {
		if(e.key == "Alt" && input.enableClickingWithAltKey) {
			input.handleTouchEvent(3, clickWithAltKeyX, clickWithAltKeyY, "touch", /*pointerId*/127, /*button*/0, /*shift*/false, /*alt*/false, /*ctrl*/false);
		} else {
			input.handleKeyEvent(6, e.keyCode)
		}
	}
		
	
	window.onpopstate = e => {
		input.handleNavigate(location.pathname);
	}
	if(!window._isWheelHandlerSet) {
		window._isWheelHandlerSet = true
		window.addEventListener('wheel', e => {
			e.preventDefault();
			e.stopPropagation();
			if(e.button == 0 && Platform.mode == 0) Platform.record();
			input.handleWheelEvent(e.pageX, e.pageY, e.deltaX, e.deltaY, e.ctrlKey)
			return false; 
		}, {passive: false})
	}
	
	if(window._input) window._input.value = ""
}
input.setLastTouchMoveIndex = function(id, index) {
	let lastMoveIndex = input.localUser.lastTouchMoveIndex;
	lastMoveIndex.push(id);
	lastMoveIndex.push(index);
}
input.getLastTouchMoveIndex = function(id) {
	let lastMoveIndex = input.localUser.lastTouchMoveIndex;
	let i = 0;
	while(i < lastMoveIndex.length) {
		if(lastMoveIndex[i] == id) {
			return lastMoveIndex[i + 1];
		}
		i += 2;
	}
	return 0;
}
input.handleTextInput = function(type, text) {
	if(core.mode == 0/*None*/ || Platform.mode != 4/*Record*/ || !(input.localUser != null) || !input.localUser.collectInputs) {
		return;
	}
	let inputs = input.localUser.inputs;
	inputs.writeInt32(input.localUser.inputFrame);
	inputs.writeUnsignedInt16(type);
	inputs.writeString(text);
}
input.handleKeyEvent = function(inputType, keyCode, key) {
	if(core.mode == 0/*None*/ || Platform.mode != 4/*Record*/ || !(input.localUser != null) || !input.localUser.collectInputs) {
		return;
	}
	let inputs = input.localUser.inputs;
	let composite = inputType;
	let controllerButton = input.controllerButtonMap.get(keyCode);
	if(controllerButton) {
		composite += (controllerButton.buttonIndex << 5);
		if(core.mode == 2/*Local*/ && !core.simulateConnection) {
			inputs = input.internalUsers[controllerButton.userId].inputs;
		}
	}
	inputs.writeInt32(input.localUser.inputFrame);
	inputs.writeUnsignedInt16(composite);
	inputs.writeInt32(keyCode);
	if(inputType == 5/*KeyDown*/) {
		inputs.writeString(key);
	}
}
input.handleTouchEvent = function(inputType, x, y, pointerType, pointerId, button, shift, alt, cmdOrCtrl) {
	let touchType = 0, id = 0;
	if(pointerType == "mouse") {
		touchType = (button < 0 ? 0 : button > 2 ? 2 : button);
	} else {
		if(pointerType == "touch") {
			touchType = 3;
			id = pointerId;
		} else {
			touchType = 4;
		}
	}
	let pixelPos = new Vector2(x * graphics.pixelRatio, y * graphics.pixelRatio, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 21528, 21574, null, null));
	let referencePos = pixelPos.getRelativeTo(graphics.baseMatrix);
	gizmo.onTouch(inputType, id, pixelPos, referencePos, shift, alt, cmdOrCtrl);
	if(core.mode == 0/*None*/ || Platform.mode != 4/*Record*/ || !(input.localUser != null) || !input.localUser.collectInputs) {
		return;
	}
	let inputs = input.localUser.inputs;
	if(inputType == 2/*TouchMove*/) {
		let index = input.getLastTouchMoveIndex(id);
		if(index) {
			inputs.dataView.setInt16(index, Math.round(referencePos.x));
			inputs.dataView.setInt16(index + 2, Math.round(referencePos.y));
			return;
		} else {
			input.setLastTouchMoveIndex(id, inputs.writePos + 6);
		}
	}
	let composite = inputType + (touchType << 5) + ((((Math.floor(Math.abs(id)) % 128) + 128) % 128) << 8);
	inputs.writeInt32(input.localUser.inputFrame);
	inputs.writeUnsignedInt16(composite);
	inputs.writeInt16(Math.round(referencePos.x));
	inputs.writeInt16(Math.round(referencePos.y));
}
input.handleUpdateTouchAfterSwitchingUser = function(id, referencePos) {
	let inputs = input.localUser.inputs;
	let composite = 2/*TouchMove*/ + (0/*Left*/ << 5) + ((((Math.floor(Math.abs(id)) % 128) + 128) % 128) << 8);
	inputs.writeInt32(input.localUser.inputFrame);
	inputs.writeUnsignedInt16(composite);
	inputs.writeInt16(Math.round(referencePos.x));
	inputs.writeInt16(Math.round(referencePos.y));
}
input.handleWheelEvent = function(x, y, deltaX, deltaY, isPinch) {
	if(core.mode == 0/*None*/ || Platform.mode != 4/*Record*/ || !(input.localUser != null) || !input.localUser.collectInputs) {
		return;
	}
	let inputs = input.localUser.inputs;
	let composite = 4/*Scroll*/ + ((isPinch ? 1 : 0) << 5);
	let referencePos = new Vector2(x * graphics.pixelRatio, y * graphics.pixelRatio, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 23671, 23717, null, null)).getRelativeTo(graphics.baseMatrix);
	inputs.writeInt32(input.localUser.inputFrame);
	inputs.writeUnsignedInt16(composite);
	inputs.writeInt16(Math.round(referencePos.x));
	inputs.writeInt16(Math.round(referencePos.y));
	inputs.writeInt16(Math.round(deltaX));
	inputs.writeInt16(Math.round(deltaY));
}
input.handleSetState = function(buffer) {
	let inputs = input.localUser.inputs;
	inputs.writeInt32(input.localUser.inputFrame);
	inputs.writeUnsignedInt16(17/*SetState*/);
	inputs.writeBuffer(buffer);
}
input.handleJoin = function(frame, account) {
	let inputs = input.localUser.inputs;
	inputs.writeInt32(frame);
	inputs.writeInt16(16/*Join*/);
	inputs.writeString(account._id);
	inputs.writeInt8(account.language);
	inputs.writeString(account.name);
	inputs.writeString(account.email);
	inputs.writeString(account.colorPreferences);
}
input.handleNavigate = function(url) {
	if(core.mode == 0/*None*/ || Platform.mode != 4/*Record*/ || !(input.localUser != null) || !input.localUser.collectInputs) {
		return;
	}
	let inputs = input.localUser.inputs;
	inputs.writeInt32(input.localUser.inputFrame);
	inputs.writeInt16(18/*Navigate*/);
	inputs.writeString(url);
}
input.handleString = function(id, data) {
	if(!data || core.mode == 0/*None*/ || core.frames > core.frame || !(input.localUser != null) || !input.localUser.collectInputs) {
		return;
	}
	let inputs = input.localUser.inputs;
	inputs.writeInt32(input.localUser.inputFrame);
	inputs.writeInt16(20/*String*/);
	inputs.writeInt(id);
	inputs.writeString(data);
}
input.handleJson = function(id, data) {
	if(!data || core.mode == 0/*None*/ || core.frames > core.frame || !(input.localUser != null) || !input.localUser.collectInputs) {
		return;
	}
	let inputs = input.localUser.inputs;
	inputs.writeInt32(input.localUser.inputFrame);
	inputs.writeInt16(21/*Json*/);
	inputs.writeInt(id);
	inputs.writeString(data);
}
input.handleObject = function(id, data) {
	let inputs = input.localUser.inputs;
	inputs.writeInt32(input.localUser.inputFrame);
	inputs.writeInt16(22/*Object*/);
	inputs.writeInt(id);
	inputs.writeString(data);
}
input.updateGameControllers = function() {
	let gamepads = navigator.getGamepads();
	if(gamepads == null) {
		return;
	}
	let gp = gamepads[0];
	if(!(gp != null) || gp.axes.length < 2) {
		return;
	}
	let isPlayStation = gp.id.includes("54c") || gp.id.includes("810");
	let axes = gp.axes;
	let leftStickX = axes[0];
	let leftStickY = axes[1];
	let buttons = ((gp.buttons[0].pressed ? 1 : 0)) + ((gp.buttons[1].pressed ? 2 : 0)) + ((gp.buttons[2].pressed ? 4 : 0)) + ((gp.buttons[3].pressed ? 8 : 0)) + ((gp.buttons[4].pressed ? 16 : 0)) + ((gp.buttons[5].pressed ? 32 : 0)) + ((gp.buttons[8].pressed ? 64 : 0)) + ((gp.buttons[9].pressed ? 128 : 0)) + ((gp.buttons[10].pressed ? 256 : 0)) + ((gp.buttons[11].pressed ? 512 : 0)) + ((gp.buttons[12].pressed ? 1024 : 0)) + ((gp.buttons[13].pressed ? 2048 : 0)) + ((gp.buttons[14].pressed ? 4096 : 0)) + ((gp.buttons[15].pressed ? 8192 : 0)) + ((isPlayStation ? 16384 : 0));
	let inputs = input.localUser.inputs;
	inputs.writeInt32(input.localUser.inputFrame);
	inputs.writeInt16(19/*GameController*/);
	inputs.writeFloat32((Math.abs(leftStickX) > GameController.deadZone ? leftStickX : 0));
	inputs.writeFloat32((Math.abs(leftStickY) > GameController.deadZone ? leftStickY : 0));
	inputs.writeUnsignedInt16(buttons);
}
input.parseInputs = function(frame) {
	for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let internalUser = _subject[i]; {
		if((internalUser != null)) {
			let inputs = internalUser.inputs;
			let userId = internalUser.id;
			let player = input.playersById[userId];
			player?.controller.startFrame();
			while(true) {
				let nextFrame = (inputs.canRead() ? inputs.dataView.getInt32(inputs.readPos) : int.maxValue);
				if(nextFrame > frame) {
					break;
				}
				inputs.readPos += 4;
				if(!(player != null)) {
					if(core.verbose && !internalUser.local) {
						core.log(("<"+internalUser.id?.toString()+"> Received first message from new user"));
					}
					input.players.push(player = new Player("", 0/*English*/, "", "", [], userId, input.players.length, null, null, 0, new Vector2(0.0, 0.0, null), false));
					input.playersById[userId] = player;
					if(internalUser.local) {
						input.localPlayer = player;
					}
					input.updatePlayers();
				}
				let value = inputs.readUnsignedInt16();
				let inputType = (((value % 32) + 32) % 32);
				if(inputType >= 1/*TouchDown*/ && inputType <= 4/*Scroll*/) {
					if(!(player != null)) {
						core.log((" ERROR: userId "+userId?.toString()+" not in playersById"));
					}
					let type = (((((value >> 5)) % 8) + 8) % 8);
					let id = (((((value >> 8)) % 128) + 128) % 128);
					let referencePos = new Vector2(inputs.readInt16(), inputs.readInt16(), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 28634, 28670, null, null));
					let isSmoothPosition = !core.smoothTouchPosition || internalUser.local || frame <= internalUser.smoothFrame;
					if(inputType == 1/*TouchDown*/) {
						let touch = player.touches.find(a => a.id == id);
						if((touch != null)) {
							touch.phase = inputType;
							touch.referencePosition.assign(referencePos);
							touch.referenceStartPosition.assign(referencePos);
							touch.type = type;
							touch.handled = false;
							if(isSmoothPosition) {
								touch.smoothPosition.assign(referencePos);
							}
						} else {
							touch = new Touch(id, player, inputType, type, referencePos, referencePos, referencePos, false, false);
							player.touches.push(touch);
						}
						player.downTouches.ensure(touch);
						player.pointerPosition.assign(referencePos);
						internalUser.downTouches.push(touch);
						if(input.generateIntegrationTest == 1/*Clicks*/) {
							input.integrationTest += "\tclick window:"+userId?.toString()+" x:"+referencePos.x.toString()+" y:"+referencePos.y.toString()+"\n";
						}
					} else {
						if(inputType == 2/*TouchMove*/) {
							let touch = player.touches.find(a => a.id == id);
							if((touch != null)) {
								if(touch.phase == 0/*Still*/) {
									touch.phase = inputType;
								}
								touch.referencePosition.assign(referencePos);
								touch.type = type;
								if(isSmoothPosition) {
									touch.smoothPosition.assign(referencePos);
								}
							} else {
								touch = new Touch(id, player, inputType, type, referencePos, new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null), referencePos, false, false);
								player.touches.push(touch);
							}
							player.pointerPosition.assign(referencePos);
							internalUser.movingTouches.push(touch);
							input.cursor = "auto";
						} else {
							if(inputType == 3/*TouchUp*/) {
								let touch = player.touches.find(a => a.id == id);
								if((touch != null)) {
									touch.phase = inputType;
									touch.referencePosition.assign(referencePos);
									touch.type = type;
									if(isSmoothPosition) {
										touch.smoothPosition.assign(referencePos);
									}
								} else {
									touch = new Touch(id, player, inputType, type, referencePos, new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null), referencePos, false, false);
									player.touches.push(touch);
								}
								player.pointerPosition.assign(referencePos);
								internalUser.upTouches.push(touch);
							} else {
								if(inputType == 4/*Scroll*/) {
									let delta = new Vector2(inputs.readInt16(), inputs.readInt16(), new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 31113, 31149, null, null));
									let isPinch = ((value >> 5)) == 1;
									internalUser.wheelEvents.push(new ScrollEvent(player.id, delta, isPinch, referencePos, false));
								}
							}
						}
					}
				} else {
					if(inputType == 7/*TextInput*/) {
						let textInput = inputs.readString();
						player.textInput = textInput;
						internalUser.textInputs.push(textInput);
					} else {
						if(inputType == 5/*KeyDown*/) {
							let key = inputs.readInt32();
							let keyPressed = inputs.readString();
							internalUser.downKeys.push(key);
							player.keysCurrentlyDown.ensure(key);
							if(keyPressed) {
								internalUser.pressedKeys.push(keyPressed);
							}
							let controllerButtonIndex = (((((value >> 5)) % 16) + 16) % 16);
							if(controllerButtonIndex) {
								player.controllerKeyDownFrame[controllerButtonIndex] = frame;
							}
						} else {
							if(inputType == 6/*KeyUp*/) {
								let key = inputs.readInt32();
								internalUser.upKeys.push(key);
								player.keysCurrentlyDown.remove(key);
								let controllerButtonIndex = (((((value >> 5)) % 16) + 16) % 16);
								if(controllerButtonIndex) {
									player.controllerKeyDownFrame[controllerButtonIndex] = 0;
								}
							} else {
								if(inputType == 18/*Navigate*/) {
									internalUser.navigations.push(inputs.readString());
								} else {
									if(inputType == 19/*GameController*/) {
										let c = player.controller;
										c.leftStick.x = inputs.readFloat32();
										c.leftStick.y = inputs.readFloat32();
										let buttons = inputs.readUnsignedInt16();
										c.a.state = ((buttons & 1)) != 0;
										c.b.state = ((buttons & 2)) != 0;
										c.x.state = ((buttons & 4)) != 0;
										c.y.state = ((buttons & 8)) != 0;
										c.type = (((buttons & 16384)) != 0 ? 2/*PlayStation*/ : 1/*Xbox*/);
										if(c.type == 1/*Xbox*/) {
											c.a.name = "A";
											c.b.name = "B";
											c.x.name = "X";
											c.y.name = "Y";
										} else {
											c.a.name = "X";
											c.b.name = "O";
											c.x.name = "SQUARE";
											c.y.name = "TRIANGLE";
										}
									} else {
										if(inputType == 20/*String*/) {
											let id = inputs.readInt();
											let valueString = inputs.readString();
											networkData.call(id, valueString);
											if(Platform.waitingForInitialData > 0) {
												Platform.waitingForInitialData--;
											}
										} else {
											if(inputType == 21/*Json*/) {
												let id = inputs.readInt();
												let valueString = inputs.readString();
												let object = (valueString ? JSON.parse(valueString) : null);
												networkData.call(id, object);
												if(Platform.waitingForInitialData > 0) {
													Platform.waitingForInitialData--;
												}
											} else {
												if(inputType == 22/*Object*/) {
													let id = inputs.readInt();
													let valueString = inputs.readString();
													let object = (valueString ? JSON.parse(valueString) : null);
													networkData.call(id, object);
													if(Platform.waitingForInitialData > 0) {
														Platform.waitingForInitialData--;
													}
												} else {
													if(inputType == 17/*SetState*/) {
														core.snapshotBuffer.reset();
														inputs.readBuffer(core.snapshotBuffer, 0);
														deserialize_internal(core.snapshotBuffer);
														math.recreateRandomValues();
														input.playersById.length = 0;
														let availableUsers = [...input.internalUsers];
														for(let i=0, _subject=input.players, _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
															let user = availableUsers.popWhere(a => a.name == player.name);
															if(!(user != null)) {
																user = availableUsers.popWhere(a => a.index == player.index);
															}
															if(!(user != null)) {
																availableUsers.pop();
															}
															player.id = user.id;
															user._id = player._id;
															user.index = player.index;
															user.name = player.name;
															input.playersById[player.id] = player;
														}}
													} else {
														if(inputType == 16/*Join*/) {
															player._id = internalUser._id = inputs.readString();
															player.language = inputs.readInt8();
															player.name = internalUser.name = inputs.readString();
															player.email = inputs.readString();
															let colorPreferencesString = inputs.readString();
															player.colorPreferences = colorPreferencesString.split(",").map((it,i) => parseInt(it));
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}}
	for(let i=0, _subject=input.players, _len=_subject.length; i<_len; ++i) { let p = _subject[i]; {
		let right = p.controllerKeyDownFrame[2/*Right*/];
		let down = p.controllerKeyDownFrame[3/*Down*/];
		let left = p.controllerKeyDownFrame[4/*Left*/];
		let up = p.controllerKeyDownFrame[1/*Up*/];
		if(right || left) {
			p.controller.leftStick.x = (right >= left ? 1 : -1);
		}
		if(down || up) {
			p.controller.leftStick.y = (down >= up ? 1 : -1);
		}
		p.controller.inMotion = Math.abs(p.controller.leftStick.x) >= GameController.deadZone || Math.abs(p.controller.leftStick.y) >= GameController.deadZone;
		for(let i=0, _subject=p.controller.buttons, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			if(p.controllerKeyDownFrame[i]) {
				it.state = true;
			}
		}}
	}}
	if(Platform.receivedInitialData) {
		Platform.waitingForInitialData -= Platform.receivedInitialData;
		Platform.receivedInitialData = 0;
	}
}
input.updatePlayers = function() {
	input.players.orderBy(a => a.id);
	for(let i=0, _subject=input.players, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		it.index = i;
		it.color = graphics.defaultColors[i];
		it.darkColor = graphics.darkDefaultColors[i];
		input.internalUsers[it.id].index = i;
	}}
	if(core.mode == 2/*Local*/ && !core.simulateConnection) {
		if(input.players.length >= 1) {
			let c = input.players[0].controller;
			if(c.type == 0/*Keyboard*/) {
				c.up.assign("↑", 38/*Up*/);
				c.right.assign("→", 39/*Right*/);
				c.down.assign("↓", 40/*Down*/);
				c.left.assign("←", 37/*Left*/);
				c.a.assign("SPACE", 32/*Space*/);
				c.b.assign("X", 88/*X*/);
			}
		}
		if(input.players.length >= 2) {
			let c = input.players[1].controller;
			if(c.type == 0/*Keyboard*/) {
				c.up.assign("W", 87/*W*/);
				c.right.assign("D", 68/*D*/);
				c.down.assign("S", 83/*S*/);
				c.left.assign("A", 65/*A*/);
				c.a.assign("F", 70/*F*/);
				c.b.assign("G", 71/*G*/);
			}
		}
		if(input.players.length >= 3) {
			let c = input.players[2].controller;
			if(c.type == 0/*Keyboard*/) {
				c.up.assign("I", 73/*I*/);
				c.right.assign("L", 76/*L*/);
				c.down.assign("K", 75/*K*/);
				c.left.assign("J", 74/*J*/);
				c.a.assign("O", 79/*O*/);
				c.b.assign("P", 80/*P*/);
			}
		}
		input.controllerButtonMap.clear();
		for(let i=0, _subject=input.players, _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
			player.controllerKeyDownFrame.length = 0;
			for(let i=0, _subject=player.controller.buttons, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
				input.controllerButtonMap.set(it.key, new ControllerButtonPlayerAndIndex(player.id, i));
				player.controllerKeyDownFrame.push(0);
			}}
		}}
	} else {
		input.controllerButtonMap.clear();
		for(let i=0, _subject=input.players, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			let c = it.controller;
			if(c.type == 0/*Keyboard*/) {
				c.up.assign("↑", 38/*Up*/);
				c.right.assign("→", 39/*Right*/);
				c.down.assign("↓", 40/*Down*/);
				c.left.assign("←", 37/*Left*/);
				c.a.assign("SPACE", 32/*Space*/);
				c.b.assign("X", 88/*X*/);
			}
		}}
		input.controllerButtonMap.clear();
		if((input.localPlayer != null)) {
			for(let i=0, _subject=input.localPlayer.controller.buttons, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
				input.controllerButtonMap.set(it.key, new ControllerButtonPlayerAndIndex(input.localPlayer.id, i));
			}}
		}
		input.controllerButtonMap.set(87/*W*/, new ControllerButtonPlayerAndIndex(input.localUser.id, 1));
		input.controllerButtonMap.set(68/*D*/, new ControllerButtonPlayerAndIndex(input.localUser.id, 2));
		input.controllerButtonMap.set(83/*S*/, new ControllerButtonPlayerAndIndex(input.localUser.id, 3));
		input.controllerButtonMap.set(65/*A*/, new ControllerButtonPlayerAndIndex(input.localUser.id, 4));
	}
}
input.getTargetedPlayers = function(by) {
	return ((by != null && by.length != 0)  && by.length > 0 && (by[0] != null) && !core.everybodyCanClickForEverybody ? by : input.players);
}
input.removePlayer = function(player) {
	if(!input.isCertain) {
		return;
	}
	core.log(("Removing player "+player.id?.toString()+" at frame "+core.frame?.toString()));
	input.playersToRemove.push(player);
}
input.removePlayersIfNecessary = function() {
	for(let i=0, _subject=input.playersToRemove, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		input.players.remove(it);
		input.playersById[it.id] = null;
		input.updatePlayers();
		let user = input.internalUsers[it.id];
		if((user != null)) {
			PeerNetwork.disconnect(user);
		}
	}}
	input.playersToRemove.length = 0;
}
input.onTouchDown = function(position, size, by, cursor, showClickableArea, markAsHandled, align, valign, $do) {
	if(!input.active) {
		return;
	}
	let sizeX = size.x;
	let sizeY = size.y || size.x;
	let x = (align == 0/*Left*/ ? position.x : (align == 1/*Center*/ ? position.x - sizeX / 2 : position.x - sizeX));
	let y = (valign == 0/*Top*/ ? position.y : (valign == 1/*Middle*/ ? position.y - sizeY / 2 : position.y - sizeY));
	let poly = [new Vector2(x, y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 41068, 41092, null, null)).transform(graphics.localMatrix), new Vector2(x + sizeX, y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 41129, 41153, null, null)).transform(graphics.localMatrix), new Vector2(x + sizeX, y + sizeY, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 41190, 41214, null, null)).transform(graphics.localMatrix), new Vector2(x, y + sizeY, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 41251, 41275, null, null)).transform(graphics.localMatrix)];
	for(let i=0, _subject=input.getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input.internalUsers[player.id].downTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
			if(!touch.handled && (player.enableTouch || touch.type != 3/*Touch*/) && touch.referencePosition.isInsidePolygon(poly)) {
				$do(touch);
				if(markAsHandled) {
					touch.handled = true;
				}
			}
		}}
	}}
	if(cursor != "auto") {
		for(let i=0, _subject=input.localUser.movingTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
			if(!touch.handled && touch.referencePosition.isInsidePolygon(poly)) {
				input.cursor = cursor;
			}
		}}
	}
	if(showClickableArea) {
		graphics.drawRectangle(position, size, new Color("#ff000080", ""), null, 0, null, 10000000, 1.0, align, valign, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 41783, 41863, null, null));
	}
}
input.onTouchDown2 = function(position, size, angle, by, cursor, showClickableArea, markAsHandled, align, valign, $do) {
	if(!input.active) {
		return;
	}
	let halfSizeX = size.x / 2;
	let halfSizeY = (size.y || size.x) / 2;
	let x = (align == 0/*Left*/ ? position.x + halfSizeX : (align == 1/*Center*/ ? position.x : position.x - halfSizeX));
	let y = (valign == 0/*Top*/ ? position.y + halfSizeY : (valign == 1/*Middle*/ ? position.y : position.y - halfSizeY));
	let poly = [new Vector2(-halfSizeX, -halfSizeY, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 43781, 43807, null, null)).rotate(angle).move2(x, y).transform(graphics.localMatrix), new Vector2(+halfSizeX, -halfSizeY, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 43868, 43894, null, null)).rotate(angle).move2(x, y).transform(graphics.localMatrix), new Vector2(+halfSizeX, +halfSizeY, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 43955, 43981, null, null)).rotate(angle).move2(x, y).transform(graphics.localMatrix), new Vector2(-halfSizeX, +halfSizeY, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 44042, 44068, null, null)).rotate(angle).move2(x, y).transform(graphics.localMatrix)];
	for(let i=0, _subject=input.getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input.internalUsers[player.id].downTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
			if(!touch.handled && (player.enableTouch || touch.type != 3/*Touch*/) && touch.referencePosition.isInsidePolygon(poly)) {
				$do(touch);
				if(markAsHandled) {
					touch.handled = true;
				}
			}
		}}
		if(cursor != "auto") {
			for(let i=0, _subject=input.localUser.movingTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
				if(!touch.handled && touch.referencePosition.isInsidePolygon(poly)) {
					input.cursor = cursor;
				}
			}}
		}
	}}
	if(showClickableArea) {
		graphics.drawPolygon(poly, new Vector2(0, 0, null), new Color("#ff000080", ""), null, 0, false, null, 10000000, 1.0);
	}
}
input.onTouchDown3 = function(position, radius, by, cursor, showClickableArea, markAsHandled, $do) {
	if(!input.active) {
		return;
	}
	let referencePosition = position.transformed(graphics.localMatrix);
	let referenceRadius = radius * graphics.localMatrix.scaleVector().x;
	for(let i=0, _subject=input.getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input.internalUsers[player.id].downTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
			if(!touch.handled && (player.enableTouch || touch.type != 3/*Touch*/) && (touch.referencePosition.distanceTo(referencePosition)) <= referenceRadius) {
				$do(touch);
				if(markAsHandled) {
					touch.handled = true;
				}
			}
		}}
		if(cursor != "auto") {
			for(let i=0, _subject=input.localUser.movingTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
				if(!touch.handled && (touch.referencePosition.distanceTo(position)) <= radius) {
					input.cursor = cursor;
				}
			}}
		}
	}}
	if(showClickableArea) {
		graphics.drawCircle(position, new Vector2(radius * 2, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 46464, 46472, null, null)), new Color("#ff0000b0", ""), null, 0, 0, 1.0, 0/*Clockwise*/, null, 10000000, 1.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 46443, 46509, null, null));
	}
}
input.onTouchDown4 = function(points, position, by, cursor, showClickableArea, markAsHandled, $do) {
	if(!input.active) {
		return;
	}
	let poly = [];
	for(let i=0, _subject=points, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		poly.push((position.plus(it)).transform(graphics.localMatrix));
	}}
	for(let i=0, _subject=input.getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input.internalUsers[player.id].downTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
			if(!touch.handled && (player.enableTouch || touch.type != 3/*Touch*/) && touch.referencePosition.isInsidePolygon(poly)) {
				$do(touch);
				if(markAsHandled) {
					touch.handled = true;
				}
			}
		}}
		if(cursor != "auto") {
			for(let i=0, _subject=input.localUser.movingTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
				if(!touch.handled && touch.referencePosition.isInsidePolygon(poly)) {
					input.cursor = cursor;
				}
			}}
		}
	}}
	if(showClickableArea) {
		graphics.drawPolygon(points, position, new Color("#ff0000b0", ""), null, 0, false, null, 10000000, 1.0);
	}
}
input.onTouchDown5 = function(by, markAsHandled, $do) {
	for(let i=0, _subject=input.getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input.internalUsers[player.id].downTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
			if(!touch.handled && (player.enableTouch || touch.type != 3/*Touch*/)) {
				$do(touch);
				if(markAsHandled) {
					touch.handled = true;
				}
			}
		}}
	}}
}
input.onTouchDownAny = function(by, $do) {
	if(!input.active) {
		return;
	}
	for(let i=0, _subject=input.getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input.internalUsers[player.id].downTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
			if(player.enableTouch || touch.type != 3/*Touch*/) {
				$do(touch);
			}
		}}
	}}
}
input.onTouchOver = function(position, size, by, cursor, showClickableArea, markAsHandled, align, valign, $do) {
	if(!input.active) {
		return;
	}
	let sizeX = size.x;
	let sizeY = size.y || size.x;
	let x = (align == 0/*Left*/ ? position.x : (align == 1/*Center*/ ? position.x - sizeX / 2 : position.x - sizeX));
	let y = (valign == 0/*Top*/ ? position.y : (valign == 1/*Middle*/ ? position.y - sizeY / 2 : position.y - sizeY));
	let poly = [new Vector2(x, y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 51791, 51815, null, null)).transform(graphics.localMatrix), new Vector2(x + sizeX, y, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 51852, 51876, null, null)).transform(graphics.localMatrix), new Vector2(x + sizeX, y + sizeY, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 51913, 51937, null, null)).transform(graphics.localMatrix), new Vector2(x, y + sizeY, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 51974, 51998, null, null)).transform(graphics.localMatrix)];
	for(let i=0, _subject=input.getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=player.touches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
			if(touch.referencePosition.isInsidePolygon(poly)) {
				$do(touch);
			}
		}}
		if(cursor != "auto") {
			for(let i=0, _subject=input.localUser.movingTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
				if(!touch.handled && touch.referencePosition.isInsidePolygon(poly)) {
					input.cursor = cursor;
				}
			}}
		}
	}}
	if(showClickableArea) {
		graphics.drawRectangle(position, size, new Color("#ff000080", ""), null, 0, null, 0, 1.0, 1/*Center*/, 1/*Middle*/, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 52372, 52421, null, null));
	}
}
input.onTouchMove = function(touch, triggeredOnTouchDown, $do) {
	if(!(touch != null) || !input.active) {
		return;
	}
	let touchId = touch.id;
	let user = input.internalUsers[touch.by.id];
	if((user != null)) {
		if(triggeredOnTouchDown) {
			for(let i=0, _subject=user.downTouches, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
				if(it.id == touchId) {
					$do(it);
				}
			}}
		}
		for(let i=0, _subject=user.movingTouches, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			if(it.id == touchId) {
				$do(it);
			}
		}}
	}
}
input.onTouchMove2 = function(by, triggeredOnTouchDown, $do) {
	if(!input.active) {
		return;
	}
	for(let i=0, _subject=input.getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let user = input.internalUsers[it.id];
		if((user != null)) {
			if(triggeredOnTouchDown) {
				for(let i=0, _subject=user.downTouches, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
					$do(it);
				}}
			}
			for(let i=0, _subject=user.movingTouches, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
				$do(it);
			}}
		}
	}}
}
input.onTouchUp = function(touch, markAsHandled, $do) {
	if(!(touch != null) || !input.active) {
		return;
	}
	let touchId = touch.id;
	let user = input.internalUsers[touch.by.id];
	if((user != null)) {
		for(let i=0, _subject=user.upTouches, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			if(it.id == touchId) {
				$do(it);
				Snapshot.autoSave();
				if(markAsHandled) {
					it.handled = true;
				}
			}
		}}
	}
}
input.onTouchUp2 = function(by, markAsHandled, $do) {
	if(!input.active) {
		return;
	}
	for(let i=0, _subject=input.getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		for(let i=0, _subject=input.internalUsers[it.id].upTouches, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			if(!it.handled) {
				$do(it);
				Snapshot.autoSave();
			}
		}}
	}}
}
input.onTouchUp3 = function(position, size, by, showClickableArea, markAsHandled, $do) {
	if(!input.active) {
		return;
	}
	let poly = [new Vector2(position.x - size.x / 2, position.y - size.y / 2, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 58286, 58330, null, null)).transform(graphics.localMatrix), new Vector2(position.x + size.x / 2, position.y - size.y / 2, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 58367, 58411, null, null)).transform(graphics.localMatrix), new Vector2(position.x + size.x / 2, position.y + size.y / 2, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 58448, 58492, null, null)).transform(graphics.localMatrix), new Vector2(position.x - size.x / 2, position.y + size.y / 2, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 58529, 58573, null, null)).transform(graphics.localMatrix)];
	for(let i=0, _subject=input.getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input.internalUsers[player.id].upTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
			if(!touch.handled && touch.referencePosition.isInsidePolygon(poly)) {
				$do(touch);
				if(markAsHandled) {
					touch.handled = true;
				}
				Snapshot.autoSave();
			}
		}}
	}}
	if(showClickableArea) {
		graphics.drawRectangle(position, size, new Color("#ff000080", ""), null, 0, null, 0, 1.0, 1/*Center*/, 1/*Middle*/, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 58884, 58933, null, null));
	}
}
input.onTouchUp4 = function(position, radius, by, cursor, showClickableArea, markAsHandled, $do) {
	if(!input.active) {
		return;
	}
	let referencePosition = position.transform(graphics.localMatrix);
	let referenceRadius = radius * graphics.localMatrix.scaleVector().x;
	for(let i=0, _subject=input.getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input.internalUsers[player.id].upTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
			if(!touch.handled && (touch.referencePosition.distanceTo(referencePosition)) <= referenceRadius) {
				$do(touch);
				if(markAsHandled) {
					touch.handled = true;
				}
				Snapshot.autoSave();
			}
		}}
		if(cursor != "auto") {
			for(let i=0, _subject=input.localUser.movingTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
				if(!touch.handled && (touch.referencePosition.distanceTo(position)) <= radius) {
					input.cursor = cursor;
				}
			}}
		}
	}}
	if(showClickableArea) {
		graphics.drawCircle(position, new Vector2(radius * 2, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 60738, 60746, null, null)), new Color("#ff000080", ""), null, 0, 0, 1.0, 0/*Clockwise*/, null, 0, 1.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 60717, 60767, null, null));
	}
}
input.onScroll = function(by, $do) {
	if(!input.active) {
		return;
	}
	for(let i=0, _subject=input.getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		for(let i=0, _subject=input.internalUsers[it.id].wheelEvents, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			$do(it);
		}}
	}}
}
input.onScrolllWithin = function(position, size, by, showClickableArea, markAsHandled, $do) {
	if(!input.active) {
		return;
	}
	let poly = [new Vector2(position.x - size.x / 2, position.y - size.y / 2, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 61981, 62025, null, null)).transform(graphics.localMatrix), new Vector2(position.x + size.x / 2, position.y - size.y / 2, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 62062, 62106, null, null)).transform(graphics.localMatrix), new Vector2(position.x + size.x / 2, position.y + size.y / 2, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 62143, 62187, null, null)).transform(graphics.localMatrix), new Vector2(position.x - size.x / 2, position.y + size.y / 2, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 62224, 62268, null, null)).transform(graphics.localMatrix)];
	for(let i=0, _subject=input.getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		for(let i=0, _subject=input.internalUsers[it.id].wheelEvents, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			if(!it.handled && it.referencePosition.isInsidePolygon(poly)) {
				$do(it);
				if(markAsHandled) {
					it.markAsHandled();
				}
			}
		}}
	}}
	if(showClickableArea) {
		graphics.drawRectangle(position, size, Color.Red, null, 0, null, 0, 1.0, 1/*Center*/, 1/*Middle*/, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/play/input.l", 62513, 62546, null, null));
	}
}
input.getOrCreateInputField = function() {
	if(!window._input) {
		window._input = document.createElement("input")
		_input.type = "text"
		_input.style.position = "absolute"
		_input.style.left = "-10000px" 
		_input.style.width = "1px"
		_input.style.height = "1px"
		_input.style.fontSize = "1px"
		_input.style.backgroundColor = "#000000"
		_input.oninput = e => input.handleTextInput(7, _input.value)
		_input.onblur = e => {
			if(input.isTextInputActive) {
				_input.focus()
			}
		}
		document.body.appendChild(_input)
	}
	return _input
}
input.startTextInput = function(initalValue, forUser) {
	if(forUser == -1 || input.localUser?.id == forUser) {
		let field = input.getOrCreateInputField()
		if(initalValue != null) { 
			field.value = initalValue
		}
		_input.focus()
		field.isTextInputActive = true
	}
}
input.stopTextInput = function() {
	input.isTextInputActive = false
}
input.setTextInput = function(value) {
	let field = input.getOrCreateInputField()
	field.value = value
	field.handleTextInput(7, value)
}
input.updateCursor = function() {
	
	document.body.style.cursor = input.cursor
}
input.onTextComposition = function($do) {
	for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let user = _subject[i]; {
		if((user != null)) {
			for(let i=0, _subject=user.textCompositions, _len=_subject.length; i<_len; ++i) { let characters = _subject[i]; {
				$do(characters);
			}}
		}
	}}
}
input.onTextInput = function(by, $do) {
	for(let i=0, _subject=input.getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		for(let i=0, _subject=input.internalUsers[it.id].textInputs, _len=_subject.length; i<_len; ++i) { let textInput = _subject[i]; {
			$do(textInput);
		}}
	}}
}
input.onKeyDown = function(modifier, key, by, $do) {
	for(let i=0, _subject=input.getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input.internalUsers[player.id].downKeys, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			if(it == key) {
				let actualCmdOrCtrl = false, actualShift = false, actualAlt = false;
				for(let i=0, _subject=player.keysCurrentlyDown, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
					switch(it) {
						case 91/*LeftMetaKey*/: {
							actualCmdOrCtrl = true;
						} break;
						case 92/*RightMetaKey*/: {
							actualCmdOrCtrl = true;
						} break;
						case 17/*Ctrl*/: {
							actualCmdOrCtrl = true;
						} break;
						case 18/*Alt*/: {
							actualAlt = true;
						} break;
						case 16/*Shift*/: {
							actualShift = true;
						} break;
					}
				}}
				if((modifier == 17/*CmdOrCtrl*/ && actualCmdOrCtrl && !actualShift && !actualAlt) || (modifier == 16/*Shift*/ && actualShift && !actualCmdOrCtrl && !actualAlt) || (modifier == 18/*Alt*/ && actualAlt && !actualCmdOrCtrl && !actualShift)) {
					$do(key, player, actualCmdOrCtrl, actualAlt, actualShift);
				}
			}
		}}
	}}
}
input.onKeyDown2 = function(key, cmdOrCtrl, alt, shift, by, $do) {
	for(let i=0, _subject=input.getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input.internalUsers[player.id].downKeys, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			if(it == key) {
				let actualCmdOrCtrl = false, actualShift = false, actualAlt = false;
				for(let i=0, _subject=player.keysCurrentlyDown, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
					switch(it) {
						case 91/*LeftMetaKey*/: {
							actualCmdOrCtrl = true;
						} break;
						case 92/*RightMetaKey*/: {
							actualCmdOrCtrl = true;
						} break;
						case 17/*Ctrl*/: {
							actualCmdOrCtrl = true;
						} break;
						case 18/*Alt*/: {
							actualAlt = true;
						} break;
						case 16/*Shift*/: {
							actualShift = true;
						} break;
					}
				}}
				if(actualCmdOrCtrl == cmdOrCtrl && actualShift == shift && actualAlt == alt) {
					$do(key, player, actualCmdOrCtrl, actualAlt, actualShift);
				}
			}
		}}
	}}
}
input.onKeyDown3 = function(by, $do) {
	for(let i=0, _subject=input.getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input.internalUsers[player.id].downKeys, _len=_subject.length; i<_len; ++i) { let key = _subject[i]; {
			let actualCmdOrCtrl = false, actualShift = false, actualAlt = false;
			for(let i=0, _subject=player.keysCurrentlyDown, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
				switch(it) {
					case 91/*LeftMetaKey*/: {
						actualCmdOrCtrl = true;
					} break;
					case 92/*RightMetaKey*/: {
						actualCmdOrCtrl = true;
					} break;
					case 17/*Ctrl*/: {
						actualCmdOrCtrl = true;
					} break;
					case 18/*Alt*/: {
						actualAlt = true;
					} break;
					case 16/*Shift*/: {
						actualShift = true;
					} break;
				}
			}}
			$do(key, player, actualCmdOrCtrl, actualAlt, actualShift);
		}}
	}}
}
input.onKeyUp = function(by, $do) {
	for(let i=0, _subject=input.getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input.internalUsers[player.id].upKeys, _len=_subject.length; i<_len; ++i) { let key = _subject[i]; {
			$do(key, player);
		}}
	}}
}
input.onType = function(by, $do) {
	for(let i=0, _subject=input.getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input.internalUsers[player.id].pressedKeys, _len=_subject.length; i<_len; ++i) { let character = _subject[i]; {
			$do(character, player);
		}}
	}}
}
input.isKeyDown = function(key, by) {
	if((core.mode == 3/*Connected*/ || core.simulateConnection) && (by != null)) {
		let player = input.playersById[by.id];
		if((player != null)) {
			return player.keysCurrentlyDown.includes(key);
		}
	} else {
		return input.players.some(a => a.keysCurrentlyDown.includes(key));
	}
	return false;
}
input.onNavigate = function(by, $do) {
	for(let i=0, _subject=input.getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input.internalUsers[player.id].navigations, _len=_subject.length; i<_len; ++i) { let url = _subject[i]; {
			$do(url);
		}}
	}}
}
function input_serialize_internal(buffer) {
	let _players = input.players
	if(_players) {
		var index = _objectCacheIndex.get(_players);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_players, index = _objectCache.length);
			_objectCache.push(_players);
			buffer.writeInt32(-index);
			_players._objectIndex = index;
			buffer.writeInt32(_players.length);
			for(let i=0, len=_players.length; i<len; ++i) {
				let _players_item = _players[i]
				if(_players_item) {
					var index = _objectCacheIndex.get(_players_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_players_item, index = _objectCache.length);
						_objectCache.push(_players_item);
						buffer.writeInt32(-index);
						_players_item._objectIndex = index;
						_players_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeBool(input.active);
	let _host = input.host
	if(_host) {
		var index = _objectCacheIndex.get(_host);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_host, index = _objectCache.length);
			_objectCache.push(_host);
			buffer.writeInt32(-index);
			_host._objectIndex = index;
			_host.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let _showPerspectiveOf = input.showPerspectiveOf
	if(_showPerspectiveOf) {
		var index = _objectCacheIndex.get(_showPerspectiveOf);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_showPerspectiveOf, index = _objectCache.length);
			_objectCache.push(_showPerspectiveOf);
			buffer.writeInt32(-index);
			_showPerspectiveOf._objectIndex = index;
			_showPerspectiveOf.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let _playersById = input.playersById
	if(_playersById) {
		var index = _objectCacheIndex.get(_playersById);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_playersById, index = _objectCache.length);
			_objectCache.push(_playersById);
			buffer.writeInt32(-index);
			_playersById._objectIndex = index;
			buffer.writeInt32(_playersById.length);
			for(let i=0, len=_playersById.length; i<len; ++i) {
				let _playersById_item = _playersById[i]
				if(_playersById_item) {
					var index = _objectCacheIndex.get(_playersById_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_playersById_item, index = _objectCache.length);
						_objectCache.push(_playersById_item);
						buffer.writeInt32(-index);
						_playersById_item._objectIndex = index;
						_playersById_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeString(input.cursor);
	buffer.writeBool(input.showPointers);
	buffer.writeInt32(input.showPointersMode);
	buffer.writeInt32(input.showPointersDuringPlaybackMode);
	buffer.writeBool(input.enableClickingWithAltKey);
	buffer.writeBool(input.ignoreFirstClick);
	buffer.writeInt32(input.generateIntegrationTest);
	buffer.writeString(input.integrationTest);
	let _playersToRemove = input.playersToRemove
	if(_playersToRemove) {
		var index = _objectCacheIndex.get(_playersToRemove);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_playersToRemove, index = _objectCache.length);
			_objectCache.push(_playersToRemove);
			buffer.writeInt32(-index);
			_playersToRemove._objectIndex = index;
			buffer.writeInt32(_playersToRemove.length);
			for(let i=0, len=_playersToRemove.length; i<len; ++i) {
				let _playersToRemove_item = _playersToRemove[i]
				if(_playersToRemove_item) {
					var index = _objectCacheIndex.get(_playersToRemove_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_playersToRemove_item, index = _objectCache.length);
						_objectCache.push(_playersToRemove_item);
						buffer.writeInt32(-index);
						_playersToRemove_item._objectIndex = index;
						_playersToRemove_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeBool(input.isTextInputActive);
}
function input_deserialize_internal(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		input.players = _objectCache[index];
	} else {
		let _players = input.players
		if(!_players || _players._objectIndex != -index) input.players = _players = [];
		_objectCache[-index] = _players;
		for(let i=0, len = _players.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_players[i] = _objectCache[index];
				} else {
					let _players_item = _players[i]
					if(!_players_item || _players_item._objectIndex != -index)
						_players[i] = _players_item = new _Player();
					(_objectCache[-index] = _players_item).deserialize_internal(buffer);
				}
		}
	}
	input.active = buffer.readBool();
	var index = buffer.readInt32();
	if(index >= 0) {
		input.host = _objectCache[index];
	} else {
		let _host = input.host
		if(!_host || _host._objectIndex != -index)
			input.host = _host = new _Player();
		(_objectCache[-index] = _host).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		input.showPerspectiveOf = _objectCache[index];
	} else {
		let _showPerspectiveOf = input.showPerspectiveOf
		if(!_showPerspectiveOf || _showPerspectiveOf._objectIndex != -index)
			input.showPerspectiveOf = _showPerspectiveOf = new _Player();
		(_objectCache[-index] = _showPerspectiveOf).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		input.playersById = _objectCache[index];
	} else {
		let _playersById = input.playersById
		if(!_playersById || _playersById._objectIndex != -index) input.playersById = _playersById = [];
		_objectCache[-index] = _playersById;
		for(let i=0, len = _playersById.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_playersById[i] = _objectCache[index];
				} else {
					let _playersById_item = _playersById[i]
					if(!_playersById_item || _playersById_item._objectIndex != -index)
						_playersById[i] = _playersById_item = new _Player();
					(_objectCache[-index] = _playersById_item).deserialize_internal(buffer);
				}
		}
	}
	input.cursor = buffer.readString();
	input.showPointers = buffer.readBool();
	input.showPointersMode = buffer.readInt32();
	input.showPointersDuringPlaybackMode = buffer.readInt32();
	input.enableClickingWithAltKey = buffer.readBool();
	input.ignoreFirstClick = buffer.readBool();
	input.generateIntegrationTest = buffer.readInt32();
	input.integrationTest = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		input.playersToRemove = _objectCache[index];
	} else {
		let _playersToRemove = input.playersToRemove
		if(!_playersToRemove || _playersToRemove._objectIndex != -index) input.playersToRemove = _playersToRemove = [];
		_objectCache[-index] = _playersToRemove;
		for(let i=0, len = _playersToRemove.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_playersToRemove[i] = _objectCache[index];
				} else {
					let _playersToRemove_item = _playersToRemove[i]
					if(!_playersToRemove_item || _playersToRemove_item._objectIndex != -index)
						_playersToRemove[i] = _playersToRemove_item = new _Player();
					(_objectCache[-index] = _playersToRemove_item).deserialize_internal(buffer);
				}
		}
	}
	input.isTextInputActive = buffer.readBool();
}
function input_serialize_external(buffer) {
	buffer.writeString("players");
	let _players = input.players
	let _players_startPos = buffer.reserveSize();
	if(_players) {
		var index = _objectCacheIndex.get(_players);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_players, index = _objectCache.length);
			_objectCache.push(_players);
			buffer.writeInt32(-index);
			_players._objectIndex = index;
			buffer.writeInt32(_players.length);
			for(let i=0, len=_players.length; i<len; ++i) {
				let _players_item = _players[i]
				if(_players_item) {
					var index = _objectCacheIndex.get(_players_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_players_item, index = _objectCache.length);
						_objectCache.push(_players_item);
						buffer.writeInt32(-index);
						_players_item._objectIndex = index;
						_players_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_players_startPos);
	buffer.writeString("active");
	buffer.writeInt32(1);
	buffer.writeBool(input.active);
	buffer.writeString("host");
	let _host_startPos = buffer.reserveSize();
	let _host = input.host
	if(_host) {
		var index = _objectCacheIndex.get(_host);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_host, index = _objectCache.length);
			_objectCache.push(_host);
			buffer.writeInt32(-index);
			_host._objectIndex = index;
			_host.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_host_startPos);
	buffer.writeString("showPerspectiveOf");
	let _showPerspectiveOf_startPos = buffer.reserveSize();
	let _showPerspectiveOf = input.showPerspectiveOf
	if(_showPerspectiveOf) {
		var index = _objectCacheIndex.get(_showPerspectiveOf);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_showPerspectiveOf, index = _objectCache.length);
			_objectCache.push(_showPerspectiveOf);
			buffer.writeInt32(-index);
			_showPerspectiveOf._objectIndex = index;
			_showPerspectiveOf.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_showPerspectiveOf_startPos);
	buffer.writeString("playersById");
	let _playersById = input.playersById
	let _playersById_startPos = buffer.reserveSize();
	if(_playersById) {
		var index = _objectCacheIndex.get(_playersById);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_playersById, index = _objectCache.length);
			_objectCache.push(_playersById);
			buffer.writeInt32(-index);
			_playersById._objectIndex = index;
			buffer.writeInt32(_playersById.length);
			for(let i=0, len=_playersById.length; i<len; ++i) {
				let _playersById_item = _playersById[i]
				if(_playersById_item) {
					var index = _objectCacheIndex.get(_playersById_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_playersById_item, index = _objectCache.length);
						_objectCache.push(_playersById_item);
						buffer.writeInt32(-index);
						_playersById_item._objectIndex = index;
						_playersById_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_playersById_startPos);
	buffer.writeString("cursor");
	buffer.writeString(input.cursor);
	buffer.writeString("showPointers");
	buffer.writeInt32(1);
	buffer.writeBool(input.showPointers);
	buffer.writeString("showPointersMode");
	buffer.writeInt32(4);
	buffer.writeInt32(input.showPointersMode);
	buffer.writeString("showPointersDuringPlaybackMode");
	buffer.writeInt32(4);
	buffer.writeInt32(input.showPointersDuringPlaybackMode);
	buffer.writeString("enableClickingWithAltKey");
	buffer.writeInt32(1);
	buffer.writeBool(input.enableClickingWithAltKey);
	buffer.writeString("ignoreFirstClick");
	buffer.writeInt32(1);
	buffer.writeBool(input.ignoreFirstClick);
	buffer.writeString("generateIntegrationTest");
	buffer.writeInt32(4);
	buffer.writeInt32(input.generateIntegrationTest);
	buffer.writeString("integrationTest");
	buffer.writeString(input.integrationTest);
	buffer.writeString("playersToRemove");
	let _playersToRemove = input.playersToRemove
	let _playersToRemove_startPos = buffer.reserveSize();
	if(_playersToRemove) {
		var index = _objectCacheIndex.get(_playersToRemove);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_playersToRemove, index = _objectCache.length);
			_objectCache.push(_playersToRemove);
			buffer.writeInt32(-index);
			_playersToRemove._objectIndex = index;
			buffer.writeInt32(_playersToRemove.length);
			for(let i=0, len=_playersToRemove.length; i<len; ++i) {
				let _playersToRemove_item = _playersToRemove[i]
				if(_playersToRemove_item) {
					var index = _objectCacheIndex.get(_playersToRemove_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_playersToRemove_item, index = _objectCache.length);
						_objectCache.push(_playersToRemove_item);
						buffer.writeInt32(-index);
						_playersToRemove_item._objectIndex = index;
						_playersToRemove_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_playersToRemove_startPos);
	buffer.writeString("isTextInputActive");
	buffer.writeInt32(1);
	buffer.writeBool(input.isTextInputActive);
	buffer.writeString("");
}
function input_deserialize_external(buffer) {
	let players_is_set = false, active_is_set = false, host_is_set = false, showPerspectiveOf_is_set = false, playersById_is_set = false, cursor_is_set = false, showPointers_is_set = false, showPointersMode_is_set = false, showPointersDuringPlaybackMode_is_set = false, enableClickingWithAltKey_is_set = false, ignoreFirstClick_is_set = false, generateIntegrationTest_is_set = false, integrationTest_is_set = false, playersToRemove_is_set = false, isTextInputActive_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "players":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					input.players = _objectCache[index];
				} else {
					let _players = input.players
					if(!_players || _players._objectIndex != -index) input.players = _players = [];
					_objectCache[-index] = _players;
					for(let i=0, len = _players.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_players[i] = _objectCache[index];
							} else {
								let _players_item = _players[i]
								if(!_players_item || _players_item._objectIndex != -index)
									_players[i] = _players_item = new _Player();
								(_objectCache[-index] = _players_item).deserialize_external(buffer);
							}
					}
				}
				players_is_set = true;
				break;
			case "active":
				buffer.readInt32();
				input.active = buffer.readBool();
				active_is_set = true;
				break;
			case "host":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					input.host = _objectCache[index];
				} else {
					let _host = input.host
					if(!_host || _host._objectIndex != -index)
						input.host = _host = new _Player();
					(_objectCache[-index] = _host).deserialize_external(buffer);
				}
				host_is_set = true;
				break;
			case "showPerspectiveOf":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					input.showPerspectiveOf = _objectCache[index];
				} else {
					let _showPerspectiveOf = input.showPerspectiveOf
					if(!_showPerspectiveOf || _showPerspectiveOf._objectIndex != -index)
						input.showPerspectiveOf = _showPerspectiveOf = new _Player();
					(_objectCache[-index] = _showPerspectiveOf).deserialize_external(buffer);
				}
				showPerspectiveOf_is_set = true;
				break;
			case "playersById":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					input.playersById = _objectCache[index];
				} else {
					let _playersById = input.playersById
					if(!_playersById || _playersById._objectIndex != -index) input.playersById = _playersById = [];
					_objectCache[-index] = _playersById;
					for(let i=0, len = _playersById.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_playersById[i] = _objectCache[index];
							} else {
								let _playersById_item = _playersById[i]
								if(!_playersById_item || _playersById_item._objectIndex != -index)
									_playersById[i] = _playersById_item = new _Player();
								(_objectCache[-index] = _playersById_item).deserialize_external(buffer);
							}
					}
				}
				playersById_is_set = true;
				break;
			case "cursor":
				input.cursor = buffer.readString();
				cursor_is_set = true;
				break;
			case "showPointers":
				buffer.readInt32();
				input.showPointers = buffer.readBool();
				showPointers_is_set = true;
				break;
			case "showPointersMode":
				buffer.readInt32();
				input.showPointersMode = buffer.readInt32();
				showPointersMode_is_set = true;
				break;
			case "showPointersDuringPlaybackMode":
				buffer.readInt32();
				input.showPointersDuringPlaybackMode = buffer.readInt32();
				showPointersDuringPlaybackMode_is_set = true;
				break;
			case "enableClickingWithAltKey":
				buffer.readInt32();
				input.enableClickingWithAltKey = buffer.readBool();
				enableClickingWithAltKey_is_set = true;
				break;
			case "ignoreFirstClick":
				buffer.readInt32();
				input.ignoreFirstClick = buffer.readBool();
				ignoreFirstClick_is_set = true;
				break;
			case "generateIntegrationTest":
				buffer.readInt32();
				input.generateIntegrationTest = buffer.readInt32();
				generateIntegrationTest_is_set = true;
				break;
			case "integrationTest":
				input.integrationTest = buffer.readString();
				integrationTest_is_set = true;
				break;
			case "playersToRemove":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					input.playersToRemove = _objectCache[index];
				} else {
					let _playersToRemove = input.playersToRemove
					if(!_playersToRemove || _playersToRemove._objectIndex != -index) input.playersToRemove = _playersToRemove = [];
					_objectCache[-index] = _playersToRemove;
					for(let i=0, len = _playersToRemove.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_playersToRemove[i] = _objectCache[index];
							} else {
								let _playersToRemove_item = _playersToRemove[i]
								if(!_playersToRemove_item || _playersToRemove_item._objectIndex != -index)
									_playersToRemove[i] = _playersToRemove_item = new _Player();
								(_objectCache[-index] = _playersToRemove_item).deserialize_external(buffer);
							}
					}
				}
				playersToRemove_is_set = true;
				break;
			case "isTextInputActive":
				buffer.readInt32();
				input.isTextInputActive = buffer.readBool();
				isTextInputActive_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!players_is_set) input.players = [];
				if(!active_is_set) input.active = true;
				if(!host_is_set) input.host = null;
				if(!showPerspectiveOf_is_set) input.showPerspectiveOf = null;
				if(!playersById_is_set) input.playersById = [];
				if(!cursor_is_set) input.cursor = "pointer";
				if(!showPointers_is_set) input.showPointers = true;
				if(!showPointersMode_is_set) input.showPointersMode = 2/*Remote*/;
				if(!showPointersDuringPlaybackMode_is_set) input.showPointersDuringPlaybackMode = 3/*LocalAndRemote*/;
				if(!enableClickingWithAltKey_is_set) input.enableClickingWithAltKey = false;
				if(!ignoreFirstClick_is_set) input.ignoreFirstClick = false;
				if(!generateIntegrationTest_is_set) input.generateIntegrationTest = 0/*None*/;
				if(!integrationTest_is_set) input.integrationTest = "";
				if(!playersToRemove_is_set) input.playersToRemove = [];
				if(!isTextInputActive_is_set) input.isTextInputActive = false;
				return;
		}
	}
}
var networkData; if(!networkData) networkData = {};
networkData.init = function() {
	networkData.callbacks = [];
}
networkData.call = function(id, data) {
	networkData.callbacks[id].invoke(data);
}
networkData.addCallback = function($do) {
	let id = networkData.callbacks.length;
	networkData.callbacks.push($do);
	return id;
}
function networkData_serialize_internal(buffer) {
	let _callbacks = networkData.callbacks
	if(_callbacks) {
		var index = _objectCacheIndex.get(_callbacks);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_callbacks, index = _objectCache.length);
			_objectCache.push(_callbacks);
			buffer.writeInt32(-index);
			_callbacks._objectIndex = index;
			buffer.writeInt32(_callbacks.length);
			for(let i=0, len=_callbacks.length; i<len; ++i) {
				let _callbacks_item = _callbacks[i]
				if(_callbacks_item) {
					var index = _objectCacheIndex.get(_callbacks_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_callbacks_item, index = _objectCache.length);
						_objectCache.push(_callbacks_item);
						buffer.writeInt32(-index);
						buffer.writeInt32(_callbacks_item._id);
						_callbacks_item._objectIndex = index;
						_callbacks_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
function networkData_deserialize_internal(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		networkData.callbacks = _objectCache[index];
	} else {
		let _callbacks = networkData.callbacks
		if(!_callbacks || _callbacks._objectIndex != -index) networkData.callbacks = _callbacks = [];
		_objectCache[-index] = _callbacks;
		for(let i=0, len = _callbacks.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					_callbacks[i] = _objectCache[index];
				} else {
					let _callbacks_item = _callbacks[i]
					let _id = buffer.readInt32();
					if(!_callbacks_item || _callbacks_item._id != _id || _callbacks_item._objectIndex != -index)
						_callbacks[i] = _callbacks_item = new _lambdaContructors[_id]();
					_callbacks_item._id = _id;
					(_objectCache[-index] = _callbacks_item).deserialize_internal(buffer);
				}
		}
	}
}
function networkData_serialize_external(buffer) {
	buffer.writeString("callbacks");
	let _callbacks = networkData.callbacks
	let _callbacks_startPos = buffer.reserveSize();
	if(_callbacks) {
		var index = _objectCacheIndex.get(_callbacks);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_callbacks, index = _objectCache.length);
			_objectCache.push(_callbacks);
			buffer.writeInt32(-index);
			_callbacks._objectIndex = index;
			buffer.writeInt32(_callbacks.length);
			for(let i=0, len=_callbacks.length; i<len; ++i) {
				let _callbacks_item = _callbacks[i]
				if(_callbacks_item) {
					var index = _objectCacheIndex.get(_callbacks_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(_callbacks_item, index = _objectCache.length);
						_objectCache.push(_callbacks_item);
						buffer.writeInt32(-index);
						buffer.writeInt32(_callbacks_item._id);
						_callbacks_item._objectIndex = index;
						_callbacks_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_callbacks_startPos);
	buffer.writeString("");
}
function networkData_deserialize_external(buffer) {
	let callbacks_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "callbacks":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					networkData.callbacks = _objectCache[index];
				} else {
					let _callbacks = networkData.callbacks
					if(!_callbacks || _callbacks._objectIndex != -index) networkData.callbacks = _callbacks = [];
					_objectCache[-index] = _callbacks;
					for(let i=0, len = _callbacks.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								_callbacks[i] = _objectCache[index];
							} else {
								let _callbacks_item = _callbacks[i]
								let _id = buffer.readInt32();
								if(!_callbacks_item || _callbacks_item._id != _id || _callbacks_item._objectIndex != -index)
									_callbacks[i] = _callbacks_item = new _lambdaContructors[_id]();
								_callbacks_item._id = _id;
								(_objectCache[-index] = _callbacks_item).deserialize_external(buffer);
							}
					}
				}
				callbacks_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!callbacks_is_set) networkData.callbacks = [];
				return;
		}
	}
}
var storage; if(!storage) storage = {};
storage.get = function(key, of, $do) {
	let id = networkData.addCallback($do);
	if(core.isPremiere && input.isCertain && input.internalUsers[of.id]?.local) {
		let data = (localStorage.getItem(key) || "");
		input.handleObject(id, data);
	}
}
storage.getObjectDirectly = function(key) {
	try {
		let data = localStorage.getItem(key)
		if(!data) return {}
		return JSON.parse(data)
	} catch {
		return {}
	}
}
var http; if(!http) http = {};
http.get = async function(url, code) {
	let id = networkData.addCallback(code)
	if(core.frame == 0 || Platform.waitingForInitialData) Platform.waitingForInitialData++
	if(core.isPremiere && input.isCertain) {
		let data = await (await fetch(url)).text()
		log("http.get "+url+" -> "+data?.length+" bytes")
		input.handleObject(id, data, 1)
	}
}
http.getString = async function(url, storeForDeterministicReplay, code) {
	if(core.frame == 0 || Platform.waitingForInitialData) {
		Platform.waitingForInitialData++
		log("getString: "+url)
	}
	if(storeForDeterministicReplay) {
		let id = networkData.addCallback(code)
		if(core.isPremiere && input.isCertain) {
			let data = await (await fetch(url)).text()
			input.handleString(id, data, 1)
		}
	} else {
		if(core.isPremiere && input.isCertain) {
			let data = await (await fetch(url)).text()
			log("received: "+url)
			code.invoke(data)
			if(Platform.waitingForInitialData > 0) Platform.receivedInitialData++
		}
	}
}
http.postStreamDirectly = async function(url, body, onData, onEnd) {
	if(!core.isPremiere || !input.isCertain) return
	try {
		let response = await fetch(url, {method:"POST", body:JSON.stringify(body)})
		let reader = response.body.getReader();
		let decoder = new TextDecoder();
		let cancelled = false
		function cancel() { cancelled = true; }
		for(;;) {
			const { value, done } = await reader.read();
			if (value) {
				let chunk = decoder.decode(value, { stream: true });
				onData(chunk, cancel);
				if(cancelled) return;
			}
			if(done) break;
		}
		onEnd?.();
	} catch (error) {
		console.error('Error during fetch or stream processing:', error);
	}
}
http.getStringDirectly = async function(url) {
	return await (await fetch(url)).text()
}
http.getJsonDirectly = async function(url) {
	if(!core.isPremiere || !input.isCertain) return null
	return await (await fetch(url)).json()
}
http.getJsonDirectly2 = async function(url, options) {
	return await (await fetch(url, options)).json()
}
http.postDirectly = async function(url, body) {
	return (await fetch(url, {method:"POST", body:JSON.stringify(body)})).text() 
}
http.postDirectly2 = async function(url, body, code, $else) {
	try {
		let data = await (await fetch(url, {method:"POST", body:JSON.stringify(body)})).text();
		code(data);
	} catch(e) {
		core.log(e.stack.toString());
		$else();
	}
}
http.post = async function(url, code) {
	let id = networkData.addCallback(code)
	if(core.frame == 0) Platform.waitingForInitialData++
	if(core.isPremiere && input.isCertain) {
		let data = await (await fetch(url, {method:"POST"})).text()
		log("http.post "+url+" -> "+data?.length+" bytes")
		input.handleObject(id, data)
	}
}
http.post2 = async function(url, body, code) {
	let id = networkData.addCallback(code)
	if(core.frame == 0) Platform.waitingForInitialData++
	if(core.isPremiere && input.isCertain) {
		log("Actually fetching data: POST "+url)
		let data = await (await fetch(url, {method:"POST", body:JSON.stringify(body)})).text()
		log("http.post "+url+" -> "+data?.length+" bytes")
		input.handleObject(id, data)
	}
}
http.post3 = async function(url, body) {
	if(core.isPremiere && input.isCertain) {
		(await fetch(url, {method:"POST", body:JSON.stringify(body)})).text()
	}
}
http.put = async function(url, code) {
	let id = networkData.addCallback(code)
	if(core.frame == 0) Platform.waitingForInitialData++
	if(core.isPremiere && input.isCertain) {
		let data = await (await fetch(url, {method:"PUT"})).text()
		log("http.put "+url+" -> "+data?.length+" bytes")
		input.handleObject(id, data)
	}
}
http.put2 = async function(url, body, code) {
	let id = networkData.addCallback(code)
	if(core.frame == 0) Platform.waitingForInitialData++
	if(core.isPremiere && input.isCertain) {
		let data = await (await fetch(url, {method:"PUT", body:JSON.stringify(body)})).text()
		log("http.put "+url+" -> "+data?.length+" bytes")
		input.handleObject(id, data)
	}
}
http.delete = async function(url, code) {
	let id = networkData.addCallback(code)
	if(core.isPremiere && input.isCertain) {
		let data = await (await fetch(url, {method:"DELETE"})).text()
		log("http.delete "+url+" -> "+data?.length+" bytes")
		input.handleObject(id, data)
	}
}
http.delete2 = async function(url, body, code) {
	let id = networkData.addCallback(code)
	if(core.isPremiere && input.isCertain) {
		let data = await (await fetch(url, {method:"DELETE", body:JSON.stringify(body)})).text()
		log("http.delete "+url+" -> "+data?.length+" bytes")
		input.handleObject(id, data)
	}
}
function Signal(receiverId, type, sdp) {
	this.receiverId = receiverId;
	this.type = type;
	this.sdp = sdp;
}
Signal.prototype.clone = function() {
	let clone = new _Signal();
	clone.receiverId = this.receiverId;
	clone.type = this.type;
	clone.sdp = this.sdp;
	return clone;
}
function _Signal() {};
_Signal.prototype = Signal.prototype;
function IceMessage(receiverId, iceCandidate) {
	this.receiverId = receiverId;
	this.iceCandidate = iceCandidate;
}
IceMessage.prototype.clone = function() {
	let clone = new _IceMessage();
	clone.receiverId = this.receiverId;
	clone.iceCandidate = this.iceCandidate;
	return clone;
}
function _IceMessage() {};
_IceMessage.prototype = IceMessage.prototype;
function MediaDeviceInfo(deviceId, groupId, kind, label) {
	this.deviceId = deviceId;
	this.groupId = groupId;
	this.kind = kind;
	this.label = label;
}
MediaDeviceInfo.prototype.clone = function() {
	let clone = new _MediaDeviceInfo();
	clone.deviceId = this.deviceId;
	clone.groupId = this.groupId;
	clone.kind = this.kind;
	clone.label = this.label;
	return clone;
}
function _MediaDeviceInfo() {};
_MediaDeviceInfo.prototype = MediaDeviceInfo.prototype;
MediaDeviceInfo.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.deviceId);
	buffer.writeString(this.groupId);
	buffer.writeString(this.kind);
	buffer.writeString(this.label);
}
MediaDeviceInfo.prototype.deserialize_internal = function(buffer) {
	this.deviceId = buffer.readString();
	this.groupId = buffer.readString();
	this.kind = buffer.readString();
	this.label = buffer.readString();
}
MediaDeviceInfo.prototype.serialize_external = function(buffer) {
	buffer.writeString("deviceId");
	buffer.writeString(this.deviceId);
	buffer.writeString("groupId");
	buffer.writeString(this.groupId);
	buffer.writeString("kind");
	buffer.writeString(this.kind);
	buffer.writeString("label");
	buffer.writeString(this.label);
	buffer.writeString("");
}
MediaDeviceInfo.prototype.deserialize_external = function(buffer) {
	let deviceId_is_set = false, groupId_is_set = false, kind_is_set = false, label_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "deviceId":
				this.deviceId = buffer.readString();
				deviceId_is_set = true;
				break;
			case "groupId":
				this.groupId = buffer.readString();
				groupId_is_set = true;
				break;
			case "kind":
				this.kind = buffer.readString();
				kind_is_set = true;
				break;
			case "label":
				this.label = buffer.readString();
				label_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!deviceId_is_set) this.deviceId = "";
				if(!groupId_is_set) this.groupId = "";
				if(!kind_is_set) this.kind = "";
				if(!label_is_set) this.label = "";
				return;
		}
	}
}
function MediaDevices(audioInput, audioOutput, videoInput) {
	this.audioInput = audioInput;
	this.audioOutput = audioOutput;
	this.videoInput = videoInput;
}
MediaDevices.prototype.clone = function() {
	let clone = new _MediaDevices();
	clone.audioInput = this.audioInput;
	clone.audioOutput = this.audioOutput;
	clone.videoInput = this.videoInput;
	return clone;
}
function _MediaDevices() {};
_MediaDevices.prototype = MediaDevices.prototype;
MediaDevices.prototype.serialize_internal = function(buffer) {
	let audioInput = this.audioInput
	if(audioInput) {
		var index = _objectCacheIndex.get(audioInput);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(audioInput, index = _objectCache.length);
			_objectCache.push(audioInput);
			buffer.writeInt32(-index);
			audioInput._objectIndex = index;
			buffer.writeInt32(audioInput.length);
			for(let i=0, len=audioInput.length; i<len; ++i) {
				let audioInput_item = audioInput[i]
				if(audioInput_item) {
					var index = _objectCacheIndex.get(audioInput_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(audioInput_item, index = _objectCache.length);
						_objectCache.push(audioInput_item);
						buffer.writeInt32(-index);
						audioInput_item._objectIndex = index;
						audioInput_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let audioOutput = this.audioOutput
	if(audioOutput) {
		var index = _objectCacheIndex.get(audioOutput);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(audioOutput, index = _objectCache.length);
			_objectCache.push(audioOutput);
			buffer.writeInt32(-index);
			audioOutput._objectIndex = index;
			buffer.writeInt32(audioOutput.length);
			for(let i=0, len=audioOutput.length; i<len; ++i) {
				let audioOutput_item = audioOutput[i]
				if(audioOutput_item) {
					var index = _objectCacheIndex.get(audioOutput_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(audioOutput_item, index = _objectCache.length);
						_objectCache.push(audioOutput_item);
						buffer.writeInt32(-index);
						audioOutput_item._objectIndex = index;
						audioOutput_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let videoInput = this.videoInput
	if(videoInput) {
		var index = _objectCacheIndex.get(videoInput);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(videoInput, index = _objectCache.length);
			_objectCache.push(videoInput);
			buffer.writeInt32(-index);
			videoInput._objectIndex = index;
			buffer.writeInt32(videoInput.length);
			for(let i=0, len=videoInput.length; i<len; ++i) {
				let videoInput_item = videoInput[i]
				if(videoInput_item) {
					var index = _objectCacheIndex.get(videoInput_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(videoInput_item, index = _objectCache.length);
						_objectCache.push(videoInput_item);
						buffer.writeInt32(-index);
						videoInput_item._objectIndex = index;
						videoInput_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
MediaDevices.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this.audioInput = _objectCache[index];
	} else {
		let audioInput = this.audioInput
		if(!audioInput || audioInput._objectIndex != -index) this.audioInput = audioInput = [];
		_objectCache[-index] = audioInput;
		for(let i=0, len = audioInput.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					audioInput[i] = _objectCache[index];
				} else {
					let audioInput_item = audioInput[i]
					if(!audioInput_item || audioInput_item._objectIndex != -index)
						audioInput[i] = audioInput_item = new _MediaDeviceInfo();
					(_objectCache[-index] = audioInput_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.audioOutput = _objectCache[index];
	} else {
		let audioOutput = this.audioOutput
		if(!audioOutput || audioOutput._objectIndex != -index) this.audioOutput = audioOutput = [];
		_objectCache[-index] = audioOutput;
		for(let i=0, len = audioOutput.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					audioOutput[i] = _objectCache[index];
				} else {
					let audioOutput_item = audioOutput[i]
					if(!audioOutput_item || audioOutput_item._objectIndex != -index)
						audioOutput[i] = audioOutput_item = new _MediaDeviceInfo();
					(_objectCache[-index] = audioOutput_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.videoInput = _objectCache[index];
	} else {
		let videoInput = this.videoInput
		if(!videoInput || videoInput._objectIndex != -index) this.videoInput = videoInput = [];
		_objectCache[-index] = videoInput;
		for(let i=0, len = videoInput.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					videoInput[i] = _objectCache[index];
				} else {
					let videoInput_item = videoInput[i]
					if(!videoInput_item || videoInput_item._objectIndex != -index)
						videoInput[i] = videoInput_item = new _MediaDeviceInfo();
					(_objectCache[-index] = videoInput_item).deserialize_internal(buffer);
				}
		}
	}
}
MediaDevices.prototype.serialize_external = function(buffer) {
	buffer.writeString("audioInput");
	let audioInput = this.audioInput
	let audioInput_startPos = buffer.reserveSize();
	if(audioInput) {
		var index = _objectCacheIndex.get(audioInput);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(audioInput, index = _objectCache.length);
			_objectCache.push(audioInput);
			buffer.writeInt32(-index);
			audioInput._objectIndex = index;
			buffer.writeInt32(audioInput.length);
			for(let i=0, len=audioInput.length; i<len; ++i) {
				let audioInput_item = audioInput[i]
				if(audioInput_item) {
					var index = _objectCacheIndex.get(audioInput_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(audioInput_item, index = _objectCache.length);
						_objectCache.push(audioInput_item);
						buffer.writeInt32(-index);
						audioInput_item._objectIndex = index;
						audioInput_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(audioInput_startPos);
	buffer.writeString("audioOutput");
	let audioOutput = this.audioOutput
	let audioOutput_startPos = buffer.reserveSize();
	if(audioOutput) {
		var index = _objectCacheIndex.get(audioOutput);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(audioOutput, index = _objectCache.length);
			_objectCache.push(audioOutput);
			buffer.writeInt32(-index);
			audioOutput._objectIndex = index;
			buffer.writeInt32(audioOutput.length);
			for(let i=0, len=audioOutput.length; i<len; ++i) {
				let audioOutput_item = audioOutput[i]
				if(audioOutput_item) {
					var index = _objectCacheIndex.get(audioOutput_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(audioOutput_item, index = _objectCache.length);
						_objectCache.push(audioOutput_item);
						buffer.writeInt32(-index);
						audioOutput_item._objectIndex = index;
						audioOutput_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(audioOutput_startPos);
	buffer.writeString("videoInput");
	let videoInput = this.videoInput
	let videoInput_startPos = buffer.reserveSize();
	if(videoInput) {
		var index = _objectCacheIndex.get(videoInput);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(videoInput, index = _objectCache.length);
			_objectCache.push(videoInput);
			buffer.writeInt32(-index);
			videoInput._objectIndex = index;
			buffer.writeInt32(videoInput.length);
			for(let i=0, len=videoInput.length; i<len; ++i) {
				let videoInput_item = videoInput[i]
				if(videoInput_item) {
					var index = _objectCacheIndex.get(videoInput_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(videoInput_item, index = _objectCache.length);
						_objectCache.push(videoInput_item);
						buffer.writeInt32(-index);
						videoInput_item._objectIndex = index;
						videoInput_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(videoInput_startPos);
	buffer.writeString("");
}
MediaDevices.prototype.deserialize_external = function(buffer) {
	let audioInput_is_set = false, audioOutput_is_set = false, videoInput_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "audioInput":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.audioInput = _objectCache[index];
				} else {
					let audioInput = this.audioInput
					if(!audioInput || audioInput._objectIndex != -index) this.audioInput = audioInput = [];
					_objectCache[-index] = audioInput;
					for(let i=0, len = audioInput.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								audioInput[i] = _objectCache[index];
							} else {
								let audioInput_item = audioInput[i]
								if(!audioInput_item || audioInput_item._objectIndex != -index)
									audioInput[i] = audioInput_item = new _MediaDeviceInfo();
								(_objectCache[-index] = audioInput_item).deserialize_external(buffer);
							}
					}
				}
				audioInput_is_set = true;
				break;
			case "audioOutput":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.audioOutput = _objectCache[index];
				} else {
					let audioOutput = this.audioOutput
					if(!audioOutput || audioOutput._objectIndex != -index) this.audioOutput = audioOutput = [];
					_objectCache[-index] = audioOutput;
					for(let i=0, len = audioOutput.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								audioOutput[i] = _objectCache[index];
							} else {
								let audioOutput_item = audioOutput[i]
								if(!audioOutput_item || audioOutput_item._objectIndex != -index)
									audioOutput[i] = audioOutput_item = new _MediaDeviceInfo();
								(_objectCache[-index] = audioOutput_item).deserialize_external(buffer);
							}
					}
				}
				audioOutput_is_set = true;
				break;
			case "videoInput":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.videoInput = _objectCache[index];
				} else {
					let videoInput = this.videoInput
					if(!videoInput || videoInput._objectIndex != -index) this.videoInput = videoInput = [];
					_objectCache[-index] = videoInput;
					for(let i=0, len = videoInput.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								videoInput[i] = _objectCache[index];
							} else {
								let videoInput_item = videoInput[i]
								if(!videoInput_item || videoInput_item._objectIndex != -index)
									videoInput[i] = videoInput_item = new _MediaDeviceInfo();
								(_objectCache[-index] = videoInput_item).deserialize_external(buffer);
							}
					}
				}
				videoInput_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!audioInput_is_set) this.audioInput = [];
				if(!audioOutput_is_set) this.audioOutput = [];
				if(!videoInput_is_set) this.videoInput = [];
				return;
		}
	}
}
var PeerNetwork; if(!PeerNetwork) PeerNetwork = {};
PeerNetwork.init = function() {
	PeerNetwork.relayMode = 1/*Auto*/;
	PeerNetwork.enableVideo = true;
	PeerNetwork.enableAudio = true;
	PeerNetwork.error = "";
	PeerNetwork.retries = 0;
	PeerNetwork.dataChannelId = 0;
	PeerNetwork.sendBuffer = new Buffer(null, 1024, 0, 0);
	PeerNetwork.devices = new MediaDevices([], [], []);
	PeerNetwork.videoInputId = "";
	PeerNetwork.audioInputId = "";
	PeerNetwork.audioOutputId = "";
}
PeerNetwork.initiate = function(user) {
	PeerNetwork.setupPeerConnection(user, true);
	PeerNetwork.setupRemoteMedia(user);
}
PeerNetwork.tick = function() {
	let now = Date.now();
	for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let user = _subject[i]; {
		if((user != null) && !user.local) {
			if(now > (user.lastIncomingMessageTime + 10000)) {
				core.log(("["+core.frame?.toString()+"] <"+user.id?.toString()+"> #problem -------------------------------- State is "+user.connectionState+" after "+(now - user.startToConnectTime).toString()+" ms, "+user.connectionTries?.toString()+" retries, last incomming message "+(now - user.lastIncomingMessageTime).toString()+" ms ago, offerByMe:"+user.offerByMe+" --------------------------------"));
				user.startToConnectTime = user.lastIncomingMessageTime = Date.now();
				statistics.scheduleSendIn((3*1000));
				if(user.offerByMe) {
					PeerNetwork.retries++;
					if(++user.connectionTries < 3) {
						core.log("#peer Restarting ICE (offer by me)");
						user.peerConnection.restartIce();
					} else {
						core.log("#peer Recreate peer connection (offer by me)");
						PeerNetwork.initiate(user);
					}
				}
			}
		}
	}}
}
PeerNetwork.setupPeerConnection = function(user, offerByMe) {
	if(user.peerConnection) {
		try {
			core.log(`#peer <${user.id}> Close Previous Peer Connection`)
			user.peerConnection.onnegotiationneeded = null;
			user.peerConnection.onsignalingstatechange = null;
			user.peerConnection.onconnectionstatechange = null;
			user.peerConnection.onicecandidate = null;
			user.peerConnection.icecandidateerror = null;
			user.peerConnection.oniceconnectionstatechange = null;
			user.peerConnection.onicegatheringstatechange = null;
			user.peerConnection.close();
		} catch {}
	}
	try {
		user.startToConnectTime = user.lastIncomingMessageTime = Date.now();
		user.offerByMe = offerByMe;
		
		let options = {
			
			iceTransportPolicy: PeerNetwork.relayMode == 2 ? "relay" : "all",
			iceServers: [],
			
		}
		if(PeerNetwork.relayMode > 0) {
			
			options.iceServers.push({
				urls: 'turn:193.70.81.132:39571',
				username: 'play-user-x8env28gx41odbxzwjyut2oq871987syq8ovyuqp128djbsjue',
				credential: 'qoy91n981vlplabb1873jdcgsouz2qm87qmmakqpc2t8hbeyjsyaqkuz'
			}); 
			
			
			
			
			
			
			
		}
		options.iceServers.push({
			urls: [
				
				
				
				
				"stun:stun1.l.google.com:19302",
				"stun:stun2.l.google.com:19302",
			],
		});
		core.log(`#peer <${user.id}> Setup Peer Connection offerByMe: ${offerByMe}`);
		let peerConnection = user.peerConnection = new RTCPeerConnection(options);
		
		
		peerConnection.onnegotiationneeded = e => {
			core.log(`#peer <${user.id}> Negotiation Needed`);
			if(offerByMe) PeerNetwork.createOffer(user);
		}
		
		
		
		
		
		peerConnection.onconnectionstatechange = e => {
			core.log(`#peer <${user.id}> Connection State Change: ${peerConnection.connectionState}`);
			user.connectionState = peerConnection.connectionState;
			user.connected = peerConnection.connectionState == "connected";
			if(user.connected) PeerNetwork.onConnected(user);
			if(peerConnection.connectionState == "disconnected")
				setTimeout(() => statistics.saveStatistics(), 7000);
				
			
			
			
			
			
			
			
			
		}
		
		
		let candidateCount = 0
		peerConnection.onicecandidate = async event => {
			if (event.candidate) {
				core.log(`#peer <${user.id}> Gathered Local Ice Candidate ${++candidateCount} -> Send to peer`);
				ServerNetwork.sendIce(user.id, JSON.stringify(event.candidate));
			} else {
				core.log(`#peer <${user.id}> Gathered Local Ice Candidates Complete`);
			}
		}
		peerConnection.icecandidateerror = e => {
			core.log(`#peer <${user.id}> IDE Candidate Error: ${e.errorText}`);
		}
		
		
		
		
		
		
		
		
		
		
		return peerConnection;
	} 
	catch(e) {
		core.log("#peer <"+user.id+"> setupPeerConnection failed " + e.message)
		console.error(e);
		core.log(e.stack);
		return null;
	}
}
PeerNetwork.setupDataChannel = function(user) {
	try {
		user.startDataChannelTime = Date.now();
		
		
		
		
		
		
		core.log("#peer <"+user.id+"> Data Channel Creating");
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		for(let dataChannel of user.dataChannels) {
			try { 
				dataChannel.close();
				core.log("#peer <"+user.id+"> Data Channel Closing previous channel (id:"+dataChannel._id+")");
			} catch {}
		}
		user.dataChannels.length = 0;
		
		
		
		let dataChannel = user.peerConnection.createDataChannel("channel", {ordered:false, maxRetransmits:0}); 
		dataChannel.binaryType = "arraybuffer";
		dataChannel._id = PeerNetwork.dataChannelId++;
		
		
		dataChannel.onopen = e => {
			user.dataChannels.splice(0,0,dataChannel);
			core.log("#peer <"+user.id+"> Data Channel Open (id:"+dataChannel._id+", length: "+user.dataChannels.length+")");
		}
		
		
		dataChannel.onclosing = e => {
			user.dataChannels.remove();
			core.log("#peer <"+user.id+"> Data Channel Closing (id:"+dataChannel._id+", length: "+user.dataChannels.length+")");
		}
		dataChannel.onclose = e => {
			user.dataChannels.remove();
			core.log("#peer <"+user.id+"> Data Channel Close (id:"+dataChannel._id+", length: "+user.dataChannels.length+")");
		}
		dataChannel.onerror = e => {
			core.log("#peer <"+user.id+"> Data Channel Error " + ev.error.message+" (id:"+dataChannel._id+", length: "+user.dataChannels.length+")");
		}
		
		
		dataChannel.onmessage = e => {
			
			PeerNetwork.onMessage(user, new Buffer(e.data, 0, 0, 0));
		}
	} 
	catch(e) {
		core.log("#peer <"+user.id+"> setupDataChannel failed " + e.message)
		console.error(e);
		core.log(e.stack);
	}
}
PeerNetwork.onConnected = function(user) {
	user.startDataChannelTime = user.lastIncomingMessageTime = Date.now();
	PeerNetwork.logConnectionType(user);
	if(user.offerByMe) {
		PeerNetwork.setupDataChannel(user);
	}
	if(!statistics.connectTime) {
		let connectedCount = input.internalUsers.count(a => a.offerByMe && a.connected);
		let offerCount = input.internalUsers.count(a => a.offerByMe);
		core.log(("#peer Connected on try "+user.connectionTries?.toString()+", "+connectedCount?.toString()+" of "+offerCount?.toString()+" my offers are connected"));
		if(!input.internalUsers.some(a => a.offerByMe && !a.connected)) {
			statistics.connectTime = (performance.now() - statistics.startTime);
			core.log(("#peer All my offers are connected after "+statistics.connectTime.toString()+" ms and "+PeerNetwork.retries?.toString()+" retries"));
		}
	}
}
PeerNetwork.disconnect = function(user) {
	for(let i=0, _subject=user.dataChannels, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		it.close();
	}}
	if(user.peerConnection != null) {
		user.peerConnection.close;
	}
	input.internalUsers[user.id] = null;
}
PeerNetwork.setBitrate = async function(user, scaleResolutionDownBy, maxBitrate) {
	try {
		let senderList = user.peerConnection.getSenders();
		for(let sender of senderList) {
			const params = sender.getParameters();
			console.log(params);
			if (!params.encodings) {
				params.encodings = [{ }];
			}
			params.encodings[0].scaleResolutionDownBy = scaleResolutionDownBy;
			params.encodings[0].maxBitrate = maxBitrate;
			
			await sender.setParameters(params);
		}
	}
	catch(e) {
		core.log("#peer <"+user.id+"> setBitrate failed " + e.message)
		console.error(e);
		core.log(e.stack);
	}
}
PeerNetwork.createOffer = async function(user) {
	try {
		core.log("#peer <"+user.id+"> Sending offer to "+user.id+", waiting for answer. Try:"+user.connectionTries);
		let peerConnection = user.peerConnection
		let offer = await peerConnection.createOffer();
		await peerConnection.setLocalDescription(offer);
		ServerNetwork.sendSignal(user.id, "offer", peerConnection.localDescription.sdp)
		user.receivedAnswer = false
		
		
		
		
		
		
		
		
		
		
	}
	catch(e) {
		core.log("#peer <"+user.id+"> createOffer failed " + e.message)
		console.error(e);
		core.log(e.stack);
	}
}
PeerNetwork.onReceivedOffer = async function(user, sdp) {
	try {
		core.log("#peer <"+user.id+"> Received offer -> Send answer");
		PeerNetwork.setupPeerConnection(user, /*offerByMe*/false);
		PeerNetwork.setupRemoteMedia(user);
		
		
		user.peerConnection.ondatachannel = e => {
			core.log("#peer <"+user.id+"> Data Channel Received");
			let dataChannel = e.channel;
			dataChannel.binaryType = "arraybuffer";
			dataChannel._id = PeerNetwork.dataChannelId++;
			
			
			dataChannel.onopen = e => {
				PeerNetwork.logConnectionType(user);
				user.dataChannels.splice(0,0,dataChannel);
				core.log("#peer <"+user.id+"> Data Channel Open (id:"+dataChannel._id+", length: "+user.dataChannels.length+")");
			}
			
			
			dataChannel.onclosing = e => {
				user.dataChannels.remove(dataChannel);
				core.log("#peer <"+user.id+"> Data Channel Closing (id:"+dataChannel._id+", length: "+user.dataChannels.length+")");
			}
			dataChannel.onclose = e => {
				user.dataChannels.remove(dataChannel);
				core.log("#peer <"+user.id+"> Data Channel Close (id:"+dataChannel._id+", length: "+user.dataChannels.length+")");
			}
			dataChannel.onerror = e => {
				core.log("#peer <"+user.id+"> Data Channel Error "+e.error.message+" (id:"+dataChannel._id+", length: "+user.dataChannels.length+")");
			}
			
			
			dataChannel.onmessage = e => {
				
				PeerNetwork.onMessage(user, new Buffer(e.data, 0, 0, 0));
			}
		}
					
		
		let peerConnection = user.peerConnection;
		await peerConnection.setRemoteDescription(new RTCSessionDescription({type: "offer", sdp}));
		let answer = await peerConnection.createAnswer();
		await peerConnection.setLocalDescription(answer);
		ServerNetwork.sendSignal(user.id, "answer", peerConnection.localDescription.sdp);
	}
	catch(e) {
		core.log("#peer <"+user.id+"> onReceivedOffer failed " + e.message)
		console.error(e)
		core.log(e.stack);
	}
}
PeerNetwork.send = function(user, buffer) {
	if(user.dataChannels.length == 0) {
		core.log("#data <"+user.id+"> Trying to send without dataChannels")
	}
	try {
		let data = buffer.toByteArray()
		let channel = user.dataChannels[0]
		channel.send(data)
		
		return data.byteLength
	} 
	catch(e) {
		core.log("#peer <"+user.id+"> send failed " + e.message)
		console.error(e)
		core.log(e.stack)
		return 0
	}
}
PeerNetwork.onMessage = function(user, buffer) {
	user.lastIncomingMessageTime = Date.now();
	let type = buffer.readInt8();
	if(type == 6/*Tick*/) {
		PeerNetwork.onTick(user, buffer);
	} else {
		if(type == 2/*Ping*/) {
			PeerNetwork.onPing(user, buffer);
		} else {
			if(type == 3/*Pong*/) {
				PeerNetwork.onPong(user, buffer);
			}
		}
	}
}
PeerNetwork.sendInputs = function(inputFrame) {
	let inputs = input.localUser.inputs;
	for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let receiver = _subject[i]; {
		if((receiver != null)) {
			let length = inputs.writePos - receiver.receivedMyInputsUpToPos;
			if(!receiver.local && (receiver.dataChannels != null && receiver.dataChannels.length != 0) ) {
				PeerNetwork.sendBuffer.reset();
				PeerNetwork.sendBuffer.writeInt8(6/*Tick*/);
				PeerNetwork.sendBuffer.writeInt(inputFrame);
				PeerNetwork.sendBuffer.writeInt(receiver.receivedMyInputsUpToPos);
				PeerNetwork.sendBuffer.writeInt(receiver.inputs.writePos);
				PeerNetwork.sendBuffer.writeBuffer2(inputs, receiver.receivedMyInputsUpToPos, length);
				PeerNetwork.sendBuffer.writeInt(core.lastChecksumFrame);
				PeerNetwork.sendBuffer.writeFloat64(core.checksums[core.lastChecksumFrame] || 0);
				core.tickMessageSize = PeerNetwork.send(receiver, PeerNetwork.sendBuffer);
				if(core.verbose) {
					if(receiver.receivedMyInputsUpToPos > inputs.writePos) {
						core.log(("["+inputFrame?.toString()+"] <"+receiver.id?.toString()+"> #send -->> "+receiver.receivedMyInputsUpToPos?.toString()+"->"+inputs.writePos?.toString()+" id:"+receiver.dataChannels[0]._id));
					} else {
						core.log(("["+inputFrame?.toString()+"] <"+receiver.id?.toString()+"> #send -->>"));
					}
				}
				core.log(("["+inputFrame?.toString()+"] <"+receiver.id?.toString()+"> #send -->> The other <"+receiver.id?.toString()+"> received up to "+receiver.receivedMyInputsUpToPos?.toString()+" and I'm <"+input.localUser.id?.toString()+"> sending "+length?.toString()+" bytes, from "+receiver.receivedMyInputsUpToPos?.toString()+" to "+inputs.writePos?.toString()));
			}
		}
	}}
}
PeerNetwork.onTick = function(sender, buffer) {
	let inputFrame = buffer.readInt();
	if(inputFrame >= sender.inputFrame) {
		let prevInputFrame = sender.inputFrame;
		let incomingInputsWritePos = buffer.readInt();
		sender.receivedMyInputsUpToPos = buffer.readInt();
		sender.inputFrame = inputFrame;
		let length = buffer.readBuffer(sender.inputs, incomingInputsWritePos);
		core.log(("["+inputFrame?.toString()+"] <"+sender.id?.toString()+"> #receive <<-- I <"+input.localUser.id?.toString()+"> received "+length?.toString()+" bytes, up to "+sender.inputs.writePos?.toString()+" from "+sender.id?.toString()));
		if(core.verbose) {
			if(sender.inputs.writePos > incomingInputsWritePos) {
				core.log(("["+inputFrame?.toString()+"] <"+sender.id?.toString()+"> #receive <<-- writePos: "+incomingInputsWritePos?.toString()+"->"+sender.inputs.writePos?.toString()));
			} else {
				core.log(("["+inputFrame?.toString()+"] <"+sender.id?.toString()+"> #receive <<--"));
			}
		}
		let checksumFor = buffer.readInt();
		let checksum = buffer.readFloat64();
		if(core.verbose) {
			core.log(("<"+sender.id?.toString()+"> #"+checksumFor?.toString()+" "+checksum.toString()));
		}
		let myChecksum = core.checksums[checksumFor];
		if(!myChecksum) {
			core.checksums[checksumFor] = checksum;
		} else {
			if(!(Math.abs(myChecksum - checksum) < 0.00001)) {
				core.onWrongChecksum(checksumFor, myChecksum, checksum);
			}
		}
		if(length) {
			core.storeInputsToDB(sender);
		}
	}
}
PeerNetwork.onReceivedAnswer = async function(user, sdp) {
	core.log("#peer <"+user.id+"> Received Answer");
	try {
		await user.peerConnection.setRemoteDescription(new RTCSessionDescription({type: "answer", sdp}));
		user.receivedAnswer = true
	}
	catch(e) {
		core.log("#peer <"+user.id+"> onReceivedAnswer failed " + e.message)
		core.log(e.stack);
	} 
}
PeerNetwork.onIce = async function(user, candidate) {
	core.log("#peer <"+user.id+"> Received Ice Candidate");
	try {
		await user.peerConnection.addIceCandidate(new RTCIceCandidate(JSON.parse(candidate)));
	}
	catch(e) {
		core.log("#peer <"+user.id+"> onIce failed " + e.message)
		core.log(e.stack);
	}
}
PeerNetwork.logConnectionType = async function(user) {
	setTimeout(async () => {
		let stats = await user.peerConnection.getStats()
		let candidatePairs = [...stats.values()].filter(s => s.type == "candidate-pair" && s.state == "succeeded")
		let candidatePair = candidatePairs.find(a => a.selected) || candidatePairs[0]
		if(candidatePair) {
			let candidate = stats.get(candidatePair.localCandidateId);
			let ip = candidate.ip || candidate.address
			user.connectionType = candidate.candidateType + " " + ip
			core.log("#connection <"+user.id+"> connection "+user.connectionType)
		} else {
			core.log("#connection <"+user.id+"> connection: no candidate pair for "+user.id)
			window.stats = [...stats.values()]
			console.log(window.stats)
			try { core.log(JSON.stringify(window.stats)) }
			catch{ }
		}
	}, 10000)
}
PeerNetwork.ping = function() {
	for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let user = _subject[i]; {
		if((user != null) && (user.dataChannels != null && user.dataChannels.length != 0) ) {
			PeerNetwork.sendBuffer.reset();
			PeerNetwork.sendBuffer.writeInt8(2/*Ping*/);
			PeerNetwork.sendBuffer.writeFloat64(Date.now());
			PeerNetwork.send(user, PeerNetwork.sendBuffer);
		}
	}}
}
PeerNetwork.onPing = function(user, buffer) {
	let pingTime = buffer.readFloat64();
	PeerNetwork.sendBuffer.reset();
	PeerNetwork.sendBuffer.writeInt8(3/*Pong*/);
	PeerNetwork.sendBuffer.writeFloat64(pingTime);
	PeerNetwork.send(user, PeerNetwork.sendBuffer);
}
PeerNetwork.onPong = function(user, buffer) {
	let now = Date.now();
	let pingTime = buffer.readFloat64();
	let pingPongTime = now - pingTime;
	let player = input.players.find(a => a.id == user.id);
	if((player != null)) {
		statistics.add("pingPongTime", player.index, pingPongTime, player.color, 3, false);
	}
}
PeerNetwork.sendChecksum = function(checksumFor, checksum) {
	PeerNetwork.sendBuffer.reset();
	PeerNetwork.sendBuffer.writeInt8(11/*Checksum*/);
	PeerNetwork.sendBuffer.writeInt(checksumFor);
	PeerNetwork.sendBuffer.writeFloat64(checksum);
	for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let user = _subject[i]; {
		if((user != null) && (user.dataChannels != null && user.dataChannels.length != 0) ) {
			PeerNetwork.send(user, PeerNetwork.sendBuffer);
		}
	}}
}
PeerNetwork.onChecksum = function(user, buffer) {
	let checksumFor = buffer.readInt();
	let checksum = buffer.readFloat64();
	if(core.verbose) {
		core.log(("<"+user.id?.toString()+"> #"+checksumFor?.toString()+" "+checksum.toString()));
	}
	let myChecksum = core.checksums[checksumFor];
	if(!myChecksum) {
		core.checksums[checksumFor] = checksum;
	} else {
		if(!(Math.abs(myChecksum - checksum) < 0.00001)) {
			core.onWrongChecksum(checksumFor, myChecksum, checksum);
		}
	}
}
PeerNetwork.setupLocalMedia = async function(enableVideo, enableAudio) {
	core.log("setupLocalMedia: start")
	PeerNetwork.enableVideo = enableVideo
	PeerNetwork.enableAudio = enableAudio
	if(!enableVideo && !enableAudio) return
		
	try {
		
		input.localUser.mediaStream = await navigator.mediaDevices.getUserMedia({
			video: {width: 500, height: 375},
			audio: enableAudio
		});
		core.log("setupLocalMedia: getUserMedia done")
		
		
		let devices = await navigator.mediaDevices.enumerateDevices();
		core.log("setupLocalMedia: enumerateDevices done")
		
		for(let device of devices) {
			switch(device.kind) {
				case "videoinput": PeerNetwork.devices.videoInput.push(device); break;
				case "audioinput": PeerNetwork.devices.audioInput.push(device); break;
				case "audiooutput": PeerNetwork.devices.audioOutput.push(device); break;
			}
		}
		PeerNetwork.videoInputId = input.localUser.mediaStream.getVideoTracks()[0]?.getSettings().deviceId || PeerNetwork.devices.videoInput[0]?.deviceId
		PeerNetwork.audioInputId = input.localUser.mediaStream.getAudioTracks()[0]?.getSettings().deviceId || PeerNetwork.devices.audioInput[0]?.deviceId
		PeerNetwork.audioOutputId = PeerNetwork.devices.audioOutput[0]?.deviceId
		statistics.cameraTime = performance.now() - statistics.startTime
		core.log("#camera Setup Local Camera and Microphone after "+statistics.cameraTime+" ms")
		
	} catch(error) {
		core.log(error.message)
		if(error.name == "NotAllowedError") {
			PeerNetwork.error = "To play with friends over a video call, you need to allow access to your webcam."
		} else {
			PeerNetwork.error = "Can't access webcam. Please make sure it's not used by another application."
		}
		core.errorMessage = error.message
		throw error
	}
}
PeerNetwork.setVideoInput = async function(videoInputId, player) {
	if(Platform.fastForward || input.localUser.id != player.id || PeerNetwork.videoInputId == videoInputId || !videoInputId) return;
	PeerNetwork.videoInputId = videoInputId;
	
	
	input.localUser.mediaStream = await navigator.mediaDevices.getUserMedia({
		audio: {deviceId: PeerNetwork.audioInputId},
		video: {deviceId: PeerNetwork.videoInputId},
	});
	
	
	for(let el of input.localUser.videoElements) {
		el.srcObject = input.localUser.mediaStream;
	}
	const [videoTrack] = input.localUser.mediaStream.getVideoTracks();
	for(let user of input.internalUsers) {
		if(user?.peerConnection) {
			const sender = user.peerConnection.getSenders().find((s) => s.track.kind === videoTrack.kind);
			sender.replaceTrack(videoTrack);
		}
	}
}
PeerNetwork.setAudioInput = async function(audioInputId, player) {
	if(Platform.fastForward || input.localUser.id != player.id || PeerNetwork.audioInputId == audioInputId || !audioInputId) return;
	PeerNetwork.audioInputId = audioInputId;
	
	
	input.localUser.mediaStream = await navigator.mediaDevices.getUserMedia({
		audio: {deviceId: PeerNetwork.audioInputId},
		video: {deviceId: PeerNetwork.videoInputId},
	});
	
	
	const [audioTrack] = input.localUser.mediaStream.getAudioTracks();
	for(let user of input.internalUsers) {
		if(user?.peerConnection) {
			const sender = user.peerConnection.getSenders().find((s) => s.track.kind === audioTrack.kind);
			sender.replaceTrack(audioTrack);
		}
	}
}
PeerNetwork.setAudioOutput = function(audioOutputId, player) {
	if(Platform.fastForward || input.localUser.id != player.id || PeerNetwork.audioOutputId == audioOutputId || !audioOutputId) return;
	PeerNetwork.audioOutputId = audioOutputId;
	
	
	for(let user of input.internalUsers) {
		if(user) {
			if(user.audioElement && user.audioElement.setSinkId) {
				user.audioElement.setSinkId(PeerNetwork.audioOutputId);
			}
			for(let videoElement of user.videoElements) {
				if(videoElement.setSinkId) {
					videoElement.setSinkId(PeerNetwork.audioOutputId);
				}
			}
		}
	}
	audio.reload();
}
PeerNetwork.setupRemoteMedia = function(user) {
	
	for(let videoElement of user.videoElements)
		videoElement.remove()
	user.videoElements.length = 0
	
	if(!PeerNetwork.enableVideo && !PeerNetwork.enableAudio) return
		
	
	for(let track of input.localUser.mediaStream.getTracks())
		user.peerConnection.addTrack(track, input.localUser.mediaStream);
	
	
	user.mediaStream = new MediaStream();
	
	
	user.peerConnection.ontrack = event => {
		core.log("#peer <"+user.id+"> Add track");
		event.streams[0].getTracks().forEach(track => {
			user.mediaStream.addTrack(track);
		});
	}
	user.peerConnection.onremovetrack = event => {
		core.log("#peer <"+user.id+"> Remove track");
	}
}
PeerNetwork.createVideoElement = function(stream, local) {
	let el = document.createElement("video")
	el.style = "border-radius: 500px; object-fit: cover; position:absolute; top:0px; left:0px; z-index:10000; visibility:hidden; pointer-events: none; user-select: none; "+(local ? "transform: scaleX(-1)" : "")
	el.autoplay = true
	el.playsinline = true
	el.controls = false
	el.muted = local
	el.srcObject = stream
	document.body.appendChild(el)
	return el
}
PeerNetwork.removeVideoElement = function(videoElement) {
	videoElement.remove()
}
PeerNetwork.updateVideoElement = function(videoElement, x, y, sizeX, sizeY, radius) {
	videoElement.style.left = (x-sizeX/2)+"px"
	videoElement.style.top = (y-sizeY/2)+"px"
	videoElement.style.width = sizeX+"px"
	videoElement.style.height = sizeY+"px"
	videoElement.style.visibility = "visible"
	videoElement.style.borderRadius = radius+"px"
}
PeerNetwork.setAudioMuted = function(audioElement, muted) {
	if(audioElement) audioElement.muted = muted
}
var Physics; if(!Physics) Physics = {};
Physics.init = function() {
	Physics.world = null;
	Physics.scale = 100;
}
Physics.start = function() {
	if(window.world) _b2World_Delete(world)
	window.world = new b2World(new b2Vec2(0, 10))
}
Physics.step = function() {
	if(window.world) window.world.Step(1/core.targetFps, 8, 3)
}
Physics.destroy = function(body) {
	world.DestroyBody(body.body)
}
Physics.createCircle = function(pos, radius, type) {
	let bodyDef = new b2BodyDef()
	bodyDef.type = type
	bodyDef.position = new b2Vec2(pos.x/Physics.scale, pos.y/Physics.scale)
	let body = window.world.CreateBody(bodyDef)
	let shape = new b2CircleShape
	shape.radius = radius/Physics.scale
	body.CreateFixtureFromShape(shape, type == 2 ? 1 : 0)
	return new PhysicsBody(body)
}
Physics.createRectangle = function(pos, size, type) {
	let bodyDef = new b2BodyDef()
	bodyDef.type = type
	bodyDef.position = new b2Vec2(pos.x/Physics.scale, pos.y/Physics.scale)
	let body = window.world.CreateBody(bodyDef)
	let shape = new b2PolygonShape
	shape.SetAsBoxXY(size.x/Physics.scale/2, size.y/Physics.scale/2)
	body.CreateFixtureFromShape(shape, type == 2 ? 1 : 0)
	return new PhysicsBody(body)
}
Physics.createPolygon = function(pos, vertices, closed, type) {
	let bodyDef = new b2BodyDef()
	bodyDef.type = type
	bodyDef.position = new b2Vec2(pos.x/Physics.scale, pos.y/Physics.scale)
	let body = window.world.CreateBody(bodyDef)
	let shape = new b2ChainShape();
	for(let v of vertices)
		shape.vertices.push(new b2Vec2(v.x/Physics.scale, v.y/Physics.scale));
	if(closed) shape.CreateLoop();
	body.CreateFixtureFromShape(shape, type == 2 ? 1 : 0)
	return new PhysicsBody(body)
}
function PhysicsBody(body) {
	this.body = body;
}
PhysicsBody.prototype.position = function() {
	let pos = this.body.GetPosition()
	return new Vector2(pos.x*Physics.scale, pos.y*Physics.scale, null)
}
PhysicsBody.prototype.clone = function() {
	let clone = new _PhysicsBody();
	clone.body = this.body;
	return clone;
}
function _PhysicsBody() {};
_PhysicsBody.prototype = PhysicsBody.prototype;
var ServerNetwork; if(!ServerNetwork) ServerNetwork = {};
ServerNetwork.init = function() {
	ServerNetwork.socket = null;
	ServerNetwork.sendBuffer = new Buffer(null, 1024, 0, 0);
	ServerNetwork.nextConnectionId = 1;
	ServerNetwork.connected = false;
	ServerNetwork.startToConnectTime = Number.MAX_VALUE;
	ServerNetwork.retries = 0;
	ServerNetwork.alreadyJoinedBefore = false;
	ServerNetwork.nextPingTime = 0.0;
	ServerNetwork.fastestPingPongTime = int.maxValue;
	ServerNetwork.pongCount = 0;
	ServerNetwork.calculatedStartTimes = [];
	ServerNetwork.referenceStartTime = 0.0;
	ServerNetwork.pingPongTimes = [];
	ServerNetwork.inputsSentPos = 0;
}
ServerNetwork.tick = function() {
	let now = Date.now();
	if(!ServerNetwork.connected && now > (ServerNetwork.startToConnectTime + 5000)) {
		core.log(("#server WebSocket not connected after "+(now - ServerNetwork.startToConnectTime).toString()+" ms -> Reconnecting"));
		ServerNetwork.setup();
		ServerNetwork.retries++;
	}
	if((core.mode == 1/*Ping*/ || core.mode == 3/*Connected*/) && now >= ServerNetwork.nextPingTime) {
		ServerNetwork.sendBuffer.reset();
		ServerNetwork.sendBuffer.writeInt8(2/*Ping*/);
		ServerNetwork.sendBuffer.writeFloat64(now);
		ServerNetwork.send(ServerNetwork.sendBuffer);
		ServerNetwork.nextPingTime = now + ((core.mode == 1/*Ping*/ ? 200 : (ServerNetwork.pongCount < 20 ? 1000 : 30000)));
	}
}
ServerNetwork.setup = function() {
	ServerNetwork.startToConnectTime = Date.now()
	ServerNetwork.connected = false
	
	if(ServerNetwork.socket) {
		core.log("#server Closing Previous Websocket");
		ServerNetwork.socket.onopen = null
		ServerNetwork.socket.onclose = null
		ServerNetwork.socket.onmessage = null
		ServerNetwork.socket.onerror = null
		ServerNetwork.socket.close()
	}
	
	core.log("#server Creating Websocket");
	if(location.href.indexOf("localhost") != -1) ServerNetwork.socket = new WebSocket("ws://localhost:3112");
	else ServerNetwork.socket = new WebSocket("wss://"+location.host+":3112");
	ServerNetwork.socket.binaryType = "arraybuffer";
	
	ServerNetwork.socket.onopen = () => {
		core.log("#server Websocket Open");
		ServerNetwork.connected = true;
		if(!ServerNetwork.firstConnectionTime)
			ServerNetwork.firstConnectionTime = Date.now() - ServerNetwork.startToConnectTime;
		ServerNetwork.onConnectedToServer();
	}
	ServerNetwork.socket.onclose = ev => {
		core.log("#server Websocket Closed "+ev.code+" "+ev.reason);
		ServerNetwork.connected = false;
	}
	ServerNetwork.socket.onerror = ev => {
		core.log("#server Websocket Error "+ev);
	}
	ServerNetwork.socket.onmessage = ev => {
		ServerNetwork.onMessageFromServer(new Buffer(ev.data, 0, 0, 0));
	}
}
ServerNetwork.getOrCreateUser = function(id) {
	return input.internalUsers[id] || (input.internalUsers[id] = new InternalUser(id, false, 0, 0, "", "", false, -1, 0, [], new Buffer(null, 1024, 0, 0), 0, null, [], null, 0, null, [], "", false, false, false, 0, "", Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, 0, 0));
}
ServerNetwork.onConnectedToServer = function() {
	core.log("#server Connected to Server"+", input.localUser.id: "+input.localUser.id?.toString()+", core.roomId: "+core.roomId?.toString());
	ServerNetwork.sendJoinMessage(core.roomString, input.localUser.id, _buildVersion);
}
ServerNetwork.bufferedAmount = function() {
	return ServerNetwork.socket.bufferedAmount 
}
ServerNetwork.send = function(buffer) {
	try {
		let data = buffer.toByteArray()
		ServerNetwork.socket.send(data)
		return data.byteLength
	} catch(e) { 
		core.log(e)
		return 0
	}
}
ServerNetwork.onMessageFromServer = function(buffer) {
	let type = buffer.readInt8();
	if(type == 1/*JoinResponse*/) {
		ServerNetwork.onJoinResponse(buffer);
	} else {
		if(type == 3/*Pong*/) {
			ServerNetwork.onPong(buffer);
		} else {
			if(type == 4/*Signal*/) {
				ServerNetwork.onSignal(buffer);
			} else {
				if(type == 5/*Ice*/) {
					ServerNetwork.onIce(buffer);
				} else {
					if(type == 6/*Tick*/) {
						ServerNetwork.onTick(buffer);
					} else {
						if(type == 7/*Switch*/) {
							ServerNetwork.onSwitch(buffer);
						} else {
							if(type == 8/*Reload*/) {
								ServerNetwork.onReload(buffer);
							}
						}
					}
				}
			}
		}
	}
}
ServerNetwork.sendJoinMessage = function(roomId, userId, version) {
	ServerNetwork.sendBuffer.reset();
	ServerNetwork.sendBuffer.writeInt8(0/*Join*/);
	ServerNetwork.sendBuffer.writeString(roomId);
	ServerNetwork.sendBuffer.writeInt16(userId);
	ServerNetwork.sendBuffer.writeInt16(version);
	ServerNetwork.send(ServerNetwork.sendBuffer);
}
ServerNetwork.onJoinResponse = function(buffer) {
	if(ServerNetwork.alreadyJoinedBefore) {
		return;
	}
	ServerNetwork.alreadyJoinedBefore = true;
	try {
		let roomId = Math.floor(buffer.readFloat64());
		let userId = buffer.readInt32();
		let version = buffer.readInt32();
		let seed = buffer.readString();
		let serverStartTime = buffer.readFloat64();
		let userCount = buffer.readInt16();
		for(let i=0; i<userCount; ++i) {
			let id = buffer.readInt32();
			let user = null;
			if(id == userId) {
				user = (input.internalUsers.hasOwnProperty(id) ? input.internalUsers[id] : input.internalUsers[id] = input.localUser);
			} else {
				user = (input.internalUsers.hasOwnProperty(id) ? input.internalUsers[id] : input.internalUsers[id] = new InternalUser(0, false, ServerNetwork.nextConnectionId++, 0, "", "", false, -1, 0, [], new Buffer(null, 1024, 0, 0), 0, null, [], null, 0, null, [], "", true, false, false, 0, "", Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, 0, 0));
			}
			user.id = id;
			core.log("#onJoinResponse"+", id: "+id?.toString()+", user.local: "+user.local+", user.inputs: "+(user.inputs?.toString() || "null"));
		}
		if(roomId != core.roomId) {
			core.log(("#server Received room id "+roomId?.toString()));
			if(core.isPremiere) history.pushState(null, "", "/"+core.gameId+"/"+roomId?.toString());
			core.roomId = roomId;
		}
		if(version != _buildVersion) {
			alert("You are using an old version of this application. Please refresh your browser.");
		}
		ServerNetwork.inputsSentPos = input.localUser.inputs.writePos;
		input.localUser.id = userId;
		math.setRandomSeed(seed);
		PeerNetwork.retries = 0;
		PeerNetwork.dataChannelId = 0;
		core.serverStartTime = serverStartTime;
		core.mode = 1/*Ping*/;
		core.storeUserId();
		core.log(("#server Joining room "+roomId?.toString()+" as user "+userId?.toString()));
		for(let i=0, _subject=input.internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			if((it != null) && !it.local) {
				PeerNetwork.initiate(it);
			}
		}}
	} catch(error) {
		core.onError(error);
	}
}
ServerNetwork.onPong = function(buffer) {
	let now = Date.now();
	let timeSinceStart = buffer.readFloat64();
	let pingTime = buffer.readFloat64();
	let pingPongTime = now - pingTime;
	let calculatedStartTime = now - pingPongTime / 2 - timeSinceStart;
	let deltaFromAverage = Math.round(calculatedStartTime - core.startTime);
	statistics.serverPings.push(pingPongTime);
	ServerNetwork.pongCount++;
	ServerNetwork.pingPongTimes.push(pingPongTime)
	if(ServerNetwork.pingPongTimes.length > 30) ServerNetwork.pingPongTimes.splice(0, 1);
	let pingPongTimesAverage = ServerNetwork.pingPongTimes.average3();
	if(pingPongTime > 400 || (ServerNetwork.pingPongTimes.length >= 15 && pingPongTime > pingPongTimesAverage * 2)) {
		core.log("#server ignoring ping-pong"+", pingPongTimes.length: "+ServerNetwork.pingPongTimes.length?.toString()+", pingPongTimesAverage: "+pingPongTimesAverage.toString());
		return;
	}
	statistics.addInfo("from average", deltaFromAverage);
	if(pingPongTime < ServerNetwork.fastestPingPongTime) {
		ServerNetwork.fastestPingPongTime = pingPongTime;
		ServerNetwork.referenceStartTime = calculatedStartTime;
		core.startTime = ServerNetwork.referenceStartTime;
		core.log("#server New fastest pingPongTime"+", pongCount: "+ServerNetwork.pongCount?.toString()+", now: "+now.toString()+", pingPongTime: "+pingPongTime.toString()+", timeSinceStart: "+timeSinceStart.toString()+", core.startTime: "+core.startTime.toString()+", referenceStartTime: "+ServerNetwork.referenceStartTime.toString());
	}
	if(ServerNetwork.pongCount >= 5) {
		core.startConnected(Math.floor((now - core.startTime) / core.frameTime) + 1);
	}
}
ServerNetwork.sendSignal = function(receiverId, type, sdp) {
	ServerNetwork.sendBuffer.reset();
	ServerNetwork.sendBuffer.writeInt8(4/*Signal*/);
	ServerNetwork.sendBuffer.writeInt32(receiverId);
	ServerNetwork.sendBuffer.writeInt32(input.localUser.id);
	ServerNetwork.sendBuffer.writeString(type);
	ServerNetwork.sendBuffer.writeString(sdp);
	ServerNetwork.send(ServerNetwork.sendBuffer);
}
ServerNetwork.onSignal = function(buffer) {
	let receiverId = buffer.readInt32();
	let senderId = buffer.readInt32();
	let type = buffer.readString();
	let sdp = buffer.readString();
	let sender = ServerNetwork.getOrCreateUser(senderId);
	if(type == "offer") {
		sender.connectionId = ServerNetwork.nextConnectionId++;
		PeerNetwork.onReceivedOffer(sender, sdp);
	} else {
		if(type == "answer") {
			PeerNetwork.onReceivedAnswer(sender, sdp);
		}
	}
}
ServerNetwork.sendIce = function(receiverId, candidate) {
	ServerNetwork.sendBuffer.reset();
	ServerNetwork.sendBuffer.writeInt8(5/*Ice*/);
	ServerNetwork.sendBuffer.writeInt32(receiverId);
	ServerNetwork.sendBuffer.writeInt32(input.localUser.id);
	ServerNetwork.sendBuffer.writeString(candidate);
	ServerNetwork.send(ServerNetwork.sendBuffer);
}
ServerNetwork.onIce = function(buffer) {
	let receiverId = buffer.readInt32();
	let senderId = buffer.readInt32();
	let candidate = buffer.readString();
	let sender = ServerNetwork.getOrCreateUser(senderId);
	PeerNetwork.onIce(sender, candidate);
}
ServerNetwork.sendInputs = function(inputFrame) {
	let inputs = input.localUser.inputs;
	let length = inputs.writePos - ServerNetwork.inputsSentPos;
	ServerNetwork.sendBuffer.reset();
	ServerNetwork.sendBuffer.writeInt8(6/*Tick*/);
	ServerNetwork.sendBuffer.writeInt32(input.localUser.id);
	ServerNetwork.sendBuffer.writeInt32(inputFrame);
	ServerNetwork.sendBuffer.writeBuffer2(inputs, ServerNetwork.inputsSentPos, length);
	ServerNetwork.sendBuffer.writeInt(core.lastChecksumFrame);
	ServerNetwork.sendBuffer.writeFloat64(core.checksums[core.lastChecksumFrame] || 0);
	ServerNetwork.send(ServerNetwork.sendBuffer);
	ServerNetwork.inputsSentPos = inputs.writePos;
	core.tickMessageSize = ServerNetwork.sendBuffer.writePos;
}
ServerNetwork.onTick = function(buffer) {
	let senderId = buffer.readInt32();
	let sender = ServerNetwork.getOrCreateUser(senderId);
	let prevWritePos = sender.inputs.writePos;
	sender.inputFrame = buffer.readInt32();
	buffer.readBuffer(sender.inputs, prevWritePos);
}
ServerNetwork.sendSwitch = function(mode, sendInterval) {
	ServerNetwork.sendBuffer.reset();
	ServerNetwork.sendBuffer.writeInt8(7/*Switch*/);
	ServerNetwork.sendBuffer.writeInt32(mode);
	ServerNetwork.sendBuffer.writeInt32(sendInterval);
	ServerNetwork.send(ServerNetwork.sendBuffer);
}
ServerNetwork.onSwitch = function(buffer) {
	let mode = buffer.readInt32();
	core.sendInterval = buffer.readInt32();
	if(mode != core.sendInputsMode) {
		core.sendInputsMode = mode;
	}
}
ServerNetwork.sendReload = function(newRoom, newUserId, keepMaster) {
	let url = "/"+core.gameId+"/"+((newRoom ? core.roomId + ((core.roomId < 0 ? -1 : 1)) : core.roomId))?.toString();
	ServerNetwork.sendBuffer.reset();
	ServerNetwork.sendBuffer.writeInt8(8/*Reload*/);
	ServerNetwork.sendBuffer.writeBool(keepMaster);
	ServerNetwork.sendBuffer.writeBool(newUserId);
	ServerNetwork.sendBuffer.writeString(url);
	ServerNetwork.send(ServerNetwork.sendBuffer);
}
ServerNetwork.onReload = function(buffer) {
	let keepMaster = buffer.readBool();
	let newUserId = buffer.readBool();
	let url = buffer.readString();
	if(!newUserId) {
		url += "u"+input.localUser.id?.toString();
	}
	location.href = url;
}
var snapshot; if(!snapshot) snapshot = {};
snapshot.itou = function(i) {
	i += 32;
	if (i > 33 && i < 39) {
		i++;
	} else if (i > 38 && i < 44) {
		i += 2;
	} else if (i > 43 && i < 127) {
		i += 3;
	} else if (i > 126 && i < 55258) {
		i += 37; 
	} else if (i > 55295) {
		i += 8485; 
	}
	return String.fromCharCode(i);
}
snapshot.utoi = function(i) {
	return i - (i > 63743 ? 8517 :
		i > 159 ? 69 :
			i > 46 && i < 130 ? 35 :
				i > 40 && i < 46 ? 34 :
					i > 34 && i < 40 ? 33 :
						32);
}
snapshot.compress = function(input) {
	var _node = function(val) { return {v: val, d: {} }; }
	function itou(i) {
		i += 32;
		if (i > 33 && i < 39) {
			i++;
		} else if (i > 38 && i < 44) {
			i += 2;
		} else if (i > 43 && i < 127) {
			i += 3;
		} else if (i > 126 && i < 55258) {
			i += 37; 
		} else if (i > 55295) {
			i += 8485; 
		}
		return String.fromCharCode(i);
	}
	if (input === null) return "";
	let i = 0,
		j = 0,
		value = 0,
		dictionary = { d: {} },
		freshNode = true,
		c = 0,
		node = _node(2), 
		nextNode,
		enlargeIn = 2,
		dictSize = 3,
		numBits = 2,
		data = [],
		data_val = 0,
		data_position = 0;
	
	if (input.length) {
		
		
		value = input.length;
		data.push(itou(value / 40000000 & 0x7FFF));
		data.push(itou((value >>> 15) & 0x7FFF));
		data.push(itou(value & 0x7FFF));
		
		
		
		
		
		
		
		c = input[0];
		
		
		
		
		for (i = 0; i < numBits; i++) {
			
			data_val <<= 1;
			if (++data_position === 15) {
				data_position = 0;
				data.push(itou(data_val));
				data_val = 0;
			}
		}
		
		for (i = 0; i < 8; i++) {
			
			data_val = c >> i & 1 | data_val << 1;
			if (++data_position === 15) {
				data_position = 0;
				data.push(itou(data_val));
				data_val = 0;
			}
		}
		
		
		dictionary[c] = node;
		
		for (j = 1; j < input.length; j++) {
			c = input[j];
			
			nextNode = node.d[c];
			if (nextNode) {
				
				node = nextNode;
			} else {
				
				
				
				
				
				
				
				if (freshNode) {
					
					
					freshNode = false;
				} else {
					
					value = node.v;
					for (i = 0; i < numBits; i++) {
						
						data_val = value >> i & 1 | data_val << 1;
						if (++data_position === 15) {
							data_position = 0;
							data.push(itou(data_val));
							data_val = 0;
						}
					}
				}
				
				
				
				if (dictionary[c] === undefined) {
					
					if (--enlargeIn === 0) {
						enlargeIn = 1 << numBits++;
					}
					
					
					for (i = 0; i < numBits; i++) {
						data_val <<= 1;
						if (++data_position === 15) {
							data_position = 0;
							data.push(itou(data_val));
							data_val = 0;
						}
					}
					for (i = 0; i < 8; i++) {
						data_val = c >> i & 1 | data_val << 1;
						if (++data_position === 15) {
							data_position = 0;
							data.push(itou(data_val));
							data_val = 0;
						}
					}
					dictionary[c] = _node(dictSize++);
					
					
					freshNode = true;
				}
				
				node.d[c] = _node(dictSize++);
				
				if (--enlargeIn === 0) {
					enlargeIn = 1 << numBits++;
				}
				
				node = dictionary[c];
			}
		}
		
		
		if (freshNode) {
			
			freshNode = false;
		} else {
			
			value = node.v;
			for (i = 0; i < numBits; i++) {
				
				data_val = value >> i & 1 | data_val << 1;
				if (++data_position === 15) {
					data_position = 0;
					data.push(itou(data_val));
					data_val = 0;
				}
			}
		}
		
		
		if (dictionary[c] === undefined) {
			
			if (--enlargeIn === 0) {
				enlargeIn = 1 << numBits++;
			}
			for (i = 0; i < numBits; i++) {
				data_val <<= 1;
				if (++data_position === 15) {
					data_position = 0;
					data.push(itou(data_val));
					data_val = 0;
				}
			}
			for (i = 0; i < 8; i++) {
				data_val = c >> i & 1 | data_val << 1;
				if (++data_position === 15) {
					data_position = 0;
					data.push(itou(data_val));
					data_val = 0;
				}
			}
		}
		
		if (--enlargeIn === 0) {
			enlargeIn = 1 << numBits++;
		}
	}
	
	
	for (i = 0; i < numBits; i++) {
		
		data_val = 1 >> i | data_val << 1;
		if (++data_position === 15) {
			data_position = 0;
			data.push(itou(data_val));
			data_val = 0;
		}
	}
	
	
	data_val <<= 15 - data_position;
	data.push(itou(data_val));
	
	data.push(" ");
	return data.join("");
}
snapshot.decompress = function(compressed) {
	function utoi(i) {
		return i - (i > 63743 ? 8517 :
			i > 159 ? 69 :
				i > 46 && i < 130 ? 35 :
					i > 40 && i < 46 ? 34 :
						i > 34 && i < 40 ? 33 :
							32);
	}
	if (compressed === null || compressed.length < 4) return null;
	
	let length = compressed.length,
		getNextValue = function (index) { return utoi(compressed.charCodeAt(index)); };
	let dictionary = [0, 1],
		enlargeIn = 1,
		dictSize = 3,
		numBits = 2,
		bytes = null,
		bytes_concat = null,
		result = new Uint8Array(
			getNextValue(0) * 0x40000000 +
			(getNextValue(1) << 15) +
			getNextValue(2)),
		result_index = 0,
		bits = 0,
		maxPower = 2,
		power = 0,
		data_val = getNextValue(3),
		data_position = 15,
		data_index = 4;
	
	
	
	while (power < maxPower) {
		
		bits += (data_val >> --data_position & 1) << power++;
		if (data_position === 0) {
			data_position = 15;
			data_val = getNextValue(data_index++);
		}
	}
	
	if (bits === 1) {
		return null;
	}
	
	
	bits = power = 0;
	while (power < 8) {
		
		bits += (data_val >> --data_position & 1) << power++;
		if (data_position === 0) {
			data_position = 15;
			data_val = getNextValue(data_index++);
		}
	}
	bytes = [bits];
	dictionary[2] = bytes;
	result[result_index++] = bits;
	
	
	while (data_index <= length) {
		
		maxPower = numBits;
		bits = power = 0;
		while (power < maxPower) {
			
			bits += (data_val >> --data_position & 1) << power++;
			if (data_position === 0) {
				data_position = 15;
				data_val = getNextValue(data_index++);
			}
		}
		
		
		if (!bits) {
			bits = power = 0;
			while (power < 8) {
				
				bits += (data_val >> --data_position & 1) << power++;
				if (data_position === 0) {
					data_position = 15;
					data_val = getNextValue(data_index++);
				}
			}
			dictionary[dictSize] = [bits];
			bits = dictSize++;
			if (--enlargeIn === 0) {
				enlargeIn = 1 << numBits++;
			}
		} else if (bits === 1) {
			
			return result;
		}
		
		if (bits > dictionary.length) {
			return null;
		}
		bytes_concat = bits < dictionary.length ? dictionary[bits] : bytes.concat(bytes[0]);
		for (let i = 0; i < bytes_concat.length; i++) {
			result[result_index++] = bytes_concat[i];
		}
		dictionary[dictSize++] = bytes.concat(bytes_concat[0]);
		bytes = bytes_concat;
		
		if (--enlargeIn === 0) {
			enlargeIn = 1 << numBits++;
		}
	
	}
	return null;
}
snapshot.testCompression = function() {
	console.log("Testing utoi/itou functions");
	let utoiMismatches = [];
	for (let i = 0; i < 1 << 15; i++) {
		let j = LZ.utoi(LZ.itou(i).charCodeAt(0));
		if (i !== j) {
			utoiMismatches.push({itou: i, utio: j});
		}
	}
	
	if (utoiMismatches.length) {
		console.log("Errors in itou/utoi conversion detected:", utoiMismatches);
	} else {
		console.log("No errors in itou/utoi conversion detected");
	}
	
	let input = new Uint16Array(1 << 15);
	for (let i = 0; i < input.length; i++) {
		input[i] = i>>4;
	}
	let inputUint8 = new Uint8Array(input.buffer);
	let compressed = LZ.compress(inputUint8);
	let decompressed = new Uint16Array(LZ.decompress(compressed).buffer);
	let mismatches = [];
	for (let i = 0; i < input.length; i++) {
		if (input[i] !== decompressed[i]) {
			mismatches.push({index: i, input: input[i], decompressed: decompressed[i]});
		}
	}
	console.log({
		compressed,
		mismatches,
		length: compressed.length,
		inputLength: input.length,
	});
}
function Sound(file, duration, fadeVolume, audioElement) {
	this.file = file;
	this.duration = duration;
	this.fadeVolume = fadeVolume;
	this.audioElement = audioElement;
	audio.sounds.push(this);
}
Sound.prototype.open = function() {
	return new Promise((resolve, reject) => {
		this.nextAudioElement = new Audio();
		this.nextAudioElement.oncanplaythrough = () => resolve();
		this.nextAudioElement.onerror = () => reject();
		this.nextAudioElement.src = Platform.getAbsoluteUrl(this.file); 
	})
}
Sound.prototype.volume = function(value) {
	this.fadeVolume = value
	if(this.audioElement) this.audioElement.volume = this.fadeVolume * audio.volume
}
Sound.prototype.updateVolume = function() {
	if(this.audioElement) this.audioElement.volume = this.fadeVolume * audio.volume
}
Sound.prototype.stop = function() {
	if(this.audioElement) this.audioElement.pause()
}
Sound.prototype.play = function(needsToBeCertain) {
	if(needsToBeCertain && !input.isCertain) {
		return;
	}
	let playingSound = audio.playingSounds.find(a => a.sound == this && a.frame == core.frame);
	if(!(playingSound != null)) {
		audio.playingSounds.push(playingSound = new PlayingSound(this, core.frame, true));
		if(core.isPremiere) {
			this.doPlay(playingSound);
		}
	} else {
		playingSound.isConfirmed = true;
	}
}
Sound.prototype.currentTime = function(value) {
	if(this.audioElement) this.audioElement.currentTime = value
}
Sound.prototype.doPlay = function(ps) {
	
	if(!this.nextAudioElement) this.preloadForNextPlayback();
		
	
	this.fadeVolume = 1;
	this.audioElement = this.nextAudioElement;
	this.audioElement.volume = audio.volume;
	this.audioElement.onended = () => audio.playingSounds.remove(ps);
	this.audioElement.play();
	this.preloadForNextPlayback()
}
Sound.prototype.preloadForNextPlayback = async function() {
	this.nextAudioElement = new Audio();
	if(PeerNetwork.audioOutputId && this.nextAudioElement.setSinkId) 
		await this.nextAudioElement.setSinkId(PeerNetwork.audioOutputId);
	this.nextAudioElement.src = _basePath+this.file;
}
Sound.prototype.isPlaying = function() {
	return audio.playingSounds.some(a => a.sound == this && a.frame < core.frame);
}
Sound.prototype.fadeOut = function(duration, delay) {
	fx.add(new FadeSoundAnimation(Time.now + delay, duration, null, 1, -1, this));
	return this;
}
Sound.prototype.clone = function() {
	let clone = new _Sound();
	clone.file = this.file;
	clone.duration = this.duration;
	clone.fadeVolume = this.fadeVolume;
	clone.audioElement = this.audioElement;
	return clone;
}
function _Sound() {};
_Sound.prototype = Sound.prototype;
Sound.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.file);
	buffer.writeFloat64(this.duration);
	buffer.writeFloat64(this.fadeVolume);
}
Sound.prototype.deserialize_internal = function(buffer) {
	this.file = buffer.readString();
	this.duration = buffer.readFloat64();
	this.fadeVolume = buffer.readFloat64();
}
Sound.prototype.serialize_external = function(buffer) {
	buffer.writeString("file");
	buffer.writeString(this.file);
	buffer.writeString("duration");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.duration);
	buffer.writeString("fadeVolume");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.fadeVolume);
	buffer.writeString("");
}
Sound.prototype.deserialize_external = function(buffer) {
	let file_is_set = false, duration_is_set = false, fadeVolume_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "file":
				this.file = buffer.readString();
				file_is_set = true;
				break;
			case "duration":
				buffer.readInt32();
				this.duration = buffer.readFloat64();
				duration_is_set = true;
				break;
			case "fadeVolume":
				buffer.readInt32();
				this.fadeVolume = buffer.readFloat64();
				fadeVolume_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!file_is_set) this.file = "";
				if(!duration_is_set) this.duration = 0.0;
				if(!fadeVolume_is_set) this.fadeVolume = 1;
				return;
		}
	}
}
function PlayingSound(sound, frame, isConfirmed) {
	this.sound = sound;
	this.frame = frame;
	this.isConfirmed = isConfirmed;
}
PlayingSound.prototype.clone = function() {
	let clone = new _PlayingSound();
	clone.sound = this.sound;
	clone.frame = this.frame;
	clone.isConfirmed = this.isConfirmed;
	return clone;
}
function _PlayingSound() {};
_PlayingSound.prototype = PlayingSound.prototype;
SpeechSynthesisVoice.prototype.serialize_internal = function(buffer) {
	buffer.writeBool(this.default);
	buffer.writeString(this.lang);
	buffer.writeBool(this.localService);
	buffer.writeString(this.name);
	buffer.writeString(this.voiceURI);
}
SpeechSynthesisVoice.prototype.deserialize_internal = function(buffer) {
	this.default = buffer.readBool();
	this.lang = buffer.readString();
	this.localService = buffer.readBool();
	this.name = buffer.readString();
	this.voiceURI = buffer.readString();
}
SpeechSynthesisVoice.prototype.serialize_external = function(buffer) {
	buffer.writeString("default");
	buffer.writeInt32(1);
	buffer.writeBool(this.default);
	buffer.writeString("lang");
	buffer.writeString(this.lang);
	buffer.writeString("localService");
	buffer.writeInt32(1);
	buffer.writeBool(this.localService);
	buffer.writeString("name");
	buffer.writeString(this.name);
	buffer.writeString("voiceURI");
	buffer.writeString(this.voiceURI);
	buffer.writeString("");
}
SpeechSynthesisVoice.prototype.deserialize_external = function(buffer) {
	let default_is_set = false, lang_is_set = false, localService_is_set = false, name_is_set = false, voiceURI_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "default":
				buffer.readInt32();
				this.default = buffer.readBool();
				default_is_set = true;
				break;
			case "lang":
				this.lang = buffer.readString();
				lang_is_set = true;
				break;
			case "localService":
				buffer.readInt32();
				this.localService = buffer.readBool();
				localService_is_set = true;
				break;
			case "name":
				this.name = buffer.readString();
				name_is_set = true;
				break;
			case "voiceURI":
				this.voiceURI = buffer.readString();
				voiceURI_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!default_is_set) this.default = false;
				if(!lang_is_set) this.lang = "";
				if(!localService_is_set) this.localService = false;
				if(!name_is_set) this.name = "";
				if(!voiceURI_is_set) this.voiceURI = "";
				return;
		}
	}
}
function VoicePreference(lang, langAndCountry, names, voice) {
	this.lang = lang;
	this.langAndCountry = langAndCountry;
	this.names = names;
	this.voice = voice;
}
VoicePreference.prototype.clone = function() {
	let clone = new _VoicePreference();
	clone.lang = this.lang;
	clone.langAndCountry = this.langAndCountry;
	clone.names = this.names;
	clone.voice = this.voice;
	return clone;
}
function _VoicePreference() {};
_VoicePreference.prototype = VoicePreference.prototype;
VoicePreference.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.lang);
	buffer.writeString(this.langAndCountry);
	let names = this.names
	if(names) {
		var index = _objectCacheIndex.get(names);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(names, index = _objectCache.length);
			_objectCache.push(names);
			buffer.writeInt32(-index);
			names._objectIndex = index;
			buffer.writeInt32(names.length);
			for(let i=0, len=names.length; i<len; ++i) {
				buffer.writeString(names[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let voice = this.voice
	if(voice) {
		var index = _objectCacheIndex.get(voice);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(voice, index = _objectCache.length);
			_objectCache.push(voice);
			buffer.writeInt32(-index);
			voice._objectIndex = index;
			voice.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
VoicePreference.prototype.deserialize_internal = function(buffer) {
	this.lang = buffer.readString();
	this.langAndCountry = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.names = _objectCache[index];
	} else {
		let names = this.names
		if(!names || names._objectIndex != -index) this.names = names = [];
		_objectCache[-index] = names;
		for(let i=0, len = names.length = buffer.readInt32(); i<len; ++i) {
				names[i] = buffer.readString();
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.voice = _objectCache[index];
	} else {
		let voice = this.voice
		if(!voice || voice._objectIndex != -index)
			this.voice = voice = new _SpeechSynthesisVoice();
		(_objectCache[-index] = voice).deserialize_internal(buffer);
	}
}
VoicePreference.prototype.serialize_external = function(buffer) {
	buffer.writeString("lang");
	buffer.writeString(this.lang);
	buffer.writeString("langAndCountry");
	buffer.writeString(this.langAndCountry);
	buffer.writeString("names");
	let names = this.names
	let names_startPos = buffer.reserveSize();
	if(names) {
		var index = _objectCacheIndex.get(names);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(names, index = _objectCache.length);
			_objectCache.push(names);
			buffer.writeInt32(-index);
			names._objectIndex = index;
			buffer.writeInt32(names.length);
			for(let i=0, len=names.length; i<len; ++i) {
				buffer.writeString(names[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(names_startPos);
	buffer.writeString("voice");
	let voice_startPos = buffer.reserveSize();
	let voice = this.voice
	if(voice) {
		var index = _objectCacheIndex.get(voice);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(voice, index = _objectCache.length);
			_objectCache.push(voice);
			buffer.writeInt32(-index);
			voice._objectIndex = index;
			voice.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(voice_startPos);
	buffer.writeString("");
}
VoicePreference.prototype.deserialize_external = function(buffer) {
	let lang_is_set = false, langAndCountry_is_set = false, names_is_set = false, voice_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "lang":
				this.lang = buffer.readString();
				lang_is_set = true;
				break;
			case "langAndCountry":
				this.langAndCountry = buffer.readString();
				langAndCountry_is_set = true;
				break;
			case "names":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.names = _objectCache[index];
				} else {
					let names = this.names
					if(!names || names._objectIndex != -index) this.names = names = [];
					_objectCache[-index] = names;
					for(let i=0, len = names.length = buffer.readInt32(); i<len; ++i) {
							names[i] = buffer.readString();
					}
				}
				names_is_set = true;
				break;
			case "voice":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.voice = _objectCache[index];
				} else {
					let voice = this.voice
					if(!voice || voice._objectIndex != -index)
						this.voice = voice = new _SpeechSynthesisVoice();
					(_objectCache[-index] = voice).deserialize_external(buffer);
				}
				voice_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!lang_is_set) this.lang = "";
				if(!langAndCountry_is_set) this.langAndCountry = "";
				if(!names_is_set) this.names = [];
				if(!voice_is_set) this.voice = null;
				return;
		}
	}
}
var speech; if(!speech) speech = {};
speech.init = function() {
	speech.voiceIndex = 0;
	speech.voices = [];
	speech.voiceOverride = null;
	speech.currentVoice = null;
	speech.rate = 1;
	speech.lastWord = "";
	speech.preferences = new Map([["Spanish", new VoicePreference("es", "es-ES", ["Microsoft Sofia", "Microsoft Catalina", "Microsoft Ximena", "Google", "Paulina", "Mónica"], null)], ["German", new VoicePreference("de", "de-DE", ["Microsoft", "Google"], null)], ["English", new VoicePreference("en", "en-US", ["Microsoft", "Google"], null)]]);
}
speech.nextVoice = function() {
	speech.voiceOverride = speech.voices[(speech.voiceIndex = (((speech.voiceIndex+1) % speech.voices.length) + speech.voices.length) % speech.voices.length)];
}
speech.setup = function(language, rate) {
	var utterance = new SpeechSynthesisUtterance("");
	
	let voice = speech.getVoice();
	utterance.lang = voice.langAndCountry;
	utterance.voice = speech.currentVoice = voice.voice;
	utterance.rate = speech.rate = rate;
	speechSynthesis.speak(utterance);
}
speech.getVoice = function(language) {
	let pref = speech.preferences.get(language) || speech.preferences.get("English");
	if(pref.voice == null) {
		let allVoices = speechSynthesis.getVoices();
		speech.voices = allVoices.filter(a => a.lang.startsWith(pref.lang));
		for(let i=0, _subject=pref.names, _len=_subject.length; i<_len; ++i) { let name = _subject[i]; {
			let voice = speech.voices.find(a => a.name.includes(name));
			if(voice) {
				pref.voice = voice;
				break;
			}
		}}
	}
	return pref;
}
speech.say = function(value, language, rate, then) {
	if(core.isPremiere && input.isCertain) {
		speech.lastWord = value;
		speechSynthesis.cancel();
		const utterance = new SpeechSynthesisUtterance(value);
		let voice = speech.getVoice(language);
		utterance.lang = voice.langAndCountry;
		utterance.voice = speech.currentVoice = speech.voiceOverride || voice.voice;
		utterance.rate = rate;
		if(then != null) {
			utterance.onend = () => {
				System.print("say onend");
				then();
			} 
		}
		speechSynthesis.speak(utterance); 
	}
}
function FadeAnimation(startTime, duration, object, startValue, delta, removeWhenDone) {
	Animation.call(this, startTime, duration, object);
	this.type = "FadeAnimation";
	this.startValue = startValue;
	this.delta = delta;
	this.removeWhenDone = removeWhenDone;
}
function __FadeAnimationPrototype() { this.constructor = FadeAnimation; }
__FadeAnimationPrototype.prototype = Animation.prototype;
FadeAnimation.prototype = new __FadeAnimationPrototype();
FadeAnimation.prototype.tick = function(progress) {
	Animation.prototype.tick.call(this, progress);
	this.object.alpha = this.startValue + this.delta * progress;
	if(progress >= 1 && this.removeWhenDone) {
		Framework.objects.remove(this.object);
	}
}
FadeAnimation.prototype.clone = function() {
	let clone = new _FadeAnimation();
	clone.type = this.type;
	clone.startTime = this.startTime;
	clone.duration = this.duration;
	clone.object = this.object;
	clone.startValue = this.startValue;
	clone.delta = this.delta;
	clone.removeWhenDone = this.removeWhenDone;
	return clone;
}
function _FadeAnimation() {};
_FadeAnimation.prototype = FadeAnimation.prototype;
FadeAnimation.prototype.serialize_internal = function(buffer) {
	Animation.prototype.serialize_internal.call(this, buffer);
	buffer.writeFloat64(this.startValue);
	buffer.writeFloat64(this.delta);
	buffer.writeBool(this.removeWhenDone);
}
FadeAnimation.prototype.deserialize_internal = function(buffer) {
	Animation.prototype.deserialize_internal.call(this, buffer);
	this.startValue = buffer.readFloat64();
	this.delta = buffer.readFloat64();
	this.removeWhenDone = buffer.readBool();
}
FadeAnimation.prototype.serialize_external = function(buffer) {
	Animation.prototype.serialize_external.call(this, buffer);
	buffer.writeString("startValue");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.startValue);
	buffer.writeString("delta");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.delta);
	buffer.writeString("removeWhenDone");
	buffer.writeInt32(1);
	buffer.writeBool(this.removeWhenDone);
	buffer.writeString("");
}
FadeAnimation.prototype.deserialize_external = function(buffer) {
	let startValue_is_set = false, delta_is_set = false, removeWhenDone_is_set = false;
	Animation.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "startValue":
				buffer.readInt32();
				this.startValue = buffer.readFloat64();
				startValue_is_set = true;
				break;
			case "delta":
				buffer.readInt32();
				this.delta = buffer.readFloat64();
				delta_is_set = true;
				break;
			case "removeWhenDone":
				buffer.readInt32();
				this.removeWhenDone = buffer.readBool();
				removeWhenDone_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!startValue_is_set) this.startValue = 0.0;
				if(!delta_is_set) this.delta = 0.0;
				if(!removeWhenDone_is_set) this.removeWhenDone = false;
				return;
		}
	}
}
function MoveAnimation(startTime, duration, object, startValue, delta) {
	Animation.call(this, startTime, duration, object);
	this.type = "MoveAnimation";
	this.startValue = startValue?.clone();
	this.delta = delta?.clone();
}
function __MoveAnimationPrototype() { this.constructor = MoveAnimation; }
__MoveAnimationPrototype.prototype = Animation.prototype;
MoveAnimation.prototype = new __MoveAnimationPrototype();
MoveAnimation.prototype.tick = function(progress) {
	Animation.prototype.tick.call(this, progress);
	this.object.position.assign(this.startValue.plus(this.delta.multiply2(progress)));
}
MoveAnimation.prototype.clone = function() {
	let clone = new _MoveAnimation();
	clone.type = this.type;
	clone.startTime = this.startTime;
	clone.duration = this.duration;
	clone.object = this.object;
	clone.startValue = this.startValue.clone();
	clone.delta = this.delta.clone();
	return clone;
}
function _MoveAnimation() {};
_MoveAnimation.prototype = MoveAnimation.prototype;
MoveAnimation.prototype.serialize_internal = function(buffer) {
	Animation.prototype.serialize_internal.call(this, buffer);
	(this.startValue || new _Vector2()).serialize_internal(buffer);
	(this.delta || new _Vector2()).serialize_internal(buffer);
}
MoveAnimation.prototype.deserialize_internal = function(buffer) {
	Animation.prototype.deserialize_internal.call(this, buffer);
	(this.startValue || (this.startValue = new _Vector2())).deserialize_internal(buffer);
	(this.delta || (this.delta = new _Vector2())).deserialize_internal(buffer);
}
MoveAnimation.prototype.serialize_external = function(buffer) {
	Animation.prototype.serialize_external.call(this, buffer);
	buffer.writeString("startValue");
	let startValue_startPos = buffer.reserveSize();
	(this.startValue || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(startValue_startPos);
	buffer.writeString("delta");
	let delta_startPos = buffer.reserveSize();
	(this.delta || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(delta_startPos);
	buffer.writeString("");
}
MoveAnimation.prototype.deserialize_external = function(buffer) {
	let startValue_is_set = false, delta_is_set = false;
	Animation.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "startValue":
				buffer.readInt32();
				(this.startValue || (this.startValue = new _Vector2())).deserialize_external(buffer);
				startValue_is_set = true;
				break;
			case "delta":
				buffer.readInt32();
				(this.delta || (this.delta = new _Vector2())).deserialize_external(buffer);
				delta_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!startValue_is_set) this.startValue = new Vector2(0.0, 0.0, null);
				if(!delta_is_set) this.delta = new Vector2(0.0, 0.0, null);
				return;
		}
	}
}
function ScaleAnimation(startTime, duration, object, startValue, delta) {
	Animation.call(this, startTime, duration, object);
	this.type = "ScaleAnimation";
	this.startValue = startValue?.clone();
	this.delta = delta?.clone();
}
function __ScaleAnimationPrototype() { this.constructor = ScaleAnimation; }
__ScaleAnimationPrototype.prototype = Animation.prototype;
ScaleAnimation.prototype = new __ScaleAnimationPrototype();
ScaleAnimation.prototype.tick = function(progress) {
	Animation.prototype.tick.call(this, progress);
	this.object.size.assign(this.startValue.plus(this.delta.multiply2(progress)));
}
ScaleAnimation.prototype.clone = function() {
	let clone = new _ScaleAnimation();
	clone.type = this.type;
	clone.startTime = this.startTime;
	clone.duration = this.duration;
	clone.object = this.object;
	clone.startValue = this.startValue.clone();
	clone.delta = this.delta.clone();
	return clone;
}
function _ScaleAnimation() {};
_ScaleAnimation.prototype = ScaleAnimation.prototype;
ScaleAnimation.prototype.serialize_internal = function(buffer) {
	Animation.prototype.serialize_internal.call(this, buffer);
	(this.startValue || new _Vector2()).serialize_internal(buffer);
	(this.delta || new _Vector2()).serialize_internal(buffer);
}
ScaleAnimation.prototype.deserialize_internal = function(buffer) {
	Animation.prototype.deserialize_internal.call(this, buffer);
	(this.startValue || (this.startValue = new _Vector2())).deserialize_internal(buffer);
	(this.delta || (this.delta = new _Vector2())).deserialize_internal(buffer);
}
ScaleAnimation.prototype.serialize_external = function(buffer) {
	Animation.prototype.serialize_external.call(this, buffer);
	buffer.writeString("startValue");
	let startValue_startPos = buffer.reserveSize();
	(this.startValue || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(startValue_startPos);
	buffer.writeString("delta");
	let delta_startPos = buffer.reserveSize();
	(this.delta || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(delta_startPos);
	buffer.writeString("");
}
ScaleAnimation.prototype.deserialize_external = function(buffer) {
	let startValue_is_set = false, delta_is_set = false;
	Animation.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "startValue":
				buffer.readInt32();
				(this.startValue || (this.startValue = new _Vector2())).deserialize_external(buffer);
				startValue_is_set = true;
				break;
			case "delta":
				buffer.readInt32();
				(this.delta || (this.delta = new _Vector2())).deserialize_external(buffer);
				delta_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!startValue_is_set) this.startValue = new Vector2(0.0, 0.0, null);
				if(!delta_is_set) this.delta = new Vector2(0.0, 0.0, null);
				return;
		}
	}
}
function RotateAnimation(startTime, duration, object, startValue, delta) {
	Animation.call(this, startTime, duration, object);
	this.type = "RotateAnimation";
	this.startValue = startValue;
	this.delta = delta;
}
function __RotateAnimationPrototype() { this.constructor = RotateAnimation; }
__RotateAnimationPrototype.prototype = Animation.prototype;
RotateAnimation.prototype = new __RotateAnimationPrototype();
RotateAnimation.prototype.tick = function(progress) {
	Animation.prototype.tick.call(this, progress);
	this.object.angle = this.startValue + (this.delta * progress);
}
RotateAnimation.prototype.clone = function() {
	let clone = new _RotateAnimation();
	clone.type = this.type;
	clone.startTime = this.startTime;
	clone.duration = this.duration;
	clone.object = this.object;
	clone.startValue = this.startValue;
	clone.delta = this.delta;
	return clone;
}
function _RotateAnimation() {};
_RotateAnimation.prototype = RotateAnimation.prototype;
RotateAnimation.prototype.serialize_internal = function(buffer) {
	Animation.prototype.serialize_internal.call(this, buffer);
	buffer.writeFloat64(this.startValue);
	buffer.writeFloat64(this.delta);
}
RotateAnimation.prototype.deserialize_internal = function(buffer) {
	Animation.prototype.deserialize_internal.call(this, buffer);
	this.startValue = buffer.readFloat64();
	this.delta = buffer.readFloat64();
}
RotateAnimation.prototype.serialize_external = function(buffer) {
	Animation.prototype.serialize_external.call(this, buffer);
	buffer.writeString("startValue");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.startValue);
	buffer.writeString("delta");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.delta);
	buffer.writeString("");
}
RotateAnimation.prototype.deserialize_external = function(buffer) {
	let startValue_is_set = false, delta_is_set = false;
	Animation.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "startValue":
				buffer.readInt32();
				this.startValue = buffer.readFloat64();
				startValue_is_set = true;
				break;
			case "delta":
				buffer.readInt32();
				this.delta = buffer.readFloat64();
				delta_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!startValue_is_set) this.startValue = 0.0;
				if(!delta_is_set) this.delta = 0.0;
				return;
		}
	}
}
function FadeSoundAnimation(startTime, duration, object, startValue, delta, sound) {
	Animation.call(this, startTime, duration, object);
	this.type = "FadeSoundAnimation";
	this.startValue = startValue;
	this.delta = delta;
	this.sound = sound;
}
function __FadeSoundAnimationPrototype() { this.constructor = FadeSoundAnimation; }
__FadeSoundAnimationPrototype.prototype = Animation.prototype;
FadeSoundAnimation.prototype = new __FadeSoundAnimationPrototype();
FadeSoundAnimation.prototype.tick = function(progress) {
	Animation.prototype.tick.call(this, progress);
	if(this.sound == null) {
		return;
	}
	this.sound.volume(this.startValue + this.delta * progress);
	if(progress >= 1) {
		this.sound.stop();
	}
}
FadeSoundAnimation.prototype.clone = function() {
	let clone = new _FadeSoundAnimation();
	clone.type = this.type;
	clone.startTime = this.startTime;
	clone.duration = this.duration;
	clone.object = this.object;
	clone.startValue = this.startValue;
	clone.delta = this.delta;
	clone.sound = this.sound;
	return clone;
}
function _FadeSoundAnimation() {};
_FadeSoundAnimation.prototype = FadeSoundAnimation.prototype;
FadeSoundAnimation.prototype.serialize_internal = function(buffer) {
	Animation.prototype.serialize_internal.call(this, buffer);
	buffer.writeFloat64(this.startValue);
	buffer.writeFloat64(this.delta);
	let sound = this.sound
	if(sound) {
		var index = _objectCacheIndex.get(sound);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(sound, index = _objectCache.length);
			_objectCache.push(sound);
			buffer.writeInt32(-index);
			sound._objectIndex = index;
			sound.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
FadeSoundAnimation.prototype.deserialize_internal = function(buffer) {
	Animation.prototype.deserialize_internal.call(this, buffer);
	this.startValue = buffer.readFloat64();
	this.delta = buffer.readFloat64();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.sound = _objectCache[index];
	} else {
		let sound = this.sound
		if(!sound || sound._objectIndex != -index)
			this.sound = sound = new _Sound();
		(_objectCache[-index] = sound).deserialize_internal(buffer);
	}
}
FadeSoundAnimation.prototype.serialize_external = function(buffer) {
	Animation.prototype.serialize_external.call(this, buffer);
	buffer.writeString("startValue");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.startValue);
	buffer.writeString("delta");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.delta);
	buffer.writeString("sound");
	let sound_startPos = buffer.reserveSize();
	let sound = this.sound
	if(sound) {
		var index = _objectCacheIndex.get(sound);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(sound, index = _objectCache.length);
			_objectCache.push(sound);
			buffer.writeInt32(-index);
			sound._objectIndex = index;
			sound.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(sound_startPos);
	buffer.writeString("");
}
FadeSoundAnimation.prototype.deserialize_external = function(buffer) {
	let startValue_is_set = false, delta_is_set = false, sound_is_set = false;
	Animation.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "startValue":
				buffer.readInt32();
				this.startValue = buffer.readFloat64();
				startValue_is_set = true;
				break;
			case "delta":
				buffer.readInt32();
				this.delta = buffer.readFloat64();
				delta_is_set = true;
				break;
			case "sound":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.sound = _objectCache[index];
				} else {
					let sound = this.sound
					if(!sound || sound._objectIndex != -index)
						this.sound = sound = new _Sound();
					(_objectCache[-index] = sound).deserialize_external(buffer);
				}
				sound_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!startValue_is_set) this.startValue = 0.0;
				if(!delta_is_set) this.delta = 0.0;
				if(!sound_is_set) this.sound = null;
				return;
		}
	}
}
function PlaySoundAnimation(startTime, duration, object, sound) {
	Animation.call(this, startTime, duration, object);
	this.type = "PlaySoundAnimation";
	this.sound = sound;
}
function __PlaySoundAnimationPrototype() { this.constructor = PlaySoundAnimation; }
__PlaySoundAnimationPrototype.prototype = Animation.prototype;
PlaySoundAnimation.prototype = new __PlaySoundAnimationPrototype();
PlaySoundAnimation.prototype.tick = function(progress) {
	Animation.prototype.tick.call(this, progress);
	this.sound.play(false);
}
PlaySoundAnimation.prototype.clone = function() {
	let clone = new _PlaySoundAnimation();
	clone.type = this.type;
	clone.startTime = this.startTime;
	clone.duration = this.duration;
	clone.object = this.object;
	clone.sound = this.sound;
	return clone;
}
function _PlaySoundAnimation() {};
_PlaySoundAnimation.prototype = PlaySoundAnimation.prototype;
PlaySoundAnimation.prototype.serialize_internal = function(buffer) {
	Animation.prototype.serialize_internal.call(this, buffer);
	let sound = this.sound
	if(sound) {
		var index = _objectCacheIndex.get(sound);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(sound, index = _objectCache.length);
			_objectCache.push(sound);
			buffer.writeInt32(-index);
			sound._objectIndex = index;
			sound.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
PlaySoundAnimation.prototype.deserialize_internal = function(buffer) {
	Animation.prototype.deserialize_internal.call(this, buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.sound = _objectCache[index];
	} else {
		let sound = this.sound
		if(!sound || sound._objectIndex != -index)
			this.sound = sound = new _Sound();
		(_objectCache[-index] = sound).deserialize_internal(buffer);
	}
}
PlaySoundAnimation.prototype.serialize_external = function(buffer) {
	Animation.prototype.serialize_external.call(this, buffer);
	buffer.writeString("sound");
	let sound_startPos = buffer.reserveSize();
	let sound = this.sound
	if(sound) {
		var index = _objectCacheIndex.get(sound);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(sound, index = _objectCache.length);
			_objectCache.push(sound);
			buffer.writeInt32(-index);
			sound._objectIndex = index;
			sound.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(sound_startPos);
	buffer.writeString("");
}
PlaySoundAnimation.prototype.deserialize_external = function(buffer) {
	let sound_is_set = false;
	Animation.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "sound":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.sound = _objectCache[index];
				} else {
					let sound = this.sound
					if(!sound || sound._objectIndex != -index)
						this.sound = sound = new _Sound();
					(_objectCache[-index] = sound).deserialize_external(buffer);
				}
				sound_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!sound_is_set) this.sound = null;
				return;
		}
	}
}
function DelayAnimation(startTime, duration, object, $do) {
	Animation.call(this, startTime, duration, object);
	this.type = "DelayAnimation";
	this.do = $do;
}
function __DelayAnimationPrototype() { this.constructor = DelayAnimation; }
__DelayAnimationPrototype.prototype = Animation.prototype;
DelayAnimation.prototype = new __DelayAnimationPrototype();
DelayAnimation.prototype.tick = function(progress) {
	Animation.prototype.tick.call(this, progress);
	this.do?.invoke();
}
DelayAnimation.prototype.clone = function() {
	let clone = new _DelayAnimation();
	clone.type = this.type;
	clone.startTime = this.startTime;
	clone.duration = this.duration;
	clone.object = this.object;
	clone.do = this.do;
	return clone;
}
function _DelayAnimation() {};
_DelayAnimation.prototype = DelayAnimation.prototype;
DelayAnimation.prototype.serialize_internal = function(buffer) {
	Animation.prototype.serialize_internal.call(this, buffer);
	let $do = this.do
	if($do) {
		var index = _objectCacheIndex.get($do);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set($do, index = _objectCache.length);
			_objectCache.push($do);
			buffer.writeInt32(-index);
			buffer.writeInt32($do._id);
			$do._objectIndex = index;
			$do.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
DelayAnimation.prototype.deserialize_internal = function(buffer) {
	Animation.prototype.deserialize_internal.call(this, buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.do = _objectCache[index];
	} else {
		let $do = this.do
		let _id = buffer.readInt32();
		if(!$do || $do._id != _id || $do._objectIndex != -index)
			this.do = $do = new _lambdaContructors[_id]();
		$do._id = _id;
		(_objectCache[-index] = $do).deserialize_internal(buffer);
	}
}
DelayAnimation.prototype.serialize_external = function(buffer) {
	Animation.prototype.serialize_external.call(this, buffer);
	buffer.writeString("do");
	let $do_startPos = buffer.reserveSize();
	let $do = this.do
	if($do) {
		var index = _objectCacheIndex.get($do);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set($do, index = _objectCache.length);
			_objectCache.push($do);
			buffer.writeInt32(-index);
			buffer.writeInt32($do._id);
			$do._objectIndex = index;
			$do.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize($do_startPos);
	buffer.writeString("");
}
DelayAnimation.prototype.deserialize_external = function(buffer) {
	let do_is_set = false;
	Animation.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "do":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.do = _objectCache[index];
				} else {
					let $do = this.do
					let _id = buffer.readInt32();
					if(!$do || $do._id != _id || $do._objectIndex != -index)
						this.do = $do = new _lambdaContructors[_id]();
					$do._id = _id;
					(_objectCache[-index] = $do).deserialize_external(buffer);
				}
				do_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!do_is_set) this.do = null;
				return;
		}
	}
}
function InterpolateAnimation(startTime, duration, object, $do) {
	Animation.call(this, startTime, duration, object);
	this.type = "InterpolateAnimation";
	this.do = $do;
}
function __InterpolateAnimationPrototype() { this.constructor = InterpolateAnimation; }
__InterpolateAnimationPrototype.prototype = Animation.prototype;
InterpolateAnimation.prototype = new __InterpolateAnimationPrototype();
InterpolateAnimation.prototype.tick = function(progress) {
	Animation.prototype.tick.call(this, progress);
	this.do?.invoke(progress);
}
InterpolateAnimation.prototype.clone = function() {
	let clone = new _InterpolateAnimation();
	clone.type = this.type;
	clone.startTime = this.startTime;
	clone.duration = this.duration;
	clone.object = this.object;
	clone.do = this.do;
	return clone;
}
function _InterpolateAnimation() {};
_InterpolateAnimation.prototype = InterpolateAnimation.prototype;
InterpolateAnimation.prototype.serialize_internal = function(buffer) {
	Animation.prototype.serialize_internal.call(this, buffer);
	let $do = this.do
	if($do) {
		var index = _objectCacheIndex.get($do);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set($do, index = _objectCache.length);
			_objectCache.push($do);
			buffer.writeInt32(-index);
			buffer.writeInt32($do._id);
			$do._objectIndex = index;
			$do.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
InterpolateAnimation.prototype.deserialize_internal = function(buffer) {
	Animation.prototype.deserialize_internal.call(this, buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.do = _objectCache[index];
	} else {
		let $do = this.do
		let _id = buffer.readInt32();
		if(!$do || $do._id != _id || $do._objectIndex != -index)
			this.do = $do = new _lambdaContructors[_id]();
		$do._id = _id;
		(_objectCache[-index] = $do).deserialize_internal(buffer);
	}
}
InterpolateAnimation.prototype.serialize_external = function(buffer) {
	Animation.prototype.serialize_external.call(this, buffer);
	buffer.writeString("do");
	let $do_startPos = buffer.reserveSize();
	let $do = this.do
	if($do) {
		var index = _objectCacheIndex.get($do);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set($do, index = _objectCache.length);
			_objectCache.push($do);
			buffer.writeInt32(-index);
			buffer.writeInt32($do._id);
			$do._objectIndex = index;
			$do.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize($do_startPos);
	buffer.writeString("");
}
InterpolateAnimation.prototype.deserialize_external = function(buffer) {
	let do_is_set = false;
	Animation.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "do":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.do = _objectCache[index];
				} else {
					let $do = this.do
					let _id = buffer.readInt32();
					if(!$do || $do._id != _id || $do._objectIndex != -index)
						this.do = $do = new _lambdaContructors[_id]();
					$do._id = _id;
					(_objectCache[-index] = $do).deserialize_external(buffer);
				}
				do_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!do_is_set) this.do = null;
				return;
		}
	}
}
function DisplayImage(m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation, htmlImage, sx, sy, sw, sh, color) {
	DisplayItem.call(this, m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation);
	this.type = "DisplayImage";
	this.htmlImage = htmlImage;
	this.sx = sx;
	this.sy = sy;
	this.sw = sw;
	this.sh = sh;
	this.color = color;
}
function __DisplayImagePrototype() { this.constructor = DisplayImage; }
__DisplayImagePrototype.prototype = DisplayItem.prototype;
DisplayImage.prototype = new __DisplayImagePrototype();
DisplayImage.prototype.draw = function() {
	if(this.alpha == 0) return
	graphics.context.setTransform(this.m0, this.m1, this.m2, this.m3, this.m4, this.m5)
	graphics.context.globalAlpha = this.alpha
	if(this.clippingPath) this.startClipping()
		
	if(this.color.hex == "#ffffff" || this.color.hex == "#ffffffff" || this.color == null) {
		try{ graphics.context.drawImage(this.htmlImage, this.sx, this.sy, this.sw, this.sh, this.x, this.y, this.w, this.h) }
		catch(e) { log("DisplayImage: "+e.message) }
	} else {
		
		let offscreenCanvas = document.createElement("canvas");
		offscreenCanvas.width = this.sw;
		offscreenCanvas.height = this.sh;
		let offscreenContext = offscreenCanvas.getContext("2d");
		
		
		offscreenContext.drawImage(this.htmlImage, this.sx, this.sy, this.sw, this.sh, 0, 0, this.sw, this.sh)
		
		
		offscreenContext.fillStyle = this.color.hex;
		offscreenContext.globalCompositeOperation = "multiply";
		offscreenContext.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
		
		
		offscreenContext.globalAlpha = 1;
		offscreenContext.globalCompositeOperation = "destination-in";
		offscreenContext.drawImage(this.htmlImage, this.sx, this.sy, this.sw, this.sh, 0, 0, this.sw, this.sh)
			
		
		graphics.context.drawImage(offscreenCanvas, this.x, this.y, this.w, this.h); 
	}
	
	if(this.clippingPath) this.endClipping()
}
DisplayImage.prototype.clone = function() {
	let clone = new _DisplayImage();
	clone.type = this.type;
	clone.x = this.x;
	clone.y = this.y;
	clone.w = this.w;
	clone.h = this.h;
	clone.layer = this.layer;
	clone.alpha = this.alpha;
	clone.clippingPath = this.clippingPath;
	clone.name = this.name;
	clone.location = this.location;
	clone.positionLocation = this.positionLocation;
	clone.sizeLocation = this.sizeLocation;
	clone.m0 = this.m0;
	clone.m1 = this.m1;
	clone.m2 = this.m2;
	clone.m3 = this.m3;
	clone.m4 = this.m4;
	clone.m5 = this.m5;
	clone.poly = this.poly;
	clone.htmlImage = this.htmlImage;
	clone.sx = this.sx;
	clone.sy = this.sy;
	clone.sw = this.sw;
	clone.sh = this.sh;
	clone.color = this.color;
	return clone;
}
function _DisplayImage() {};
_DisplayImage.prototype = DisplayImage.prototype;
function DisplayText(m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation, fillStyle, outlineColor, outlineWidth, offsetY, font, lines, lineOffsets, lineHeight) {
	DisplayItem.call(this, m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation);
	this.type = "DisplayText";
	this.fillStyle = fillStyle;
	this.outlineColor = outlineColor;
	this.outlineWidth = outlineWidth;
	this.offsetY = offsetY;
	this.font = font;
	this.lines = lines;
	this.lineOffsets = lineOffsets;
	this.lineHeight = lineHeight;
}
function __DisplayTextPrototype() { this.constructor = DisplayText; }
__DisplayTextPrototype.prototype = DisplayItem.prototype;
DisplayText.prototype = new __DisplayTextPrototype();
DisplayText.prototype.draw = function() {
	if(this.alpha == 0) return
	graphics.context.setTransform(this.m0, this.m1, this.m2, this.m3, this.m4, this.m5)
	graphics.context.globalAlpha = this.alpha
	if(this.clippingPath) this.startClipping()
	graphics.context.font = this.font
	if(!this.lines) {
		
		if(this.outlineColor) {
			graphics.context.lineWidth = this.outlineWidth
			graphics.context.strokeStyle = this.outlineColor
			graphics.context.strokeText(this.name, this.x, this.y)
		}
		graphics.context.fillStyle = this.fillStyle
		graphics.context.fillText(this.name, this.x, this.y - this.offsetY)
	} else {
		
		let y = this.y
		for(let i=0; i<this.lines.length; i++) {
			let line = this.lines[i];
			let offset = this.lineOffsets[i];
			if(this.outlineColor) {
				graphics.context.lineWidth = this.outlineWidth
				graphics.context.strokeStyle = this.outlineColor
				graphics.context.strokeText(line, this.x + offset, y)
			}
			graphics.context.fillStyle = this.fillStyle
			graphics.context.fillText(line, this.x + offset, y)
			y += this.lineHeight
		}
	}
	
	if(this.clippingPath) this.endClipping()
}
DisplayText.prototype.clone = function() {
	let clone = new _DisplayText();
	clone.type = this.type;
	clone.x = this.x;
	clone.y = this.y;
	clone.w = this.w;
	clone.h = this.h;
	clone.layer = this.layer;
	clone.alpha = this.alpha;
	clone.clippingPath = this.clippingPath;
	clone.name = this.name;
	clone.location = this.location;
	clone.positionLocation = this.positionLocation;
	clone.sizeLocation = this.sizeLocation;
	clone.m0 = this.m0;
	clone.m1 = this.m1;
	clone.m2 = this.m2;
	clone.m3 = this.m3;
	clone.m4 = this.m4;
	clone.m5 = this.m5;
	clone.poly = this.poly;
	clone.fillStyle = this.fillStyle;
	clone.outlineColor = this.outlineColor;
	clone.outlineWidth = this.outlineWidth;
	clone.offsetY = this.offsetY;
	clone.font = this.font;
	clone.lines = this.lines;
	clone.lineOffsets = this.lineOffsets;
	clone.lineHeight = this.lineHeight;
	return clone;
}
function _DisplayText() {};
_DisplayText.prototype = DisplayText.prototype;
function DisplayTextWithHighlights(m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation, fillStyle, outlineColor, outlineWidth, offsetY, font, segments) {
	DisplayItem.call(this, m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation);
	this.type = "DisplayTextWithHighlights";
	this.fillStyle = fillStyle;
	this.outlineColor = outlineColor;
	this.outlineWidth = outlineWidth;
	this.offsetY = offsetY;
	this.font = font;
	this.segments = segments;
}
function __DisplayTextWithHighlightsPrototype() { this.constructor = DisplayTextWithHighlights; }
__DisplayTextWithHighlightsPrototype.prototype = DisplayItem.prototype;
DisplayTextWithHighlights.prototype = new __DisplayTextWithHighlightsPrototype();
DisplayTextWithHighlights.prototype.draw = function() {
	if(this.alpha == 0) return
	graphics.context.setTransform(this.m0, this.m1, this.m2, this.m3, this.m4, this.m5)
	graphics.context.globalAlpha = this.alpha
	if(this.clippingPath) this.startClipping()
	graphics.context.font = this.font
	let y = this.y
	for(let i=0; i<this.segments.length; i++) {
		let segment = this.segments[i];
		if(this.outlineColor) {
			graphics.context.lineWidth = this.outlineWidth
			graphics.context.strokeStyle = this.outlineColor
			graphics.context.strokeText(line, this.x + offset, y)
		}
		let highlight = segment.highlight
		if(highlight) {
			if(highlight.backgroundColor) {
				
				graphics.context.fillStyle = highlight.backgroundColor.hex
				
				let x = this.x + segment.position.x
				let y = this.y + segment.position.y - highlight.padding.y
				let width = segment.size.x
				let height = segment.size.y + highlight.padding.y*2
				let radius = highlight.cornerRadius
				
				if(radius) {
					
					graphics.context.beginPath();
					graphics.context.moveTo(x + radius, y);
					graphics.context.lineTo(x + width - radius, y);
					graphics.context.quadraticCurveTo(x + width, y, x + width, y + radius);
					graphics.context.lineTo(x + width, y + height - radius);
					graphics.context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
					graphics.context.lineTo(x + radius, y + height);
					graphics.context.quadraticCurveTo(x, y + height, x, y + height - radius);
					graphics.context.lineTo(x, y + radius);
					graphics.context.quadraticCurveTo(x, y, x + radius, y);
					graphics.context.closePath();
					graphics.context.fill();
				} else {
					graphics.context.fillRect(x, y, width, height)
				}
			}
		}
		if(highlight) {
			graphics.context.fillStyle = highlight.color ? highlight.color.hex : this.fillStyle
			graphics.context.fillText(segment.text, this.x + segment.position.x + highlight.padding.x, this.y + segment.position.y)
		} else {
			graphics.context.fillStyle = this.fillStyle
			graphics.context.fillText(segment.text, this.x + segment.position.x, this.y + segment.position.y)
		}
	}
	
	if(this.clippingPath) this.endClipping()
}
DisplayTextWithHighlights.prototype.clone = function() {
	let clone = new _DisplayTextWithHighlights();
	clone.type = this.type;
	clone.x = this.x;
	clone.y = this.y;
	clone.w = this.w;
	clone.h = this.h;
	clone.layer = this.layer;
	clone.alpha = this.alpha;
	clone.clippingPath = this.clippingPath;
	clone.name = this.name;
	clone.location = this.location;
	clone.positionLocation = this.positionLocation;
	clone.sizeLocation = this.sizeLocation;
	clone.m0 = this.m0;
	clone.m1 = this.m1;
	clone.m2 = this.m2;
	clone.m3 = this.m3;
	clone.m4 = this.m4;
	clone.m5 = this.m5;
	clone.poly = this.poly;
	clone.fillStyle = this.fillStyle;
	clone.outlineColor = this.outlineColor;
	clone.outlineWidth = this.outlineWidth;
	clone.offsetY = this.offsetY;
	clone.font = this.font;
	clone.segments = this.segments;
	return clone;
}
function _DisplayTextWithHighlights() {};
_DisplayTextWithHighlights.prototype = DisplayTextWithHighlights.prototype;
function DisplayRectangle(m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation, color, outlineColor, outlineWidth) {
	DisplayItem.call(this, m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation);
	this.type = "DisplayRectangle";
	this.color = color;
	this.outlineColor = outlineColor;
	this.outlineWidth = outlineWidth;
}
function __DisplayRectanglePrototype() { this.constructor = DisplayRectangle; }
__DisplayRectanglePrototype.prototype = DisplayItem.prototype;
DisplayRectangle.prototype = new __DisplayRectanglePrototype();
DisplayRectangle.prototype.draw = function() {
	if(this.alpha == 0) return
	graphics.context.setTransform(this.m0, this.m1, this.m2, this.m3, this.m4, this.m5)
	graphics.context.globalAlpha = this.alpha
	if(this.clippingPath) this.startClipping()
		
	if(this.color == "clear") {
		graphics.context.clearRect(this.x, this.y, this.w, this.h)
	}
	else
	if(this.color) {
		graphics.context.fillStyle = this.color
		graphics.context.fillRect(this.x, this.y, this.w, this.h)
	}
	if(this.outlineColor) {
		graphics.context.lineWidth = this.outlineWidth
		graphics.context.strokeStyle = this.outlineColor
		graphics.context.strokeRect(this.x, this.y, this.w, this.h)
	}
	if(this.clippingPath) this.endClipping()
}
DisplayRectangle.prototype.clone = function() {
	let clone = new _DisplayRectangle();
	clone.type = this.type;
	clone.x = this.x;
	clone.y = this.y;
	clone.w = this.w;
	clone.h = this.h;
	clone.layer = this.layer;
	clone.alpha = this.alpha;
	clone.clippingPath = this.clippingPath;
	clone.name = this.name;
	clone.location = this.location;
	clone.positionLocation = this.positionLocation;
	clone.sizeLocation = this.sizeLocation;
	clone.m0 = this.m0;
	clone.m1 = this.m1;
	clone.m2 = this.m2;
	clone.m3 = this.m3;
	clone.m4 = this.m4;
	clone.m5 = this.m5;
	clone.poly = this.poly;
	clone.color = this.color;
	clone.outlineColor = this.outlineColor;
	clone.outlineWidth = this.outlineWidth;
	return clone;
}
function _DisplayRectangle() {};
_DisplayRectangle.prototype = DisplayRectangle.prototype;
function DisplayRoundedRectangle(m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation, radius, color, outlineColor, outlineWidth) {
	DisplayItem.call(this, m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation);
	this.type = "DisplayRoundedRectangle";
	this.radius = radius;
	this.color = color;
	this.outlineColor = outlineColor;
	this.outlineWidth = outlineWidth;
}
function __DisplayRoundedRectanglePrototype() { this.constructor = DisplayRoundedRectangle; }
__DisplayRoundedRectanglePrototype.prototype = DisplayItem.prototype;
DisplayRoundedRectangle.prototype = new __DisplayRoundedRectanglePrototype();
DisplayRoundedRectangle.prototype.draw = function() {
	if(this.alpha == 0) return
	graphics.context.setTransform(this.m0, this.m1, this.m2, this.m3, this.m4, this.m5)
	graphics.context.globalAlpha = this.alpha
	if(this.clippingPath) this.startClipping()
	let sizeX = this.w, sizeY = this.h, x = this.x, y = this.y, radius = this.radius
	
	
	graphics.context.beginPath();
	graphics.context.moveTo(x + radius, y);
	graphics.context.lineTo(x + sizeX - radius, y);
	graphics.context.arcTo(x + sizeX, y, x + sizeX, y + radius, radius);
	graphics.context.lineTo(x + sizeX, y + sizeY - radius);
	graphics.context.arcTo(x + sizeX, y + sizeY, x + sizeX - radius, y + sizeY, radius);
	graphics.context.lineTo(x + radius, y + sizeY);
	graphics.context.arcTo(x, y + sizeY, x, y + sizeY - radius, radius);
	graphics.context.lineTo(x, y + radius);
	graphics.context.arcTo(x, y, x + radius, y, radius);
	graphics.context.closePath();
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	if(this.color) {
		graphics.context.fillStyle = this.color
		graphics.context.fill()
	}
	if(this.outlineColor) {
		graphics.context.lineWidth = this.outlineWidth
		graphics.context.strokeStyle = this.outlineColor
		graphics.context.stroke()
	}
	if(this.clippingPath) this.endClipping()
}
DisplayRoundedRectangle.prototype.clone = function() {
	let clone = new _DisplayRoundedRectangle();
	clone.type = this.type;
	clone.x = this.x;
	clone.y = this.y;
	clone.w = this.w;
	clone.h = this.h;
	clone.layer = this.layer;
	clone.alpha = this.alpha;
	clone.clippingPath = this.clippingPath;
	clone.name = this.name;
	clone.location = this.location;
	clone.positionLocation = this.positionLocation;
	clone.sizeLocation = this.sizeLocation;
	clone.m0 = this.m0;
	clone.m1 = this.m1;
	clone.m2 = this.m2;
	clone.m3 = this.m3;
	clone.m4 = this.m4;
	clone.m5 = this.m5;
	clone.poly = this.poly;
	clone.radius = this.radius;
	clone.color = this.color;
	clone.outlineColor = this.outlineColor;
	clone.outlineWidth = this.outlineWidth;
	return clone;
}
function _DisplayRoundedRectangle() {};
_DisplayRoundedRectangle.prototype = DisplayRoundedRectangle.prototype;
function DisplayPolygon(m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation, points, color, outlineColor, outlineWidth, smooth, close) {
	DisplayItem.call(this, m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation);
	this.type = "DisplayPolygon";
	this.points = points;
	this.color = color;
	this.outlineColor = outlineColor;
	this.outlineWidth = outlineWidth;
	this.smooth = smooth;
	this.close = close;
}
function __DisplayPolygonPrototype() { this.constructor = DisplayPolygon; }
__DisplayPolygonPrototype.prototype = DisplayItem.prototype;
DisplayPolygon.prototype = new __DisplayPolygonPrototype();
DisplayPolygon.prototype.draw = function() {
	if(this.points.length < 2 || this.alpha == 0) return
	graphics.context.setTransform(this.m0, this.m1, this.m2, this.m3, this.m4, this.m5)
	graphics.context.globalAlpha = this.alpha
	if(this.clippingPath) this.startClipping()
	let x = this.x, y = this.y
	let points = this.points, startPoint = points[0]
	
	graphics.context.beginPath();
	graphics.context.moveTo(x + startPoint.x, y + startPoint.y)
	
	if(!this.smooth || points.length < 3) {
		for(let i=1, len = points.length; i<len; ++i) {
			let p = points[i]
			graphics.context.lineTo(x + p.x, y + p.y)
		}
	} else {
		for(var i = 1, len = points.length - 2; i<len; i++)
		{
			let p1 = points[i], p2 = points[i + 1]
			graphics.context.quadraticCurveTo(p1.x, p1.y, (p1.x + p2.x) / 2, (p1.y + p2.y) / 2);
		}
		let p1 = points[i], p2 = points[i + 1]
		graphics.context.quadraticCurveTo(p1.x, p1.y, p2.x,p2.y);
	}
	if(this.close || this.color) {
		graphics.context.closePath()
	}
	if(this.color) {
		
		graphics.context.fillStyle = this.color
		graphics.context.fill()
	}
	if(this.outlineColor) {
		
		graphics.context.lineWidth = this.outlineWidth
		graphics.context.strokeStyle = this.outlineColor
		graphics.context.stroke()
	}
	if(this.clippingPath) this.endClipping()
}
DisplayPolygon.prototype.clone = function() {
	let clone = new _DisplayPolygon();
	clone.type = this.type;
	clone.x = this.x;
	clone.y = this.y;
	clone.w = this.w;
	clone.h = this.h;
	clone.layer = this.layer;
	clone.alpha = this.alpha;
	clone.clippingPath = this.clippingPath;
	clone.name = this.name;
	clone.location = this.location;
	clone.positionLocation = this.positionLocation;
	clone.sizeLocation = this.sizeLocation;
	clone.m0 = this.m0;
	clone.m1 = this.m1;
	clone.m2 = this.m2;
	clone.m3 = this.m3;
	clone.m4 = this.m4;
	clone.m5 = this.m5;
	clone.poly = this.poly;
	clone.points = this.points;
	clone.color = this.color;
	clone.outlineColor = this.outlineColor;
	clone.outlineWidth = this.outlineWidth;
	clone.smooth = this.smooth;
	clone.close = this.close;
	return clone;
}
function _DisplayPolygon() {};
_DisplayPolygon.prototype = DisplayPolygon.prototype;
function DisplayCircle(m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation, startAngle, angle, direction, color, outlineColor, outlineWidth) {
	DisplayItem.call(this, m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation);
	this.type = "DisplayCircle";
	this.startAngle = startAngle;
	this.angle = angle;
	this.direction = direction;
	this.color = color;
	this.outlineColor = outlineColor;
	this.outlineWidth = outlineWidth;
}
function __DisplayCirclePrototype() { this.constructor = DisplayCircle; }
__DisplayCirclePrototype.prototype = DisplayItem.prototype;
DisplayCircle.prototype = new __DisplayCirclePrototype();
DisplayCircle.prototype.draw = function() {
	if(this.alpha == 0) return
	graphics.context.setTransform(this.m0, this.m1, this.m2, this.m3, this.m4, this.m5)
	graphics.context.globalAlpha = this.alpha
	if(this.clippingPath) this.startClipping()
		
	graphics.context.beginPath();
	if(this.w == this.h) {
		let radius = this.w/2
		if(this.angle == 1) {
			graphics.context.arc(this.x+radius, this.y+radius, radius, 0, math.TwoPI, this.direction);
		} else {
			let startAngle = this.startAngle - .25
			graphics.context.arc(this.x+radius, this.y+radius, radius, startAngle*math.TwoPI, (startAngle+this.angle)*math.TwoPI, this.direction);
		}
	} else {
		let radiusX = this.w/2
		let radiusY = this.h/2
		graphics.context.ellipse(this.x+radiusX, this.y+radiusY, radiusX, radiusY, 0, math.TwoPI, this.direction);
	}
	if(this.color) {
		graphics.context.fillStyle = this.color
		graphics.context.fill()
	}
	if(this.outlineColor) {
		graphics.context.lineWidth = this.outlineWidth
		graphics.context.strokeStyle = this.outlineColor
		graphics.context.stroke()
	}
	if(this.clippingPath) this.endClipping()
}
DisplayCircle.prototype.clone = function() {
	let clone = new _DisplayCircle();
	clone.type = this.type;
	clone.x = this.x;
	clone.y = this.y;
	clone.w = this.w;
	clone.h = this.h;
	clone.layer = this.layer;
	clone.alpha = this.alpha;
	clone.clippingPath = this.clippingPath;
	clone.name = this.name;
	clone.location = this.location;
	clone.positionLocation = this.positionLocation;
	clone.sizeLocation = this.sizeLocation;
	clone.m0 = this.m0;
	clone.m1 = this.m1;
	clone.m2 = this.m2;
	clone.m3 = this.m3;
	clone.m4 = this.m4;
	clone.m5 = this.m5;
	clone.poly = this.poly;
	clone.startAngle = this.startAngle;
	clone.angle = this.angle;
	clone.direction = this.direction;
	clone.color = this.color;
	clone.outlineColor = this.outlineColor;
	clone.outlineWidth = this.outlineWidth;
	return clone;
}
function _DisplayCircle() {};
_DisplayCircle.prototype = DisplayCircle.prototype;
function DisplayLine(m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation, end, outlineColor, outlineWidth) {
	DisplayItem.call(this, m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation);
	this.type = "DisplayLine";
	this.end = end?.clone();
	this.outlineColor = outlineColor;
	this.outlineWidth = outlineWidth;
}
function __DisplayLinePrototype() { this.constructor = DisplayLine; }
__DisplayLinePrototype.prototype = DisplayItem.prototype;
DisplayLine.prototype = new __DisplayLinePrototype();
DisplayLine.prototype.draw = function() {
	if(this.alpha == 0) return
	graphics.context.setTransform(this.m0, this.m1, this.m2, this.m3, this.m4, this.m5)
	graphics.context.globalAlpha = this.alpha
	if(this.clippingPath) this.startClipping()
	
	graphics.context.beginPath();
	graphics.context.moveTo(this.x,this.y)
	graphics.context.lineTo(this.end.x, this.end.y)
	graphics.context.lineWidth = this.outlineWidth
	graphics.context.strokeStyle = this.outlineColor
	graphics.context.stroke()
	
	if(this.clippingPath) this.endClipping()
}
DisplayLine.prototype.clone = function() {
	let clone = new _DisplayLine();
	clone.type = this.type;
	clone.x = this.x;
	clone.y = this.y;
	clone.w = this.w;
	clone.h = this.h;
	clone.layer = this.layer;
	clone.alpha = this.alpha;
	clone.clippingPath = this.clippingPath;
	clone.name = this.name;
	clone.location = this.location;
	clone.positionLocation = this.positionLocation;
	clone.sizeLocation = this.sizeLocation;
	clone.m0 = this.m0;
	clone.m1 = this.m1;
	clone.m2 = this.m2;
	clone.m3 = this.m3;
	clone.m4 = this.m4;
	clone.m5 = this.m5;
	clone.poly = this.poly;
	clone.end = this.end.clone();
	clone.outlineColor = this.outlineColor;
	clone.outlineWidth = this.outlineWidth;
	return clone;
}
function _DisplayLine() {};
_DisplayLine.prototype = DisplayLine.prototype;
function DisplayVideo(m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation, userId, shape) {
	DisplayItem.call(this, m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation);
	this.type = "DisplayVideo";
	this.userId = userId;
	this.shape = shape;
}
function __DisplayVideoPrototype() { this.constructor = DisplayVideo; }
__DisplayVideoPrototype.prototype = DisplayItem.prototype;
DisplayVideo.prototype = new __DisplayVideoPrototype();
DisplayVideo.prototype.draw = function() {
	DisplayItem.prototype.draw.call(this);
	let user = input.internalUsers[this.userId];
	if((user != null)) {
		let videoElement = user.videoElements[user.videoElementIndex] || (user.videoElements[user.videoElementIndex] = PeerNetwork.createVideoElement(user.mediaStream, user.local));
		let px = (this.m0 * this.x + this.m2 * this.y + this.m4) / graphics.pixelRatio;
		let py = (this.m1 * this.x + this.m3 * this.y + this.m5) / graphics.pixelRatio;
		let sizeX = this.w * this.m0 / graphics.pixelRatio;
		let sizeY = this.h * this.m3 / graphics.pixelRatio;
		PeerNetwork.updateVideoElement(videoElement, px, py, sizeX, sizeY, (this.shape == 2/*Circle*/ ? 10000 : 0));
		user.videoElementIndex++;
	}
}
DisplayVideo.prototype.clone = function() {
	let clone = new _DisplayVideo();
	clone.type = this.type;
	clone.x = this.x;
	clone.y = this.y;
	clone.w = this.w;
	clone.h = this.h;
	clone.layer = this.layer;
	clone.alpha = this.alpha;
	clone.clippingPath = this.clippingPath;
	clone.name = this.name;
	clone.location = this.location;
	clone.positionLocation = this.positionLocation;
	clone.sizeLocation = this.sizeLocation;
	clone.m0 = this.m0;
	clone.m1 = this.m1;
	clone.m2 = this.m2;
	clone.m3 = this.m3;
	clone.m4 = this.m4;
	clone.m5 = this.m5;
	clone.poly = this.poly;
	clone.userId = this.userId;
	clone.shape = this.shape;
	return clone;
}
function _DisplayVideo() {};
_DisplayVideo.prototype = DisplayVideo.prototype;
function LobbyTextField(position, size, angle, alpha, visibleFor, layer, locked, location, text, font, color, player, effect, particleSystem, editableBy, width, onChanged) {
	$Object.call(this, position, size, angle, alpha, visibleFor, layer, locked, location);
	this.type = "LobbyTextField";
	this.text = text;
	this.font = font;
	this.color = color;
	this.player = player;
	this.effect = effect;
	this.particleSystem = particleSystem;
	this.editableBy = editableBy;
	this.width = width;
	this.onChanged = onChanged;
	this.isFocused = false;
	this.lastTypeTime = 0.0;
}
function __LobbyTextFieldPrototype() { this.constructor = LobbyTextField; }
__LobbyTextFieldPrototype.prototype = $Object.prototype;
LobbyTextField.prototype = new __LobbyTextFieldPrototype();
LobbyTextField.prototype.clear = function() {
	this.text = "";
	this.isFocused = false;
}
LobbyTextField.prototype.focus = function(isFocused) {
	this.isFocused = isFocused;
	this.lastTypeTime = Time.now;
}
LobbyTextField.prototype.tick = function() {
	var _value, _value2;
	$Object.prototype.tick.call(this);
	let c = this.isFocused && (((_value = 1000, (Time.now % _value) + _value) % _value) < 500);
	input.onTouchDownAny([this.editableBy], touch => {
		this.focus(false);
	});
	input.onTouchDown(this.position.plus(new Vector2(0, this.size.x / 2, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 8154, 8166, null, null))), new Vector2(this.width, this.size.x * 2, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 8168, 8184, null, null)), [this.editableBy], "auto", false, true, 1/*Center*/, 1/*Middle*/, touch => {
		this.focus(true);
	});
	if(this.isFocused) {
		input.onType([this.editableBy], (character,pressedBy) => {
			this.text += character;
			this.lastTypeTime = Time.now;
			if(this.onChanged != null) {
				this.onChanged?.invoke(this.text);
			}
		});
		input.onKeyDown2(8/*Backspace*/, false, false, false, [this.editableBy], (key,pressedBy,cmdOrCtrl,alt,shift) => {
			if(this.text) {
				this.text = this.text.substring(0, this.text.length - 1);
			}
			this.lastTypeTime = Time.now;
			if(this.onChanged != null) {
				this.onChanged?.invoke(this.text);
			}
		});
	}
	graphics.drawText(this.text, this.position.plus(new Vector2(0, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 8524, 8530, null, null))), this.size, null, 1/*Center*/, 1/*Middle*/, 0/*Normal*/, Font.ByTheWay, null, 0, 0, this.alpha, this.angle, this.visibleFor, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 8500, 8591, null, null));
	if(this.isFocused && (((_value2 = 1500, ((Time.now - this.lastTypeTime) % _value2) + _value2) % _value2) < 750)) {
		let textWidth = graphics.getTextWidth(this.text, this.size, Font.ByTheWay, 0/*Normal*/);
		graphics.drawText("|", this.position.plus(new Vector2(textWidth / 2, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 8748, 8764, null, null))), this.size, null, 1/*Center*/, 1/*Middle*/, 0/*Normal*/, Font.ByTheWay, null, 0, 0, this.alpha, this.angle, [this.editableBy], null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/lobby.l", 8725, 8836, null, null));
	}
}

LobbyTextField.prototype.clone = function() {
	let clone = new _LobbyTextField();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.angle = this.angle;
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.text = this.text;
	clone.font = this.font;
	clone.color = this.color;
	clone.player = this.player;
	clone.effect = this.effect;
	clone.particleSystem = this.particleSystem;
	clone.editableBy = this.editableBy;
	clone.width = this.width;
	clone.onChanged = this.onChanged;
	clone.isFocused = this.isFocused;
	clone.lastTypeTime = this.lastTypeTime;
	return clone;
}
function _LobbyTextField() {};
_LobbyTextField.prototype = LobbyTextField.prototype;
LobbyTextField.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	buffer.writeString(this.text);
	let font = this.font
	if(font) {
		var index = _objectCacheIndex.get(font);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(font, index = _objectCache.length);
			_objectCache.push(font);
			buffer.writeInt32(-index);
			font._objectIndex = index;
			font.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let player = this.player
	if(player) {
		var index = _objectCacheIndex.get(player);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(player, index = _objectCache.length);
			_objectCache.push(player);
			buffer.writeInt32(-index);
			player._objectIndex = index;
			player.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let effect = this.effect
	if(effect) {
		var index = _objectCacheIndex.get(effect);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(effect, index = _objectCache.length);
			_objectCache.push(effect);
			buffer.writeInt32(-index);
			buffer.writeString(effect.type);
			effect._objectIndex = index;
			effect.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let particleSystem = this.particleSystem
	if(particleSystem) {
		var index = _objectCacheIndex.get(particleSystem);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(particleSystem, index = _objectCache.length);
			_objectCache.push(particleSystem);
			buffer.writeInt32(-index);
			buffer.writeString(particleSystem.type);
			particleSystem._objectIndex = index;
			particleSystem.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let editableBy = this.editableBy
	if(editableBy) {
		var index = _objectCacheIndex.get(editableBy);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(editableBy, index = _objectCache.length);
			_objectCache.push(editableBy);
			buffer.writeInt32(-index);
			editableBy._objectIndex = index;
			editableBy.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeFloat64(this.width);
	let onChanged = this.onChanged
	if(onChanged) {
		var index = _objectCacheIndex.get(onChanged);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(onChanged, index = _objectCache.length);
			_objectCache.push(onChanged);
			buffer.writeInt32(-index);
			buffer.writeInt32(onChanged._id);
			onChanged._objectIndex = index;
			onChanged.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeBool(this.isFocused);
	buffer.writeFloat64(this.lastTypeTime);
}
LobbyTextField.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	this.text = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.font = _objectCache[index];
	} else {
		let font = this.font
		if(!font || font._objectIndex != -index)
			this.font = font = new _Font();
		(_objectCache[-index] = font).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.color = _objectCache[index];
	} else {
		let color = this.color
		if(!color || color._objectIndex != -index)
			this.color = color = new _Color();
		(_objectCache[-index] = color).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.player = _objectCache[index];
	} else {
		let player = this.player
		if(!player || player._objectIndex != -index)
			this.player = player = new _Player();
		(_objectCache[-index] = player).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.effect = _objectCache[index];
	} else {
		let effect = this.effect
		let type = buffer.readString();
		if(!effect || effect._objectIndex != -index)
			this.effect = effect = new_Object_of_type(type);
		effect.type = type;
		(_objectCache[-index] = effect).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.particleSystem = _objectCache[index];
	} else {
		let particleSystem = this.particleSystem
		let type = buffer.readString();
		if(!particleSystem || particleSystem._objectIndex != -index)
			this.particleSystem = particleSystem = new_Object_of_type(type);
		particleSystem.type = type;
		(_objectCache[-index] = particleSystem).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.editableBy = _objectCache[index];
	} else {
		let editableBy = this.editableBy
		if(!editableBy || editableBy._objectIndex != -index)
			this.editableBy = editableBy = new _Player();
		(_objectCache[-index] = editableBy).deserialize_internal(buffer);
	}
	this.width = buffer.readFloat64();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.onChanged = _objectCache[index];
	} else {
		let onChanged = this.onChanged
		let _id = buffer.readInt32();
		if(!onChanged || onChanged._id != _id || onChanged._objectIndex != -index)
			this.onChanged = onChanged = new _lambdaContructors[_id]();
		onChanged._id = _id;
		(_objectCache[-index] = onChanged).deserialize_internal(buffer);
	}
	this.isFocused = buffer.readBool();
	this.lastTypeTime = buffer.readFloat64();
}
LobbyTextField.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("text");
	buffer.writeString(this.text);
	buffer.writeString("font");
	let font_startPos = buffer.reserveSize();
	let font = this.font
	if(font) {
		var index = _objectCacheIndex.get(font);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(font, index = _objectCache.length);
			_objectCache.push(font);
			buffer.writeInt32(-index);
			font._objectIndex = index;
			font.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(font_startPos);
	buffer.writeString("color");
	let color_startPos = buffer.reserveSize();
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(color_startPos);
	buffer.writeString("player");
	let player_startPos = buffer.reserveSize();
	let player = this.player
	if(player) {
		var index = _objectCacheIndex.get(player);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(player, index = _objectCache.length);
			_objectCache.push(player);
			buffer.writeInt32(-index);
			player._objectIndex = index;
			player.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(player_startPos);
	buffer.writeString("effect");
	let effect_startPos = buffer.reserveSize();
	let effect = this.effect
	if(effect) {
		var index = _objectCacheIndex.get(effect);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(effect, index = _objectCache.length);
			_objectCache.push(effect);
			buffer.writeInt32(-index);
			buffer.writeString(effect.type);
			effect._objectIndex = index;
			effect.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(effect_startPos);
	buffer.writeString("particleSystem");
	let particleSystem_startPos = buffer.reserveSize();
	let particleSystem = this.particleSystem
	if(particleSystem) {
		var index = _objectCacheIndex.get(particleSystem);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(particleSystem, index = _objectCache.length);
			_objectCache.push(particleSystem);
			buffer.writeInt32(-index);
			buffer.writeString(particleSystem.type);
			particleSystem._objectIndex = index;
			particleSystem.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(particleSystem_startPos);
	buffer.writeString("editableBy");
	let editableBy_startPos = buffer.reserveSize();
	let editableBy = this.editableBy
	if(editableBy) {
		var index = _objectCacheIndex.get(editableBy);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(editableBy, index = _objectCache.length);
			_objectCache.push(editableBy);
			buffer.writeInt32(-index);
			editableBy._objectIndex = index;
			editableBy.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(editableBy_startPos);
	buffer.writeString("width");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.width);
	buffer.writeString("onChanged");
	let onChanged_startPos = buffer.reserveSize();
	let onChanged = this.onChanged
	if(onChanged) {
		var index = _objectCacheIndex.get(onChanged);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(onChanged, index = _objectCache.length);
			_objectCache.push(onChanged);
			buffer.writeInt32(-index);
			buffer.writeInt32(onChanged._id);
			onChanged._objectIndex = index;
			onChanged.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(onChanged_startPos);
	buffer.writeString("isFocused");
	buffer.writeInt32(1);
	buffer.writeBool(this.isFocused);
	buffer.writeString("lastTypeTime");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.lastTypeTime);
	buffer.writeString("");
}
LobbyTextField.prototype.deserialize_external = function(buffer) {
	let text_is_set = false, font_is_set = false, color_is_set = false, player_is_set = false, effect_is_set = false, particleSystem_is_set = false, editableBy_is_set = false, width_is_set = false, onChanged_is_set = false, isFocused_is_set = false, lastTypeTime_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "text":
				this.text = buffer.readString();
				text_is_set = true;
				break;
			case "font":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.font = _objectCache[index];
				} else {
					let font = this.font
					if(!font || font._objectIndex != -index)
						this.font = font = new _Font();
					(_objectCache[-index] = font).deserialize_external(buffer);
				}
				font_is_set = true;
				break;
			case "color":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.color = _objectCache[index];
				} else {
					let color = this.color
					if(!color || color._objectIndex != -index)
						this.color = color = new _Color();
					(_objectCache[-index] = color).deserialize_external(buffer);
				}
				color_is_set = true;
				break;
			case "player":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.player = _objectCache[index];
				} else {
					let player = this.player
					if(!player || player._objectIndex != -index)
						this.player = player = new _Player();
					(_objectCache[-index] = player).deserialize_external(buffer);
				}
				player_is_set = true;
				break;
			case "effect":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.effect = _objectCache[index];
				} else {
					let effect = this.effect
					let type = buffer.readString();
					if(!effect || effect._objectIndex != -index)
						this.effect = effect = new_Object_of_type(type);
					effect.type = type;
					(_objectCache[-index] = effect).deserialize_external(buffer);
				}
				effect_is_set = true;
				break;
			case "particleSystem":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.particleSystem = _objectCache[index];
				} else {
					let particleSystem = this.particleSystem
					let type = buffer.readString();
					if(!particleSystem || particleSystem._objectIndex != -index)
						this.particleSystem = particleSystem = new_Object_of_type(type);
					particleSystem.type = type;
					(_objectCache[-index] = particleSystem).deserialize_external(buffer);
				}
				particleSystem_is_set = true;
				break;
			case "editableBy":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.editableBy = _objectCache[index];
				} else {
					let editableBy = this.editableBy
					if(!editableBy || editableBy._objectIndex != -index)
						this.editableBy = editableBy = new _Player();
					(_objectCache[-index] = editableBy).deserialize_external(buffer);
				}
				editableBy_is_set = true;
				break;
			case "width":
				buffer.readInt32();
				this.width = buffer.readFloat64();
				width_is_set = true;
				break;
			case "onChanged":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.onChanged = _objectCache[index];
				} else {
					let onChanged = this.onChanged
					let _id = buffer.readInt32();
					if(!onChanged || onChanged._id != _id || onChanged._objectIndex != -index)
						this.onChanged = onChanged = new _lambdaContructors[_id]();
					onChanged._id = _id;
					(_objectCache[-index] = onChanged).deserialize_external(buffer);
				}
				onChanged_is_set = true;
				break;
			case "isFocused":
				buffer.readInt32();
				this.isFocused = buffer.readBool();
				isFocused_is_set = true;
				break;
			case "lastTypeTime":
				buffer.readInt32();
				this.lastTypeTime = buffer.readFloat64();
				lastTypeTime_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!text_is_set) this.text = "";
				if(!font_is_set) this.font = null;
				if(!color_is_set) this.color = Color.White;
				if(!player_is_set) this.player = null;
				if(!effect_is_set) this.effect = null;
				if(!particleSystem_is_set) this.particleSystem = null;
				if(!editableBy_is_set) this.editableBy = null;
				if(!width_is_set) this.width = 600;
				if(!onChanged_is_set) this.onChanged = null;
				if(!isFocused_is_set) this.isFocused = false;
				if(!lastTypeTime_is_set) this.lastTypeTime = 0.0;
				return;
		}
	}
}
function RectangleObject(position, size, angle, alpha, visibleFor, layer, locked, location, color) {
	$Object.call(this, position, size, angle, alpha, visibleFor, layer, locked, location);
	this.type = "RectangleObject";
	this.color = color;
}
function __RectangleObjectPrototype() { this.constructor = RectangleObject; }
__RectangleObjectPrototype.prototype = $Object.prototype;
RectangleObject.prototype = new __RectangleObjectPrototype();
RectangleObject.prototype.tick = function() {
	if(this.alpha) {
		graphics.drawRectangle(this.position, this.size, this.color, null, 0, this.visibleFor, this.layer, this.alpha, 1/*Center*/, 1/*Middle*/, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 6728, 6789, null, null));
	}
}
RectangleObject.prototype.clone = function() {
	let clone = new _RectangleObject();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.angle = this.angle;
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.color = this.color;
	return clone;
}
function _RectangleObject() {};
_RectangleObject.prototype = RectangleObject.prototype;
RectangleObject.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
RectangleObject.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.color = _objectCache[index];
	} else {
		let color = this.color
		if(!color || color._objectIndex != -index)
			this.color = color = new _Color();
		(_objectCache[-index] = color).deserialize_internal(buffer);
	}
}
RectangleObject.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("color");
	let color_startPos = buffer.reserveSize();
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(color_startPos);
	buffer.writeString("");
}
RectangleObject.prototype.deserialize_external = function(buffer) {
	let color_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "color":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.color = _objectCache[index];
				} else {
					let color = this.color
					if(!color || color._objectIndex != -index)
						this.color = color = new _Color();
					(_objectCache[-index] = color).deserialize_external(buffer);
				}
				color_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!color_is_set) this.color = Color.White;
				return;
		}
	}
}
function CircleObject(position, size, angle, alpha, visibleFor, layer, locked, location, color) {
	$Object.call(this, position, size, angle, alpha, visibleFor, layer, locked, location);
	this.type = "CircleObject";
	this.color = color;
}
function __CircleObjectPrototype() { this.constructor = CircleObject; }
__CircleObjectPrototype.prototype = $Object.prototype;
CircleObject.prototype = new __CircleObjectPrototype();
CircleObject.prototype.tick = function() {
	if(this.alpha) {
		graphics.drawCircle(this.position, this.size, this.color, null, 0, 0, 1.0, 0/*Clockwise*/, this.visibleFor, this.layer, 1.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 6868, 6925, null, null));
	}
}
CircleObject.prototype.clone = function() {
	let clone = new _CircleObject();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.angle = this.angle;
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.color = this.color;
	return clone;
}
function _CircleObject() {};
_CircleObject.prototype = CircleObject.prototype;
CircleObject.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
CircleObject.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.color = _objectCache[index];
	} else {
		let color = this.color
		if(!color || color._objectIndex != -index)
			this.color = color = new _Color();
		(_objectCache[-index] = color).deserialize_internal(buffer);
	}
}
CircleObject.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("color");
	let color_startPos = buffer.reserveSize();
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(color_startPos);
	buffer.writeString("");
}
CircleObject.prototype.deserialize_external = function(buffer) {
	let color_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "color":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.color = _objectCache[index];
				} else {
					let color = this.color
					if(!color || color._objectIndex != -index)
						this.color = color = new _Color();
					(_objectCache[-index] = color).deserialize_external(buffer);
				}
				color_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!color_is_set) this.color = Color.White;
				return;
		}
	}
}
function VisualizeObject(position, size, angle, alpha, visibleFor, layer, locked, location, color, index, text) {
	$Object.call(this, position, size, angle, alpha, visibleFor, layer, locked, location);
	this.type = "VisualizeObject";
	this.color = color;
	this.index = index;
	this.text = text;
}
function __VisualizeObjectPrototype() { this.constructor = VisualizeObject; }
__VisualizeObjectPrototype.prototype = $Object.prototype;
VisualizeObject.prototype = new __VisualizeObjectPrototype();
VisualizeObject.prototype.tick = function() {
	graphics.drawText(this.index?.toString(), this.position, new Vector2(30, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 7532, 7534, null, null)), Color.Black, 1/*Center*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, int.maxValue, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 7468, 7534, null, null));
	graphics.drawText(this.text, this.position.plus(new Vector2(0, 32, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 7561, 7567, null, null))), new Vector2(14, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 7601, 7603, null, null)), this.color, 1/*Center*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, int.maxValue, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 7537, 7603, null, null));
	graphics.drawCircle(this.position, this.size, this.color, null, 0, 0, 1.0, 0/*Clockwise*/, null, int.maxValue, 1.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 7606, 7658, null, null));
}
VisualizeObject.prototype.clone = function() {
	let clone = new _VisualizeObject();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.angle = this.angle;
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.color = this.color;
	clone.index = this.index;
	clone.text = this.text;
	return clone;
}
function _VisualizeObject() {};
_VisualizeObject.prototype = VisualizeObject.prototype;
VisualizeObject.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.index);
	buffer.writeString(this.text);
}
VisualizeObject.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.color = _objectCache[index];
	} else {
		let color = this.color
		if(!color || color._objectIndex != -index)
			this.color = color = new _Color();
		(_objectCache[-index] = color).deserialize_internal(buffer);
	}
	this.index = buffer.readInt32();
	this.text = buffer.readString();
}
VisualizeObject.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("color");
	let color_startPos = buffer.reserveSize();
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(color_startPos);
	buffer.writeString("index");
	buffer.writeInt32(4);
	buffer.writeInt32(this.index);
	buffer.writeString("text");
	buffer.writeString(this.text);
	buffer.writeString("");
}
VisualizeObject.prototype.deserialize_external = function(buffer) {
	let color_is_set = false, index_is_set = false, text_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "color":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.color = _objectCache[index];
				} else {
					let color = this.color
					if(!color || color._objectIndex != -index)
						this.color = color = new _Color();
					(_objectCache[-index] = color).deserialize_external(buffer);
				}
				color_is_set = true;
				break;
			case "index":
				buffer.readInt32();
				this.index = buffer.readInt32();
				index_is_set = true;
				break;
			case "text":
				this.text = buffer.readString();
				text_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!color_is_set) this.color = Color.White;
				if(!index_is_set) this.index = 0;
				if(!text_is_set) this.text = "";
				return;
		}
	}
}
function TextObject(position, size, angle, alpha, visibleFor, layer, locked, location, text, font, color, align, valign, maxWidth) {
	$Object.call(this, position, size, angle, alpha, visibleFor, layer, locked, location);
	this.type = "TextObject";
	this.text = text;
	this.font = font;
	this.color = color;
	this.align = align;
	this.valign = valign;
	this.maxWidth = maxWidth;
}
function __TextObjectPrototype() { this.constructor = TextObject; }
__TextObjectPrototype.prototype = $Object.prototype;
TextObject.prototype = new __TextObjectPrototype();
TextObject.prototype.tick = function() {
	if(this.alpha) {
		graphics.drawText(this.text, this.position, this.size, this.color, this.align, this.valign, 0/*Normal*/, this.font, null, 0, this.layer, this.alpha, this.angle, this.visibleFor, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, this.maxWidth, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 7927, 8027, null, null));
	}
}
TextObject.prototype.clone = function() {
	let clone = new _TextObject();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.angle = this.angle;
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.text = this.text;
	clone.font = this.font;
	clone.color = this.color;
	clone.align = this.align;
	clone.valign = this.valign;
	clone.maxWidth = this.maxWidth;
	return clone;
}
function _TextObject() {};
_TextObject.prototype = TextObject.prototype;
TextObject.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	buffer.writeString(this.text);
	let font = this.font
	if(font) {
		var index = _objectCacheIndex.get(font);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(font, index = _objectCache.length);
			_objectCache.push(font);
			buffer.writeInt32(-index);
			font._objectIndex = index;
			font.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.align);
	buffer.writeInt32(this.valign);
	buffer.writeFloat64(this.maxWidth);
}
TextObject.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	this.text = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.font = _objectCache[index];
	} else {
		let font = this.font
		if(!font || font._objectIndex != -index)
			this.font = font = new _Font();
		(_objectCache[-index] = font).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.color = _objectCache[index];
	} else {
		let color = this.color
		if(!color || color._objectIndex != -index)
			this.color = color = new _Color();
		(_objectCache[-index] = color).deserialize_internal(buffer);
	}
	this.align = buffer.readInt32();
	this.valign = buffer.readInt32();
	this.maxWidth = buffer.readFloat64();
}
TextObject.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("text");
	buffer.writeString(this.text);
	buffer.writeString("font");
	let font_startPos = buffer.reserveSize();
	let font = this.font
	if(font) {
		var index = _objectCacheIndex.get(font);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(font, index = _objectCache.length);
			_objectCache.push(font);
			buffer.writeInt32(-index);
			font._objectIndex = index;
			font.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(font_startPos);
	buffer.writeString("color");
	let color_startPos = buffer.reserveSize();
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(color_startPos);
	buffer.writeString("align");
	buffer.writeInt32(4);
	buffer.writeInt32(this.align);
	buffer.writeString("valign");
	buffer.writeInt32(4);
	buffer.writeInt32(this.valign);
	buffer.writeString("maxWidth");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.maxWidth);
	buffer.writeString("");
}
TextObject.prototype.deserialize_external = function(buffer) {
	let text_is_set = false, font_is_set = false, color_is_set = false, align_is_set = false, valign_is_set = false, maxWidth_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "text":
				this.text = buffer.readString();
				text_is_set = true;
				break;
			case "font":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.font = _objectCache[index];
				} else {
					let font = this.font
					if(!font || font._objectIndex != -index)
						this.font = font = new _Font();
					(_objectCache[-index] = font).deserialize_external(buffer);
				}
				font_is_set = true;
				break;
			case "color":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.color = _objectCache[index];
				} else {
					let color = this.color
					if(!color || color._objectIndex != -index)
						this.color = color = new _Color();
					(_objectCache[-index] = color).deserialize_external(buffer);
				}
				color_is_set = true;
				break;
			case "align":
				buffer.readInt32();
				this.align = buffer.readInt32();
				align_is_set = true;
				break;
			case "valign":
				buffer.readInt32();
				this.valign = buffer.readInt32();
				valign_is_set = true;
				break;
			case "maxWidth":
				buffer.readInt32();
				this.maxWidth = buffer.readFloat64();
				maxWidth_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!text_is_set) this.text = "";
				if(!font_is_set) this.font = null;
				if(!color_is_set) this.color = Color.White;
				if(!align_is_set) this.align = 1/*Center*/;
				if(!valign_is_set) this.valign = 1/*Middle*/;
				if(!maxWidth_is_set) this.maxWidth = 0.0;
				return;
		}
	}
}
function CircularTextObject(position, size, angle, alpha, visibleFor, layer, locked, location, text, font, color, radius, spacing) {
	$Object.call(this, position, size, angle, alpha, visibleFor, layer, locked, location);
	this.type = "CircularTextObject";
	this.text = text;
	this.font = font;
	this.color = color;
	this.radius = radius;
	this.spacing = spacing;
}
function __CircularTextObjectPrototype() { this.constructor = CircularTextObject; }
__CircularTextObjectPrototype.prototype = $Object.prototype;
CircularTextObject.prototype = new __CircularTextObjectPrototype();
CircularTextObject.prototype.tick = function() {
	if(this.alpha) {
		graphics.drawCircularText(this.text, this.position, this.size.x, this.color, this.font, this.layer, this.radius, this.angle, this.spacing, this.visibleFor, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 8597, 8692, null, null));
	}
}
CircularTextObject.prototype.clone = function() {
	let clone = new _CircularTextObject();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.angle = this.angle;
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.text = this.text;
	clone.font = this.font;
	clone.color = this.color;
	clone.radius = this.radius;
	clone.spacing = this.spacing;
	return clone;
}
function _CircularTextObject() {};
_CircularTextObject.prototype = CircularTextObject.prototype;
CircularTextObject.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	buffer.writeString(this.text);
	let font = this.font
	if(font) {
		var index = _objectCacheIndex.get(font);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(font, index = _objectCache.length);
			_objectCache.push(font);
			buffer.writeInt32(-index);
			font._objectIndex = index;
			font.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeFloat64(this.radius);
	buffer.writeFloat64(this.spacing);
}
CircularTextObject.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	this.text = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.font = _objectCache[index];
	} else {
		let font = this.font
		if(!font || font._objectIndex != -index)
			this.font = font = new _Font();
		(_objectCache[-index] = font).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.color = _objectCache[index];
	} else {
		let color = this.color
		if(!color || color._objectIndex != -index)
			this.color = color = new _Color();
		(_objectCache[-index] = color).deserialize_internal(buffer);
	}
	this.radius = buffer.readFloat64();
	this.spacing = buffer.readFloat64();
}
CircularTextObject.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("text");
	buffer.writeString(this.text);
	buffer.writeString("font");
	let font_startPos = buffer.reserveSize();
	let font = this.font
	if(font) {
		var index = _objectCacheIndex.get(font);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(font, index = _objectCache.length);
			_objectCache.push(font);
			buffer.writeInt32(-index);
			font._objectIndex = index;
			font.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(font_startPos);
	buffer.writeString("color");
	let color_startPos = buffer.reserveSize();
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(color_startPos);
	buffer.writeString("radius");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.radius);
	buffer.writeString("spacing");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.spacing);
	buffer.writeString("");
}
CircularTextObject.prototype.deserialize_external = function(buffer) {
	let text_is_set = false, font_is_set = false, color_is_set = false, radius_is_set = false, spacing_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "text":
				this.text = buffer.readString();
				text_is_set = true;
				break;
			case "font":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.font = _objectCache[index];
				} else {
					let font = this.font
					if(!font || font._objectIndex != -index)
						this.font = font = new _Font();
					(_objectCache[-index] = font).deserialize_external(buffer);
				}
				font_is_set = true;
				break;
			case "color":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.color = _objectCache[index];
				} else {
					let color = this.color
					if(!color || color._objectIndex != -index)
						this.color = color = new _Color();
					(_objectCache[-index] = color).deserialize_external(buffer);
				}
				color_is_set = true;
				break;
			case "radius":
				buffer.readInt32();
				this.radius = buffer.readFloat64();
				radius_is_set = true;
				break;
			case "spacing":
				buffer.readInt32();
				this.spacing = buffer.readFloat64();
				spacing_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!text_is_set) this.text = "";
				if(!font_is_set) this.font = null;
				if(!color_is_set) this.color = Color.White;
				if(!radius_is_set) this.radius = 100;
				if(!spacing_is_set) this.spacing = .2;
				return;
		}
	}
}
function ImageObject(position, size, angle, alpha, visibleFor, layer, locked, location, image) {
	$Object.call(this, position, size, angle, alpha, visibleFor, layer, locked, location);
	this.type = "ImageObject";
	this.image = image;
	if(this.size.x == 0 && this.size.y == 0) {
		this.size = this.image.size?.clone();
	}
}
function __ImageObjectPrototype() { this.constructor = ImageObject; }
__ImageObjectPrototype.prototype = $Object.prototype;
ImageObject.prototype = new __ImageObjectPrototype();
ImageObject.prototype.tick = function() {
	if(this.alpha) {
		graphics.drawImage2(this.image, this.position, this.size, this.visibleFor, 0, this.layer, this.alpha, Color.White, this.angle, false, false, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 8833, 8897, null, null));
	}
}
ImageObject.prototype.clone = function() {
	let clone = new _ImageObject();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.angle = this.angle;
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.image = this.image;
	return clone;
}
function _ImageObject() {};
_ImageObject.prototype = ImageObject.prototype;
ImageObject.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	let image = this.image
	if(image) {
		var index = _objectCacheIndex.get(image);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(image, index = _objectCache.length);
			_objectCache.push(image);
			buffer.writeInt32(-index);
			image._objectIndex = index;
			image.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
ImageObject.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.image = _objectCache[index];
	} else {
		let image = this.image
		if(!image || image._objectIndex != -index)
			this.image = image = new _Image();
		(_objectCache[-index] = image).deserialize_internal(buffer);
	}
}
ImageObject.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("image");
	let image_startPos = buffer.reserveSize();
	let image = this.image
	if(image) {
		var index = _objectCacheIndex.get(image);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(image, index = _objectCache.length);
			_objectCache.push(image);
			buffer.writeInt32(-index);
			image._objectIndex = index;
			image.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(image_startPos);
	buffer.writeString("");
}
ImageObject.prototype.deserialize_external = function(buffer) {
	let image_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "image":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.image = _objectCache[index];
				} else {
					let image = this.image
					if(!image || image._objectIndex != -index)
						this.image = image = new _Image();
					(_objectCache[-index] = image).deserialize_external(buffer);
				}
				image_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!image_is_set) this.image = null;
				return;
		}
	}
}
function Effect(position, size, angle, alpha, visibleFor, layer, locked, location, image, framesPerSecond) {
	$Object.call(this, position, size, angle, alpha, visibleFor, layer, locked, location);
	this.type = "Effect";
	this.image = image;
	this.framesPerSecond = framesPerSecond;
	this.startFrame = core.frame;
	if(this.size.x == 0 && this.size.y == 0) {
		this.size = this.image.size?.clone();
	}
}
function __EffectPrototype() { this.constructor = Effect; }
__EffectPrototype.prototype = $Object.prototype;
Effect.prototype = new __EffectPrototype();
Effect.prototype.tick = function() {
	let frame = Math.floor((core.frame - this.startFrame) * Math.max(this.framesPerSecond, 0) / core.targetFps);
	if(this.alpha && frame < this.image.frames.length) {
		graphics.drawImage(this.image, this.position, this.size, this.visibleFor, frame, this.layer, this.alpha, Color.White, 1/*Center*/, 1/*Middle*/, this.location);
	} else {
		Framework.objects.remove(this);
	}
}
Effect.prototype.clone = function() {
	let clone = new _Effect();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.angle = this.angle;
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.image = this.image;
	clone.framesPerSecond = this.framesPerSecond;
	clone.startFrame = this.startFrame;
	return clone;
}
function _Effect() {};
_Effect.prototype = Effect.prototype;
Effect.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	let image = this.image
	if(image) {
		var index = _objectCacheIndex.get(image);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(image, index = _objectCache.length);
			_objectCache.push(image);
			buffer.writeInt32(-index);
			image._objectIndex = index;
			image.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.framesPerSecond);
	buffer.writeInt32(this.startFrame);
}
Effect.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.image = _objectCache[index];
	} else {
		let image = this.image
		if(!image || image._objectIndex != -index)
			this.image = image = new _Image();
		(_objectCache[-index] = image).deserialize_internal(buffer);
	}
	this.framesPerSecond = buffer.readInt32();
	this.startFrame = buffer.readInt32();
}
Effect.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("image");
	let image_startPos = buffer.reserveSize();
	let image = this.image
	if(image) {
		var index = _objectCacheIndex.get(image);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(image, index = _objectCache.length);
			_objectCache.push(image);
			buffer.writeInt32(-index);
			image._objectIndex = index;
			image.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(image_startPos);
	buffer.writeString("framesPerSecond");
	buffer.writeInt32(4);
	buffer.writeInt32(this.framesPerSecond);
	buffer.writeString("startFrame");
	buffer.writeInt32(4);
	buffer.writeInt32(this.startFrame);
	buffer.writeString("");
}
Effect.prototype.deserialize_external = function(buffer) {
	let image_is_set = false, framesPerSecond_is_set = false, startFrame_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "image":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.image = _objectCache[index];
				} else {
					let image = this.image
					if(!image || image._objectIndex != -index)
						this.image = image = new _Image();
					(_objectCache[-index] = image).deserialize_external(buffer);
				}
				image_is_set = true;
				break;
			case "framesPerSecond":
				buffer.readInt32();
				this.framesPerSecond = buffer.readInt32();
				framesPerSecond_is_set = true;
				break;
			case "startFrame":
				buffer.readInt32();
				this.startFrame = buffer.readInt32();
				startFrame_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!image_is_set) this.image = null;
				if(!framesPerSecond_is_set) this.framesPerSecond = 15;
				if(!startFrame_is_set) this.startFrame = core.frame;
				return;
		}
	}
}
function VideoObject(position, size, angle, alpha, visibleFor, layer, locked, location, player, shape) {
	$Object.call(this, position, size, angle, alpha, visibleFor, layer, locked, location);
	this.type = "VideoObject";
	this.player = player;
	this.shape = shape;
}
function __VideoObjectPrototype() { this.constructor = VideoObject; }
__VideoObjectPrototype.prototype = $Object.prototype;
VideoObject.prototype = new __VideoObjectPrototype();
VideoObject.prototype.tick = function() {
	if(this.alpha && (this.player != null)) {
		graphics.drawVideo(this.player, this.position, this.size, this.shape, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 9439, 9478, null, null));
	}
}
VideoObject.prototype.clone = function() {
	let clone = new _VideoObject();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.angle = this.angle;
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.player = this.player;
	clone.shape = this.shape;
	return clone;
}
function _VideoObject() {};
_VideoObject.prototype = VideoObject.prototype;
VideoObject.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	let player = this.player
	if(player) {
		var index = _objectCacheIndex.get(player);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(player, index = _objectCache.length);
			_objectCache.push(player);
			buffer.writeInt32(-index);
			player._objectIndex = index;
			player.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.shape);
}
VideoObject.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.player = _objectCache[index];
	} else {
		let player = this.player
		if(!player || player._objectIndex != -index)
			this.player = player = new _Player();
		(_objectCache[-index] = player).deserialize_internal(buffer);
	}
	this.shape = buffer.readInt32();
}
VideoObject.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("player");
	let player_startPos = buffer.reserveSize();
	let player = this.player
	if(player) {
		var index = _objectCacheIndex.get(player);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(player, index = _objectCache.length);
			_objectCache.push(player);
			buffer.writeInt32(-index);
			player._objectIndex = index;
			player.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(player_startPos);
	buffer.writeString("shape");
	buffer.writeInt32(4);
	buffer.writeInt32(this.shape);
	buffer.writeString("");
}
VideoObject.prototype.deserialize_external = function(buffer) {
	let player_is_set = false, shape_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "player":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.player = _objectCache[index];
				} else {
					let player = this.player
					if(!player || player._objectIndex != -index)
						this.player = player = new _Player();
					(_objectCache[-index] = player).deserialize_external(buffer);
				}
				player_is_set = true;
				break;
			case "shape":
				buffer.readInt32();
				this.shape = buffer.readInt32();
				shape_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!player_is_set) this.player = null;
				if(!shape_is_set) this.shape = 0/*Rectangle*/;
				return;
		}
	}
}
function Button(position, size, angle, alpha, visibleFor, layer, locked, location, image, text, textColor, frame, fontSize, clickableMargin, textOffset, scaleOnHover, frameOnHover, showClickableArea, clickableBy, enabled, alphaWhenDisabled, hotkey, onClick, removeOnClick) {
	$Object.call(this, position, size, angle, alpha, visibleFor, layer, locked, location);
	this.type = "Button";
	this.image = image;
	this.text = text;
	this.textColor = textColor;
	this.frame = frame;
	this.fontSize = fontSize;
	this.clickableMargin = clickableMargin?.clone();
	this.textOffset = textOffset?.clone();
	this.scaleOnHover = scaleOnHover;
	this.frameOnHover = frameOnHover;
	this.showClickableArea = showClickableArea;
	this.clickableBy = clickableBy;
	this.enabled = enabled;
	this.alphaWhenDisabled = alphaWhenDisabled;
	this.hotkey = hotkey;
	this.onClick = onClick;
	this.removeOnClick = removeOnClick;
}
function __ButtonPrototype() { this.constructor = Button; }
__ButtonPrototype.prototype = $Object.prototype;
Button.prototype = new __ButtonPrototype();
Button.prototype.tick = function() {
	if(this.alpha) {
		graphics.drawButton(this.image, this.text, this.position, this.size, this.frame, this.textColor, this.fontSize, this.textOffset, this.clickableMargin, this.showClickableArea, this.scaleOnHover, this.frameOnHover, null, null, null, this.visibleFor, this.clickableBy, this.hotkey, this.layer, this.alpha, this.enabled, this.alphaWhenDisabled, touch => {
			if(this.removeOnClick) {
				this.removeAtEndOfFrame();
			}
			this.onClick?.invoke(touch);
		}, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 10836, 11130, null, null));
	}
}
Button.prototype.clone = function() {
	let clone = new _Button();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.angle = this.angle;
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.image = this.image;
	clone.text = this.text;
	clone.textColor = this.textColor;
	clone.frame = this.frame;
	clone.fontSize = this.fontSize;
	clone.clickableMargin = this.clickableMargin.clone();
	clone.textOffset = this.textOffset.clone();
	clone.scaleOnHover = this.scaleOnHover;
	clone.frameOnHover = this.frameOnHover;
	clone.showClickableArea = this.showClickableArea;
	clone.clickableBy = this.clickableBy;
	clone.enabled = this.enabled;
	clone.alphaWhenDisabled = this.alphaWhenDisabled;
	clone.hotkey = this.hotkey;
	clone.onClick = this.onClick;
	clone.removeOnClick = this.removeOnClick;
	return clone;
}
function _Button() {};
_Button.prototype = Button.prototype;
Button.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	let image = this.image
	if(image) {
		var index = _objectCacheIndex.get(image);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(image, index = _objectCache.length);
			_objectCache.push(image);
			buffer.writeInt32(-index);
			image._objectIndex = index;
			image.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeString(this.text);
	let textColor = this.textColor
	if(textColor) {
		var index = _objectCacheIndex.get(textColor);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(textColor, index = _objectCache.length);
			_objectCache.push(textColor);
			buffer.writeInt32(-index);
			textColor._objectIndex = index;
			textColor.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.frame);
	buffer.writeInt32(this.fontSize);
	(this.clickableMargin || new _Vector2()).serialize_internal(buffer);
	(this.textOffset || new _Vector2()).serialize_internal(buffer);
	buffer.writeFloat64(this.scaleOnHover);
	buffer.writeInt32(this.frameOnHover);
	buffer.writeBool(this.showClickableArea);
	let clickableBy = this.clickableBy
	if(clickableBy) {
		var index = _objectCacheIndex.get(clickableBy);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(clickableBy, index = _objectCache.length);
			_objectCache.push(clickableBy);
			buffer.writeInt32(-index);
			clickableBy._objectIndex = index;
			buffer.writeInt32(clickableBy.length);
			for(let i=0, len=clickableBy.length; i<len; ++i) {
				let clickableBy_item = clickableBy[i]
				if(clickableBy_item) {
					var index = _objectCacheIndex.get(clickableBy_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(clickableBy_item, index = _objectCache.length);
						_objectCache.push(clickableBy_item);
						buffer.writeInt32(-index);
						clickableBy_item._objectIndex = index;
						clickableBy_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeBool(this.enabled);
	buffer.writeFloat64(this.alphaWhenDisabled);
	buffer.writeInt32(this.hotkey);
	let onClick = this.onClick
	if(onClick) {
		var index = _objectCacheIndex.get(onClick);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(onClick, index = _objectCache.length);
			_objectCache.push(onClick);
			buffer.writeInt32(-index);
			buffer.writeInt32(onClick._id);
			onClick._objectIndex = index;
			onClick.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeBool(this.removeOnClick);
}
Button.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.image = _objectCache[index];
	} else {
		let image = this.image
		if(!image || image._objectIndex != -index)
			this.image = image = new _Image();
		(_objectCache[-index] = image).deserialize_internal(buffer);
	}
	this.text = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.textColor = _objectCache[index];
	} else {
		let textColor = this.textColor
		if(!textColor || textColor._objectIndex != -index)
			this.textColor = textColor = new _Color();
		(_objectCache[-index] = textColor).deserialize_internal(buffer);
	}
	this.frame = buffer.readInt32();
	this.fontSize = buffer.readInt32();
	(this.clickableMargin || (this.clickableMargin = new _Vector2())).deserialize_internal(buffer);
	(this.textOffset || (this.textOffset = new _Vector2())).deserialize_internal(buffer);
	this.scaleOnHover = buffer.readFloat64();
	this.frameOnHover = buffer.readInt32();
	this.showClickableArea = buffer.readBool();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.clickableBy = _objectCache[index];
	} else {
		let clickableBy = this.clickableBy
		if(!clickableBy || clickableBy._objectIndex != -index) this.clickableBy = clickableBy = [];
		_objectCache[-index] = clickableBy;
		for(let i=0, len = clickableBy.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					clickableBy[i] = _objectCache[index];
				} else {
					let clickableBy_item = clickableBy[i]
					if(!clickableBy_item || clickableBy_item._objectIndex != -index)
						clickableBy[i] = clickableBy_item = new _Player();
					(_objectCache[-index] = clickableBy_item).deserialize_internal(buffer);
				}
		}
	}
	this.enabled = buffer.readBool();
	this.alphaWhenDisabled = buffer.readFloat64();
	this.hotkey = buffer.readInt32();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.onClick = _objectCache[index];
	} else {
		let onClick = this.onClick
		let _id = buffer.readInt32();
		if(!onClick || onClick._id != _id || onClick._objectIndex != -index)
			this.onClick = onClick = new _lambdaContructors[_id]();
		onClick._id = _id;
		(_objectCache[-index] = onClick).deserialize_internal(buffer);
	}
	this.removeOnClick = buffer.readBool();
}
Button.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("image");
	let image_startPos = buffer.reserveSize();
	let image = this.image
	if(image) {
		var index = _objectCacheIndex.get(image);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(image, index = _objectCache.length);
			_objectCache.push(image);
			buffer.writeInt32(-index);
			image._objectIndex = index;
			image.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(image_startPos);
	buffer.writeString("text");
	buffer.writeString(this.text);
	buffer.writeString("textColor");
	let textColor_startPos = buffer.reserveSize();
	let textColor = this.textColor
	if(textColor) {
		var index = _objectCacheIndex.get(textColor);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(textColor, index = _objectCache.length);
			_objectCache.push(textColor);
			buffer.writeInt32(-index);
			textColor._objectIndex = index;
			textColor.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(textColor_startPos);
	buffer.writeString("frame");
	buffer.writeInt32(4);
	buffer.writeInt32(this.frame);
	buffer.writeString("fontSize");
	buffer.writeInt32(4);
	buffer.writeInt32(this.fontSize);
	buffer.writeString("clickableMargin");
	let clickableMargin_startPos = buffer.reserveSize();
	(this.clickableMargin || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(clickableMargin_startPos);
	buffer.writeString("textOffset");
	let textOffset_startPos = buffer.reserveSize();
	(this.textOffset || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(textOffset_startPos);
	buffer.writeString("scaleOnHover");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.scaleOnHover);
	buffer.writeString("frameOnHover");
	buffer.writeInt32(4);
	buffer.writeInt32(this.frameOnHover);
	buffer.writeString("showClickableArea");
	buffer.writeInt32(1);
	buffer.writeBool(this.showClickableArea);
	buffer.writeString("clickableBy");
	let clickableBy = this.clickableBy
	let clickableBy_startPos = buffer.reserveSize();
	if(clickableBy) {
		var index = _objectCacheIndex.get(clickableBy);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(clickableBy, index = _objectCache.length);
			_objectCache.push(clickableBy);
			buffer.writeInt32(-index);
			clickableBy._objectIndex = index;
			buffer.writeInt32(clickableBy.length);
			for(let i=0, len=clickableBy.length; i<len; ++i) {
				let clickableBy_item = clickableBy[i]
				if(clickableBy_item) {
					var index = _objectCacheIndex.get(clickableBy_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(clickableBy_item, index = _objectCache.length);
						_objectCache.push(clickableBy_item);
						buffer.writeInt32(-index);
						clickableBy_item._objectIndex = index;
						clickableBy_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(clickableBy_startPos);
	buffer.writeString("enabled");
	buffer.writeInt32(1);
	buffer.writeBool(this.enabled);
	buffer.writeString("alphaWhenDisabled");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.alphaWhenDisabled);
	buffer.writeString("hotkey");
	buffer.writeInt32(4);
	buffer.writeInt32(this.hotkey);
	buffer.writeString("onClick");
	let onClick_startPos = buffer.reserveSize();
	let onClick = this.onClick
	if(onClick) {
		var index = _objectCacheIndex.get(onClick);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(onClick, index = _objectCache.length);
			_objectCache.push(onClick);
			buffer.writeInt32(-index);
			buffer.writeInt32(onClick._id);
			onClick._objectIndex = index;
			onClick.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(onClick_startPos);
	buffer.writeString("removeOnClick");
	buffer.writeInt32(1);
	buffer.writeBool(this.removeOnClick);
	buffer.writeString("");
}
Button.prototype.deserialize_external = function(buffer) {
	let image_is_set = false, text_is_set = false, textColor_is_set = false, frame_is_set = false, fontSize_is_set = false, clickableMargin_is_set = false, textOffset_is_set = false, scaleOnHover_is_set = false, frameOnHover_is_set = false, showClickableArea_is_set = false, clickableBy_is_set = false, enabled_is_set = false, alphaWhenDisabled_is_set = false, hotkey_is_set = false, onClick_is_set = false, removeOnClick_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "image":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.image = _objectCache[index];
				} else {
					let image = this.image
					if(!image || image._objectIndex != -index)
						this.image = image = new _Image();
					(_objectCache[-index] = image).deserialize_external(buffer);
				}
				image_is_set = true;
				break;
			case "text":
				this.text = buffer.readString();
				text_is_set = true;
				break;
			case "textColor":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.textColor = _objectCache[index];
				} else {
					let textColor = this.textColor
					if(!textColor || textColor._objectIndex != -index)
						this.textColor = textColor = new _Color();
					(_objectCache[-index] = textColor).deserialize_external(buffer);
				}
				textColor_is_set = true;
				break;
			case "frame":
				buffer.readInt32();
				this.frame = buffer.readInt32();
				frame_is_set = true;
				break;
			case "fontSize":
				buffer.readInt32();
				this.fontSize = buffer.readInt32();
				fontSize_is_set = true;
				break;
			case "clickableMargin":
				buffer.readInt32();
				(this.clickableMargin || (this.clickableMargin = new _Vector2())).deserialize_external(buffer);
				clickableMargin_is_set = true;
				break;
			case "textOffset":
				buffer.readInt32();
				(this.textOffset || (this.textOffset = new _Vector2())).deserialize_external(buffer);
				textOffset_is_set = true;
				break;
			case "scaleOnHover":
				buffer.readInt32();
				this.scaleOnHover = buffer.readFloat64();
				scaleOnHover_is_set = true;
				break;
			case "frameOnHover":
				buffer.readInt32();
				this.frameOnHover = buffer.readInt32();
				frameOnHover_is_set = true;
				break;
			case "showClickableArea":
				buffer.readInt32();
				this.showClickableArea = buffer.readBool();
				showClickableArea_is_set = true;
				break;
			case "clickableBy":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.clickableBy = _objectCache[index];
				} else {
					let clickableBy = this.clickableBy
					if(!clickableBy || clickableBy._objectIndex != -index) this.clickableBy = clickableBy = [];
					_objectCache[-index] = clickableBy;
					for(let i=0, len = clickableBy.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								clickableBy[i] = _objectCache[index];
							} else {
								let clickableBy_item = clickableBy[i]
								if(!clickableBy_item || clickableBy_item._objectIndex != -index)
									clickableBy[i] = clickableBy_item = new _Player();
								(_objectCache[-index] = clickableBy_item).deserialize_external(buffer);
							}
					}
				}
				clickableBy_is_set = true;
				break;
			case "enabled":
				buffer.readInt32();
				this.enabled = buffer.readBool();
				enabled_is_set = true;
				break;
			case "alphaWhenDisabled":
				buffer.readInt32();
				this.alphaWhenDisabled = buffer.readFloat64();
				alphaWhenDisabled_is_set = true;
				break;
			case "hotkey":
				buffer.readInt32();
				this.hotkey = buffer.readInt32();
				hotkey_is_set = true;
				break;
			case "onClick":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.onClick = _objectCache[index];
				} else {
					let onClick = this.onClick
					let _id = buffer.readInt32();
					if(!onClick || onClick._id != _id || onClick._objectIndex != -index)
						this.onClick = onClick = new _lambdaContructors[_id]();
					onClick._id = _id;
					(_objectCache[-index] = onClick).deserialize_external(buffer);
				}
				onClick_is_set = true;
				break;
			case "removeOnClick":
				buffer.readInt32();
				this.removeOnClick = buffer.readBool();
				removeOnClick_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!image_is_set) this.image = null;
				if(!text_is_set) this.text = "";
				if(!textColor_is_set) this.textColor = Color.White;
				if(!frame_is_set) this.frame = 0;
				if(!fontSize_is_set) this.fontSize = 18;
				if(!clickableMargin_is_set) this.clickableMargin = new Vector2(16, 16);
				if(!textOffset_is_set) this.textOffset = new Vector2(0, 0);
				if(!scaleOnHover_is_set) this.scaleOnHover = 1.0;
				if(!frameOnHover_is_set) this.frameOnHover = 1;
				if(!showClickableArea_is_set) this.showClickableArea = false;
				if(!clickableBy_is_set) this.clickableBy = null;
				if(!enabled_is_set) this.enabled = true;
				if(!alphaWhenDisabled_is_set) this.alphaWhenDisabled = .5;
				if(!hotkey_is_set) this.hotkey = 0/*None*/;
				if(!onClick_is_set) this.onClick = null;
				if(!removeOnClick_is_set) this.removeOnClick = false;
				return;
		}
	}
}
function StandardButton(position, size, angle, alpha, visibleFor, layer, locked, location, text, clickableBy, enabled, hotkey, onClick, removeOnClick) {
	$Object.call(this, position, size, angle, alpha, visibleFor, layer, locked, location);
	this.type = "StandardButton";
	this.text = text;
	this.clickableBy = clickableBy;
	this.enabled = enabled;
	this.hotkey = hotkey;
	this.onClick = onClick;
	this.removeOnClick = removeOnClick;
}
function __StandardButtonPrototype() { this.constructor = StandardButton; }
__StandardButtonPrototype.prototype = $Object.prototype;
StandardButton.prototype = new __StandardButtonPrototype();
StandardButton.prototype.tick = function() {
	if(this.alpha) {
		graphics.drawStandardButton(this.text, this.position, null, this.visibleFor, this.clickableBy, this.hotkey, this.layer, 1.0, this.enabled, touch => {
			if(this.removeOnClick) {
				this.removeAtEndOfFrame();
			}
			this.onClick?.invoke(touch);
		}, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 11715, 11874, null, null));
	}
}
StandardButton.prototype.clone = function() {
	let clone = new _StandardButton();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.angle = this.angle;
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.text = this.text;
	clone.clickableBy = this.clickableBy;
	clone.enabled = this.enabled;
	clone.hotkey = this.hotkey;
	clone.onClick = this.onClick;
	clone.removeOnClick = this.removeOnClick;
	return clone;
}
function _StandardButton() {};
_StandardButton.prototype = StandardButton.prototype;
StandardButton.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	buffer.writeString(this.text);
	let clickableBy = this.clickableBy
	if(clickableBy) {
		var index = _objectCacheIndex.get(clickableBy);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(clickableBy, index = _objectCache.length);
			_objectCache.push(clickableBy);
			buffer.writeInt32(-index);
			clickableBy._objectIndex = index;
			buffer.writeInt32(clickableBy.length);
			for(let i=0, len=clickableBy.length; i<len; ++i) {
				let clickableBy_item = clickableBy[i]
				if(clickableBy_item) {
					var index = _objectCacheIndex.get(clickableBy_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(clickableBy_item, index = _objectCache.length);
						_objectCache.push(clickableBy_item);
						buffer.writeInt32(-index);
						clickableBy_item._objectIndex = index;
						clickableBy_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeBool(this.enabled);
	buffer.writeInt32(this.hotkey);
	let onClick = this.onClick
	if(onClick) {
		var index = _objectCacheIndex.get(onClick);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(onClick, index = _objectCache.length);
			_objectCache.push(onClick);
			buffer.writeInt32(-index);
			buffer.writeInt32(onClick._id);
			onClick._objectIndex = index;
			onClick.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeBool(this.removeOnClick);
}
StandardButton.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	this.text = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.clickableBy = _objectCache[index];
	} else {
		let clickableBy = this.clickableBy
		if(!clickableBy || clickableBy._objectIndex != -index) this.clickableBy = clickableBy = [];
		_objectCache[-index] = clickableBy;
		for(let i=0, len = clickableBy.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					clickableBy[i] = _objectCache[index];
				} else {
					let clickableBy_item = clickableBy[i]
					if(!clickableBy_item || clickableBy_item._objectIndex != -index)
						clickableBy[i] = clickableBy_item = new _Player();
					(_objectCache[-index] = clickableBy_item).deserialize_internal(buffer);
				}
		}
	}
	this.enabled = buffer.readBool();
	this.hotkey = buffer.readInt32();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.onClick = _objectCache[index];
	} else {
		let onClick = this.onClick
		let _id = buffer.readInt32();
		if(!onClick || onClick._id != _id || onClick._objectIndex != -index)
			this.onClick = onClick = new _lambdaContructors[_id]();
		onClick._id = _id;
		(_objectCache[-index] = onClick).deserialize_internal(buffer);
	}
	this.removeOnClick = buffer.readBool();
}
StandardButton.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("text");
	buffer.writeString(this.text);
	buffer.writeString("clickableBy");
	let clickableBy = this.clickableBy
	let clickableBy_startPos = buffer.reserveSize();
	if(clickableBy) {
		var index = _objectCacheIndex.get(clickableBy);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(clickableBy, index = _objectCache.length);
			_objectCache.push(clickableBy);
			buffer.writeInt32(-index);
			clickableBy._objectIndex = index;
			buffer.writeInt32(clickableBy.length);
			for(let i=0, len=clickableBy.length; i<len; ++i) {
				let clickableBy_item = clickableBy[i]
				if(clickableBy_item) {
					var index = _objectCacheIndex.get(clickableBy_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(clickableBy_item, index = _objectCache.length);
						_objectCache.push(clickableBy_item);
						buffer.writeInt32(-index);
						clickableBy_item._objectIndex = index;
						clickableBy_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(clickableBy_startPos);
	buffer.writeString("enabled");
	buffer.writeInt32(1);
	buffer.writeBool(this.enabled);
	buffer.writeString("hotkey");
	buffer.writeInt32(4);
	buffer.writeInt32(this.hotkey);
	buffer.writeString("onClick");
	let onClick_startPos = buffer.reserveSize();
	let onClick = this.onClick
	if(onClick) {
		var index = _objectCacheIndex.get(onClick);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(onClick, index = _objectCache.length);
			_objectCache.push(onClick);
			buffer.writeInt32(-index);
			buffer.writeInt32(onClick._id);
			onClick._objectIndex = index;
			onClick.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(onClick_startPos);
	buffer.writeString("removeOnClick");
	buffer.writeInt32(1);
	buffer.writeBool(this.removeOnClick);
	buffer.writeString("");
}
StandardButton.prototype.deserialize_external = function(buffer) {
	let text_is_set = false, clickableBy_is_set = false, enabled_is_set = false, hotkey_is_set = false, onClick_is_set = false, removeOnClick_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "text":
				this.text = buffer.readString();
				text_is_set = true;
				break;
			case "clickableBy":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.clickableBy = _objectCache[index];
				} else {
					let clickableBy = this.clickableBy
					if(!clickableBy || clickableBy._objectIndex != -index) this.clickableBy = clickableBy = [];
					_objectCache[-index] = clickableBy;
					for(let i=0, len = clickableBy.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								clickableBy[i] = _objectCache[index];
							} else {
								let clickableBy_item = clickableBy[i]
								if(!clickableBy_item || clickableBy_item._objectIndex != -index)
									clickableBy[i] = clickableBy_item = new _Player();
								(_objectCache[-index] = clickableBy_item).deserialize_external(buffer);
							}
					}
				}
				clickableBy_is_set = true;
				break;
			case "enabled":
				buffer.readInt32();
				this.enabled = buffer.readBool();
				enabled_is_set = true;
				break;
			case "hotkey":
				buffer.readInt32();
				this.hotkey = buffer.readInt32();
				hotkey_is_set = true;
				break;
			case "onClick":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.onClick = _objectCache[index];
				} else {
					let onClick = this.onClick
					let _id = buffer.readInt32();
					if(!onClick || onClick._id != _id || onClick._objectIndex != -index)
						this.onClick = onClick = new _lambdaContructors[_id]();
					onClick._id = _id;
					(_objectCache[-index] = onClick).deserialize_external(buffer);
				}
				onClick_is_set = true;
				break;
			case "removeOnClick":
				buffer.readInt32();
				this.removeOnClick = buffer.readBool();
				removeOnClick_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!text_is_set) this.text = "";
				if(!clickableBy_is_set) this.clickableBy = null;
				if(!enabled_is_set) this.enabled = true;
				if(!hotkey_is_set) this.hotkey = 0/*None*/;
				if(!onClick_is_set) this.onClick = null;
				if(!removeOnClick_is_set) this.removeOnClick = false;
				return;
		}
	}
}
function ParticleSystem(position, size, angle, alpha, visibleFor, layer, locked, location, image, minSpeed, maxSpeed, particlesPerBurst, burstInterval, nextBurst, bursts, gravity, maxRotationSpeed, mode, angleSpread) {
	$Object.call(this, position, size, angle, alpha, visibleFor, layer, locked, location);
	this.type = "ParticleSystem";
	this.particles = [];
	this.image = image;
	this.minSpeed = minSpeed;
	this.maxSpeed = maxSpeed;
	this.particlesPerBurst = particlesPerBurst;
	this.burstInterval = burstInterval;
	this.nextBurst = nextBurst;
	this.bursts = bursts;
	this.gravity = gravity;
	this.maxRotationSpeed = maxRotationSpeed;
	this.mode = mode;
	this.angleSpread = angleSpread;
	this.burst = 0;
}
function __ParticleSystemPrototype() { this.constructor = ParticleSystem; }
__ParticleSystemPrototype.prototype = $Object.prototype;
ParticleSystem.prototype = new __ParticleSystemPrototype();
ParticleSystem.prototype.debugString = function() {
	$Object.prototype.debugString.call(this);
	return "(ParticleSystem "+this.position.x.toString()+" "+this.position.y.toString()+" "+this.particles.length?.toString()+")";
}
ParticleSystem.prototype.tick = function() {
	if(Time.now > this.nextBurst) {
		if(this.mode == 1/*OneParticlePerImageFrame*/) {
			for(let i=0; i<this.image.frames.length; ++i) {
				let angle = -math.randomFloat2(.5);
				let speedFactor = math.randomFloat(this.minSpeed, this.maxSpeed);
				this.particles.push(new Particle(this.position, math.getVectorForAngle(angle, speedFactor), 0, math.randomFloat(-this.maxRotationSpeed, this.maxRotationSpeed), i));
			}
			this.nextBurst = Number.MAX_VALUE;
		} else {
			for(let i=0; i<this.particlesPerBurst; ++i) {
				let angle = -math.randomFloat2(this.angleSpread);
				let speedFactor = math.randomFloat(this.minSpeed, this.maxSpeed);
				this.particles.push(new Particle(this.position, math.getVectorForAngle(angle, speedFactor), angle, math.randomFloat(-this.maxRotationSpeed, this.maxRotationSpeed), math.randomInteger2(this.image.frames.length)));
			}
			this.nextBurst = (++this.burst < this.bursts ? Time.now + this.burstInterval : Number.MAX_VALUE);
		}
	}
	for(let _subject=this.particles, i=_subject.length-1; i>=0; --i) { let it = _subject[i]; {
		graphics.move(it.pos, () => {
			graphics.rotate(it.angle, () => {
				graphics.drawImage(this.image, new Vector2(0.0, 0.0, null), new Vector2(0.0, 0.0, null), this.visibleFor, it.frame, 0, 1.0, Color.White, 1/*Center*/, 1/*Middle*/, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 13393, 13434, null, null));
			});
		});
		it.pos.plusAssign(it.speed);
		it.speed.y += this.gravity;
		it.angle += it.rotationSpeed;
		if(it.pos.y > graphics.referenceSize.y * .55) {
			this.particles.splice(i, 1);
		}
	}}
	if(this.particles.length == 0) {
		this.removeImmediately();
	}
}
ParticleSystem.prototype.clone = function() {
	let clone = new _ParticleSystem();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.angle = this.angle;
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.particles = this.particles;
	clone.image = this.image;
	clone.minSpeed = this.minSpeed;
	clone.maxSpeed = this.maxSpeed;
	clone.particlesPerBurst = this.particlesPerBurst;
	clone.burstInterval = this.burstInterval;
	clone.nextBurst = this.nextBurst;
	clone.bursts = this.bursts;
	clone.gravity = this.gravity;
	clone.maxRotationSpeed = this.maxRotationSpeed;
	clone.mode = this.mode;
	clone.angleSpread = this.angleSpread;
	clone.burst = this.burst;
	return clone;
}
function _ParticleSystem() {};
_ParticleSystem.prototype = ParticleSystem.prototype;
ParticleSystem.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	let particles = this.particles
	if(particles) {
		var index = _objectCacheIndex.get(particles);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(particles, index = _objectCache.length);
			_objectCache.push(particles);
			buffer.writeInt32(-index);
			particles._objectIndex = index;
			buffer.writeInt32(particles.length);
			for(let i=0, len=particles.length; i<len; ++i) {
				(particles[i] || new _Particle()).serialize_internal(buffer);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let image = this.image
	if(image) {
		var index = _objectCacheIndex.get(image);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(image, index = _objectCache.length);
			_objectCache.push(image);
			buffer.writeInt32(-index);
			image._objectIndex = index;
			image.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeFloat64(this.minSpeed);
	buffer.writeFloat64(this.maxSpeed);
	buffer.writeInt32(this.particlesPerBurst);
	buffer.writeInt32(this.burstInterval);
	buffer.writeFloat64(this.nextBurst);
	buffer.writeInt32(this.bursts);
	buffer.writeFloat64(this.gravity);
	buffer.writeFloat64(this.maxRotationSpeed);
	buffer.writeInt32(this.mode);
	buffer.writeFloat64(this.angleSpread);
	buffer.writeInt32(this.burst);
}
ParticleSystem.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.particles = _objectCache[index];
	} else {
		let particles = this.particles
		if(!particles || particles._objectIndex != -index) this.particles = particles = [];
		_objectCache[-index] = particles;
		for(let i=0, len = particles.length = buffer.readInt32(); i<len; ++i) {
				(particles[i] || (particles[i] = new _Particle())).deserialize_internal(buffer);
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.image = _objectCache[index];
	} else {
		let image = this.image
		if(!image || image._objectIndex != -index)
			this.image = image = new _Image();
		(_objectCache[-index] = image).deserialize_internal(buffer);
	}
	this.minSpeed = buffer.readFloat64();
	this.maxSpeed = buffer.readFloat64();
	this.particlesPerBurst = buffer.readInt32();
	this.burstInterval = buffer.readInt32();
	this.nextBurst = buffer.readFloat64();
	this.bursts = buffer.readInt32();
	this.gravity = buffer.readFloat64();
	this.maxRotationSpeed = buffer.readFloat64();
	this.mode = buffer.readInt32();
	this.angleSpread = buffer.readFloat64();
	this.burst = buffer.readInt32();
}
ParticleSystem.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("particles");
	let particles = this.particles
	let particles_startPos = buffer.reserveSize();
	if(particles) {
		var index = _objectCacheIndex.get(particles);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(particles, index = _objectCache.length);
			_objectCache.push(particles);
			buffer.writeInt32(-index);
			particles._objectIndex = index;
			buffer.writeInt32(particles.length);
			for(let i=0, len=particles.length; i<len; ++i) {
				(particles[i] || new _Particle()).serialize_external(buffer);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(particles_startPos);
	buffer.writeString("image");
	let image_startPos = buffer.reserveSize();
	let image = this.image
	if(image) {
		var index = _objectCacheIndex.get(image);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(image, index = _objectCache.length);
			_objectCache.push(image);
			buffer.writeInt32(-index);
			image._objectIndex = index;
			image.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(image_startPos);
	buffer.writeString("minSpeed");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.minSpeed);
	buffer.writeString("maxSpeed");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.maxSpeed);
	buffer.writeString("particlesPerBurst");
	buffer.writeInt32(4);
	buffer.writeInt32(this.particlesPerBurst);
	buffer.writeString("burstInterval");
	buffer.writeInt32(4);
	buffer.writeInt32(this.burstInterval);
	buffer.writeString("nextBurst");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.nextBurst);
	buffer.writeString("bursts");
	buffer.writeInt32(4);
	buffer.writeInt32(this.bursts);
	buffer.writeString("gravity");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.gravity);
	buffer.writeString("maxRotationSpeed");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.maxRotationSpeed);
	buffer.writeString("mode");
	buffer.writeInt32(4);
	buffer.writeInt32(this.mode);
	buffer.writeString("angleSpread");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.angleSpread);
	buffer.writeString("burst");
	buffer.writeInt32(4);
	buffer.writeInt32(this.burst);
	buffer.writeString("");
}
ParticleSystem.prototype.deserialize_external = function(buffer) {
	let particles_is_set = false, image_is_set = false, minSpeed_is_set = false, maxSpeed_is_set = false, particlesPerBurst_is_set = false, burstInterval_is_set = false, nextBurst_is_set = false, bursts_is_set = false, gravity_is_set = false, maxRotationSpeed_is_set = false, mode_is_set = false, angleSpread_is_set = false, burst_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "particles":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.particles = _objectCache[index];
				} else {
					let particles = this.particles
					if(!particles || particles._objectIndex != -index) this.particles = particles = [];
					_objectCache[-index] = particles;
					for(let i=0, len = particles.length = buffer.readInt32(); i<len; ++i) {
							(particles[i] || (particles[i] = new _Particle())).deserialize_external(buffer);
					}
				}
				particles_is_set = true;
				break;
			case "image":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.image = _objectCache[index];
				} else {
					let image = this.image
					if(!image || image._objectIndex != -index)
						this.image = image = new _Image();
					(_objectCache[-index] = image).deserialize_external(buffer);
				}
				image_is_set = true;
				break;
			case "minSpeed":
				buffer.readInt32();
				this.minSpeed = buffer.readFloat64();
				minSpeed_is_set = true;
				break;
			case "maxSpeed":
				buffer.readInt32();
				this.maxSpeed = buffer.readFloat64();
				maxSpeed_is_set = true;
				break;
			case "particlesPerBurst":
				buffer.readInt32();
				this.particlesPerBurst = buffer.readInt32();
				particlesPerBurst_is_set = true;
				break;
			case "burstInterval":
				buffer.readInt32();
				this.burstInterval = buffer.readInt32();
				burstInterval_is_set = true;
				break;
			case "nextBurst":
				buffer.readInt32();
				this.nextBurst = buffer.readFloat64();
				nextBurst_is_set = true;
				break;
			case "bursts":
				buffer.readInt32();
				this.bursts = buffer.readInt32();
				bursts_is_set = true;
				break;
			case "gravity":
				buffer.readInt32();
				this.gravity = buffer.readFloat64();
				gravity_is_set = true;
				break;
			case "maxRotationSpeed":
				buffer.readInt32();
				this.maxRotationSpeed = buffer.readFloat64();
				maxRotationSpeed_is_set = true;
				break;
			case "mode":
				buffer.readInt32();
				this.mode = buffer.readInt32();
				mode_is_set = true;
				break;
			case "angleSpread":
				buffer.readInt32();
				this.angleSpread = buffer.readFloat64();
				angleSpread_is_set = true;
				break;
			case "burst":
				buffer.readInt32();
				this.burst = buffer.readInt32();
				burst_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!particles_is_set) this.particles = [];
				if(!image_is_set) this.image = $Image.starParticle;
				if(!minSpeed_is_set) this.minSpeed = 10.0;
				if(!maxSpeed_is_set) this.maxSpeed = 25.0;
				if(!particlesPerBurst_is_set) this.particlesPerBurst = 30;
				if(!burstInterval_is_set) this.burstInterval = 500;
				if(!nextBurst_is_set) this.nextBurst = (-1);
				if(!bursts_is_set) this.bursts = 10;
				if(!gravity_is_set) this.gravity = 1.0;
				if(!maxRotationSpeed_is_set) this.maxRotationSpeed = .05;
				if(!mode_is_set) this.mode = 0/*Burst*/;
				if(!angleSpread_is_set) this.angleSpread = 1.0;
				if(!burst_is_set) this.burst = 0;
				return;
		}
	}
}
function Lambda22() {
	this._id = 22;
}
Lambda22.prototype.invoke = function(value, touch) {
	core.restart();
}
Lambda22.prototype.serialize_internal = function(buffer) {
}
Lambda22.prototype.deserialize_internal = function(buffer) {
}
Lambda22.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda22.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda22() {
	this._id = 22;
};
_Lambda22.prototype = Lambda22.prototype;
function Lambda23() {
	this._id = 23;
}
Lambda23.prototype.invoke = function(value, touch) {
	core.saveEventStreamAndLogs();
}
Lambda23.prototype.serialize_internal = function(buffer) {
}
Lambda23.prototype.deserialize_internal = function(buffer) {
}
Lambda23.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda23.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda23() {
	this._id = 23;
};
_Lambda23.prototype = Lambda23.prototype;
function Lambda24() {
	this._id = 24;
}
Lambda24.prototype.invoke = function(value, touch) {
	lobby.show();
}
Lambda24.prototype.serialize_internal = function(buffer) {
}
Lambda24.prototype.deserialize_internal = function(buffer) {
}
Lambda24.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda24.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda24() {
	this._id = 24;
};
_Lambda24.prototype = Lambda24.prototype;
function Lambda25() {
	this._id = 25;
}
Lambda25.prototype.invoke = function(value, touch) {
	Platform.setFullscreen(false, touch.by);
}
Lambda25.prototype.serialize_internal = function(buffer) {
}
Lambda25.prototype.deserialize_internal = function(buffer) {
}
Lambda25.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda25.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda25() {
	this._id = 25;
};
_Lambda25.prototype = Lambda25.prototype;
function Menu(position, size, angle, alpha, visibleFor, layer, locked, location, popupPosition, items, includeDefaultItems, overlayColor) {
	$Object.call(this, position, size, angle, alpha, visibleFor, layer, locked, location);
	this.type = "Menu";
	this.popupPosition = popupPosition?.clone();
	this.items = items;
	this.includeDefaultItems = includeDefaultItems;
	this.overlayColor = overlayColor;
	this.active = false;
	if(this.includeDefaultItems) {
		this.items.splice(0, 0, new MenuItem($Image.New, "New Game", 0/*Button*/, false, new Lambda22()));
		this.items.push(new MenuItem($Image.Save, "Save Game", 0/*Button*/, false, new Lambda23()));
		this.items.push(new MenuItem($Image.Back, "Back to Lobby", 0/*Button*/, false, new Lambda24()));
		this.items.push(new MenuItem($Image.Quit, "Exit Fullscreen", 0/*Button*/, false, new Lambda25()));
	}
}
function __MenuPrototype() { this.constructor = Menu; }
__MenuPrototype.prototype = $Object.prototype;
Menu.prototype = new __MenuPrototype();
Menu.prototype.tick = function() {
	let doNotClose = false;
	if(this.active) {
		for(let i=0, _subject=this.items, _center = this.popupPosition, _delta = new Vector2(0, 60, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 14442, 14448, null, null)), _len=_subject.length, _x = _center.x-(_len-1)*_delta.x/2, _y=_center.y-(_len-1)*_delta.y/2; i<_len; ++i, _x += _delta.x, _y += _delta.y) { let item = _subject[i], pos = new Vector2(_x, _y, _center.location || _delta.location ? new SourceCodeLocation(null, 0, 0, _center.location, _delta.location) : null); {
			graphics.drawText(item.label, pos.plus(new Vector2(-60, 0.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 14482, 14487, null, null))), new Vector2(30, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 14494, 14496, null, null)), null, 0/*Left*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, int.maxValue, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 14461, 14528, null, null));
			if(item.type == 0/*Button*/) {
				if((item.image != null)) {
					graphics.drawImage(item.image, pos.plus(new Vector2(-120, 0.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 14594, 14600, null, null))), new Vector2(0.0, 0.0, null), null, 0, int.maxValue, 1.0, Color.White, 1/*Center*/, 1/*Middle*/, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 14572, 14620, null, null));
				}
				input.onTouchDown(pos, new Vector2(500, 60, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 14648, 14656, null, null)), null, "auto", false, true, 1/*Center*/, 1/*Middle*/, touch => {
					item.onClick?.invoke(true, touch);
				});
			} else {
				if(item.type == 1/*Check*/) {
					graphics.drawImage(item.image || $Image.Checkbox, pos.plus(new Vector2(-120, 0.0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 14761, 14767, null, null))), new Vector2(0.0, 0.0, null), null, (item.value ? 1 : 0), int.maxValue, 1.0, Color.White, 1/*Center*/, 1/*Middle*/, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 14727, 14813, null, null));
					input.onTouchDown(pos, new Vector2(500, 60, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 14841, 14849, null, null)), null, "auto", false, true, 1/*Center*/, 1/*Middle*/, touch => {
						item.value = !item.value;
						item.onClick?.invoke(item.value, touch);
						doNotClose = true;
					});
				}
			}
		}}
		graphics.drawRectangle(this.popupPosition, new Vector2(500, 60 + this.items.length * 60, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 15019, 15043, null, null)), Color.Black, Color.White, 3, null, int.maxValue, 1.0, 1/*Center*/, 1/*Middle*/, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 14952, 15079, null, null));
		graphics.drawRectangle(new Vector2(0.0, 0.0, null), new Vector2(1920, 1080, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 15102, 15113, null, null)), this.overlayColor, null, 0, null, int.maxValue, 1.0, 1/*Center*/, 1/*Middle*/, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/lib/core/2D/objects.l", 15083, 15153, null, null));
		if(!doNotClose) {
			input.onTouchDownAny(null, touch => {
				this.active = false;
			});
		}
	}
	if(this.alpha && !awardScreen.active) {
		graphics.drawImage5($Image.Menu, this.position, new Vector2(0.0, 0.0, null), null, null, 0, this.layer, 1.0, Color.White, 0.0, false, false, new Vector2(16, 16, null), false, 0/*None*/, touch => {
			this.active = true;
		}, this.location);
	}
}
Menu.prototype.clone = function() {
	let clone = new _Menu();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.angle = this.angle;
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.popupPosition = this.popupPosition.clone();
	clone.items = this.items;
	clone.includeDefaultItems = this.includeDefaultItems;
	clone.overlayColor = this.overlayColor;
	clone.active = this.active;
	return clone;
}
function _Menu() {};
_Menu.prototype = Menu.prototype;
Menu.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	(this.popupPosition || new _Vector2()).serialize_internal(buffer);
	let items = this.items
	if(items) {
		var index = _objectCacheIndex.get(items);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(items, index = _objectCache.length);
			_objectCache.push(items);
			buffer.writeInt32(-index);
			items._objectIndex = index;
			buffer.writeInt32(items.length);
			for(let i=0, len=items.length; i<len; ++i) {
				let items_item = items[i]
				if(items_item) {
					var index = _objectCacheIndex.get(items_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(items_item, index = _objectCache.length);
						_objectCache.push(items_item);
						buffer.writeInt32(-index);
						items_item._objectIndex = index;
						items_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeBool(this.includeDefaultItems);
	let overlayColor = this.overlayColor
	if(overlayColor) {
		var index = _objectCacheIndex.get(overlayColor);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(overlayColor, index = _objectCache.length);
			_objectCache.push(overlayColor);
			buffer.writeInt32(-index);
			overlayColor._objectIndex = index;
			overlayColor.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeBool(this.active);
}
Menu.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	(this.popupPosition || (this.popupPosition = new _Vector2())).deserialize_internal(buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.items = _objectCache[index];
	} else {
		let items = this.items
		if(!items || items._objectIndex != -index) this.items = items = [];
		_objectCache[-index] = items;
		for(let i=0, len = items.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					items[i] = _objectCache[index];
				} else {
					let items_item = items[i]
					if(!items_item || items_item._objectIndex != -index)
						items[i] = items_item = new _MenuItem();
					(_objectCache[-index] = items_item).deserialize_internal(buffer);
				}
		}
	}
	this.includeDefaultItems = buffer.readBool();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.overlayColor = _objectCache[index];
	} else {
		let overlayColor = this.overlayColor
		if(!overlayColor || overlayColor._objectIndex != -index)
			this.overlayColor = overlayColor = new _Color();
		(_objectCache[-index] = overlayColor).deserialize_internal(buffer);
	}
	this.active = buffer.readBool();
}
Menu.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("popupPosition");
	let popupPosition_startPos = buffer.reserveSize();
	(this.popupPosition || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(popupPosition_startPos);
	buffer.writeString("items");
	let items = this.items
	let items_startPos = buffer.reserveSize();
	if(items) {
		var index = _objectCacheIndex.get(items);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(items, index = _objectCache.length);
			_objectCache.push(items);
			buffer.writeInt32(-index);
			items._objectIndex = index;
			buffer.writeInt32(items.length);
			for(let i=0, len=items.length; i<len; ++i) {
				let items_item = items[i]
				if(items_item) {
					var index = _objectCacheIndex.get(items_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(items_item, index = _objectCache.length);
						_objectCache.push(items_item);
						buffer.writeInt32(-index);
						items_item._objectIndex = index;
						items_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(items_startPos);
	buffer.writeString("includeDefaultItems");
	buffer.writeInt32(1);
	buffer.writeBool(this.includeDefaultItems);
	buffer.writeString("overlayColor");
	let overlayColor_startPos = buffer.reserveSize();
	let overlayColor = this.overlayColor
	if(overlayColor) {
		var index = _objectCacheIndex.get(overlayColor);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(overlayColor, index = _objectCache.length);
			_objectCache.push(overlayColor);
			buffer.writeInt32(-index);
			overlayColor._objectIndex = index;
			overlayColor.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(overlayColor_startPos);
	buffer.writeString("active");
	buffer.writeInt32(1);
	buffer.writeBool(this.active);
	buffer.writeString("");
}
Menu.prototype.deserialize_external = function(buffer) {
	let popupPosition_is_set = false, items_is_set = false, includeDefaultItems_is_set = false, overlayColor_is_set = false, active_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "popupPosition":
				buffer.readInt32();
				(this.popupPosition || (this.popupPosition = new _Vector2())).deserialize_external(buffer);
				popupPosition_is_set = true;
				break;
			case "items":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.items = _objectCache[index];
				} else {
					let items = this.items
					if(!items || items._objectIndex != -index) this.items = items = [];
					_objectCache[-index] = items;
					for(let i=0, len = items.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								items[i] = _objectCache[index];
							} else {
								let items_item = items[i]
								if(!items_item || items_item._objectIndex != -index)
									items[i] = items_item = new _MenuItem();
								(_objectCache[-index] = items_item).deserialize_external(buffer);
							}
					}
				}
				items_is_set = true;
				break;
			case "includeDefaultItems":
				buffer.readInt32();
				this.includeDefaultItems = buffer.readBool();
				includeDefaultItems_is_set = true;
				break;
			case "overlayColor":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.overlayColor = _objectCache[index];
				} else {
					let overlayColor = this.overlayColor
					if(!overlayColor || overlayColor._objectIndex != -index)
						this.overlayColor = overlayColor = new _Color();
					(_objectCache[-index] = overlayColor).deserialize_external(buffer);
				}
				overlayColor_is_set = true;
				break;
			case "active":
				buffer.readInt32();
				this.active = buffer.readBool();
				active_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!popupPosition_is_set) this.popupPosition = new Vector2(0.0, 0.0, null);
				if(!items_is_set) this.items = [];
				if(!includeDefaultItems_is_set) this.includeDefaultItems = true;
				if(!overlayColor_is_set) this.overlayColor = new Color("#000000b0");
				if(!active_is_set) this.active = false;
				return;
		}
	}
}
function Lambda26(_this) {
	this._id = 26;
	this._this = _this;
}
Lambda26.prototype.invoke = function(data) {
	this._this.value = data;
	if(!core.isPremiere) {
		this._this.element.value = data;
	}
}
Lambda26.prototype.serialize_internal = function(buffer) {
	let _this = this._this
	if(_this) {
		var index = _objectCacheIndex.get(_this);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_this, index = _objectCache.length);
			_objectCache.push(_this);
			buffer.writeInt32(-index);
			buffer.writeString(_this.type);
			_this._objectIndex = index;
			_this.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
Lambda26.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this._this = _objectCache[index];
	} else {
		let _this = this._this
		let type = buffer.readString();
		if(!_this || _this._objectIndex != -index)
			this._this = _this = new_HTMLElement_of_type(type);
		_this.type = type;
		(_objectCache[-index] = _this).deserialize_internal(buffer);
	}
}
Lambda26.prototype.serialize_external = function(buffer) {
	buffer.writeString("_this");
	let _this_startPos = buffer.reserveSize();
	let _this = this._this
	if(_this) {
		var index = _objectCacheIndex.get(_this);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_this, index = _objectCache.length);
			_objectCache.push(_this);
			buffer.writeInt32(-index);
			buffer.writeString(_this.type);
			_this._objectIndex = index;
			_this.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_this_startPos);
	buffer.writeString("");
}
Lambda26.prototype.deserialize_external = function(buffer) {
	let _this_is_set = false;
	for(;;) {
		switch(buffer.readString()) {
			case "_this":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this._this = _objectCache[index];
				} else {
					let _this = this._this
					let type = buffer.readString();
					if(!_this || _this._objectIndex != -index)
						this._this = _this = new_HTMLElement_of_type(type);
					_this.type = type;
					(_objectCache[-index] = _this).deserialize_external(buffer);
				}
				_this_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				if(!_this_is_set) this._this = null;
				return;
		}
	}
}
function _Lambda26() {
	this._id = 26;
};
_Lambda26.prototype = Lambda26.prototype;
function Lambda27(_this) {
	this._id = 27;
	this._this = _this;
}
Lambda27.prototype.invoke = function(data) {
	this._this.value = data;
	this._this.onEnterKey?.invoke(data);
}
Lambda27.prototype.serialize_internal = function(buffer) {
	let _this = this._this
	if(_this) {
		var index = _objectCacheIndex.get(_this);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_this, index = _objectCache.length);
			_objectCache.push(_this);
			buffer.writeInt32(-index);
			buffer.writeString(_this.type);
			_this._objectIndex = index;
			_this.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
Lambda27.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this._this = _objectCache[index];
	} else {
		let _this = this._this
		let type = buffer.readString();
		if(!_this || _this._objectIndex != -index)
			this._this = _this = new_HTMLElement_of_type(type);
		_this.type = type;
		(_objectCache[-index] = _this).deserialize_internal(buffer);
	}
}
Lambda27.prototype.serialize_external = function(buffer) {
	buffer.writeString("_this");
	let _this_startPos = buffer.reserveSize();
	let _this = this._this
	if(_this) {
		var index = _objectCacheIndex.get(_this);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_this, index = _objectCache.length);
			_objectCache.push(_this);
			buffer.writeInt32(-index);
			buffer.writeString(_this.type);
			_this._objectIndex = index;
			_this.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_this_startPos);
	buffer.writeString("");
}
Lambda27.prototype.deserialize_external = function(buffer) {
	let _this_is_set = false;
	for(;;) {
		switch(buffer.readString()) {
			case "_this":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this._this = _objectCache[index];
				} else {
					let _this = this._this
					let type = buffer.readString();
					if(!_this || _this._objectIndex != -index)
						this._this = _this = new_HTMLElement_of_type(type);
					_this.type = type;
					(_objectCache[-index] = _this).deserialize_external(buffer);
				}
				_this_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				if(!_this_is_set) this._this = null;
				return;
		}
	}
}
function _Lambda27() {
	this._id = 27;
};
_Lambda27.prototype = Lambda27.prototype;
function HTMLInput(position, size, color, fontSize, borderColor, align, onEnterKey) {
	HTMLElement.call(this, position, size, color);
	this.type = "HTMLInput";
	this.fontSize = fontSize;
	this.borderColor = borderColor;
	this.align = align;
	this.value = "";
	this.onEnterKey = onEnterKey;
	this.changeCallbackId = 0;
	this.enterCallbackId = 0;
	this.changeCallbackId = networkData.addCallback(new Lambda26(this));
	this.enterCallbackId = networkData.addCallback(new Lambda27(this));
	this.ensureElement();
	this.focus();
}
function __HTMLInputPrototype() { this.constructor = HTMLInput; }
__HTMLInputPrototype.prototype = HTMLElement.prototype;
HTMLInput.prototype = new __HTMLInputPrototype();
HTMLInput.prototype.ensureElement = function() {
	if(this.element) return
	let alignString = this.align == 0 ? "left" : this.align == 1 ? "center" : "right";
	this.element = document.createElement("input")
	this.element.type = "text"
	this.element.style = "margin:0;padding:0 12px 0 12px;position:absolute;border:1px solid "+this.borderColor.hex+";text-align:"+alignString+";outline:none;background-color:#00000000"
	this.element.value = this.value
	let prevValue = this.value
	this.element.onkeyup = e => {
		let value = this.element.value
		if(value != prevValue) {
			input.handleString(this.changeCallbackId, value);
			prevValue = value;
		}
		if(e.keyCode == 13) {
			input.handleString(this.enterCallbackId, value);
		}
	}
	document.body.appendChild(this.element)
}
HTMLInput.prototype.remove = function() {
	this.element?.remove()
}
HTMLInput.prototype.focus = function() {
	this.element?.focus()
}
HTMLInput.prototype.tick = function() {
	HTMLElement.prototype.tick.call(this);
}
HTMLInput.prototype.clone = function() {
	let clone = new _HTMLInput();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.color = this.color;
	clone.element = this.element;
	clone.fontSize = this.fontSize;
	clone.borderColor = this.borderColor;
	clone.align = this.align;
	clone.value = this.value;
	clone.onEnterKey = this.onEnterKey;
	clone.changeCallbackId = this.changeCallbackId;
	clone.enterCallbackId = this.enterCallbackId;
	return clone;
}
function _HTMLInput() {};
_HTMLInput.prototype = HTMLInput.prototype;
HTMLInput.prototype.serialize_internal = function(buffer) {
	HTMLElement.prototype.serialize_internal.call(this, buffer);
	buffer.writeInt32(this.fontSize);
	let borderColor = this.borderColor
	if(borderColor) {
		var index = _objectCacheIndex.get(borderColor);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(borderColor, index = _objectCache.length);
			_objectCache.push(borderColor);
			buffer.writeInt32(-index);
			borderColor._objectIndex = index;
			borderColor.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.align);
	buffer.writeString(this.value);
	let onEnterKey = this.onEnterKey
	if(onEnterKey) {
		var index = _objectCacheIndex.get(onEnterKey);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(onEnterKey, index = _objectCache.length);
			_objectCache.push(onEnterKey);
			buffer.writeInt32(-index);
			buffer.writeInt32(onEnterKey._id);
			onEnterKey._objectIndex = index;
			onEnterKey.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.changeCallbackId);
	buffer.writeInt32(this.enterCallbackId);
}
HTMLInput.prototype.deserialize_internal = function(buffer) {
	HTMLElement.prototype.deserialize_internal.call(this, buffer);
	this.fontSize = buffer.readInt32();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.borderColor = _objectCache[index];
	} else {
		let borderColor = this.borderColor
		if(!borderColor || borderColor._objectIndex != -index)
			this.borderColor = borderColor = new _Color();
		(_objectCache[-index] = borderColor).deserialize_internal(buffer);
	}
	this.align = buffer.readInt32();
	this.value = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.onEnterKey = _objectCache[index];
	} else {
		let onEnterKey = this.onEnterKey
		let _id = buffer.readInt32();
		if(!onEnterKey || onEnterKey._id != _id || onEnterKey._objectIndex != -index)
			this.onEnterKey = onEnterKey = new _lambdaContructors[_id]();
		onEnterKey._id = _id;
		(_objectCache[-index] = onEnterKey).deserialize_internal(buffer);
	}
	this.changeCallbackId = buffer.readInt32();
	this.enterCallbackId = buffer.readInt32();
}
HTMLInput.prototype.serialize_external = function(buffer) {
	HTMLElement.prototype.serialize_external.call(this, buffer);
	buffer.writeString("fontSize");
	buffer.writeInt32(4);
	buffer.writeInt32(this.fontSize);
	buffer.writeString("borderColor");
	let borderColor_startPos = buffer.reserveSize();
	let borderColor = this.borderColor
	if(borderColor) {
		var index = _objectCacheIndex.get(borderColor);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(borderColor, index = _objectCache.length);
			_objectCache.push(borderColor);
			buffer.writeInt32(-index);
			borderColor._objectIndex = index;
			borderColor.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(borderColor_startPos);
	buffer.writeString("align");
	buffer.writeInt32(4);
	buffer.writeInt32(this.align);
	buffer.writeString("value");
	buffer.writeString(this.value);
	buffer.writeString("onEnterKey");
	let onEnterKey_startPos = buffer.reserveSize();
	let onEnterKey = this.onEnterKey
	if(onEnterKey) {
		var index = _objectCacheIndex.get(onEnterKey);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(onEnterKey, index = _objectCache.length);
			_objectCache.push(onEnterKey);
			buffer.writeInt32(-index);
			buffer.writeInt32(onEnterKey._id);
			onEnterKey._objectIndex = index;
			onEnterKey.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(onEnterKey_startPos);
	buffer.writeString("changeCallbackId");
	buffer.writeInt32(4);
	buffer.writeInt32(this.changeCallbackId);
	buffer.writeString("enterCallbackId");
	buffer.writeInt32(4);
	buffer.writeInt32(this.enterCallbackId);
	buffer.writeString("");
}
HTMLInput.prototype.deserialize_external = function(buffer) {
	let fontSize_is_set = false, borderColor_is_set = false, align_is_set = false, value_is_set = false, onEnterKey_is_set = false, changeCallbackId_is_set = false, enterCallbackId_is_set = false;
	HTMLElement.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "fontSize":
				buffer.readInt32();
				this.fontSize = buffer.readInt32();
				fontSize_is_set = true;
				break;
			case "borderColor":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.borderColor = _objectCache[index];
				} else {
					let borderColor = this.borderColor
					if(!borderColor || borderColor._objectIndex != -index)
						this.borderColor = borderColor = new _Color();
					(_objectCache[-index] = borderColor).deserialize_external(buffer);
				}
				borderColor_is_set = true;
				break;
			case "align":
				buffer.readInt32();
				this.align = buffer.readInt32();
				align_is_set = true;
				break;
			case "value":
				this.value = buffer.readString();
				value_is_set = true;
				break;
			case "onEnterKey":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.onEnterKey = _objectCache[index];
				} else {
					let onEnterKey = this.onEnterKey
					let _id = buffer.readInt32();
					if(!onEnterKey || onEnterKey._id != _id || onEnterKey._objectIndex != -index)
						this.onEnterKey = onEnterKey = new _lambdaContructors[_id]();
					onEnterKey._id = _id;
					(_objectCache[-index] = onEnterKey).deserialize_external(buffer);
				}
				onEnterKey_is_set = true;
				break;
			case "changeCallbackId":
				buffer.readInt32();
				this.changeCallbackId = buffer.readInt32();
				changeCallbackId_is_set = true;
				break;
			case "enterCallbackId":
				buffer.readInt32();
				this.enterCallbackId = buffer.readInt32();
				enterCallbackId_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!fontSize_is_set) this.fontSize = 50;
				if(!borderColor_is_set) this.borderColor = new Color("ffffff00", "");
				if(!align_is_set) this.align = 1/*Center*/;
				if(!value_is_set) this.value = "";
				if(!onEnterKey_is_set) this.onEnterKey = null;
				if(!changeCallbackId_is_set) this.changeCallbackId = 0;
				if(!enterCallbackId_is_set) this.enterCallbackId = 0;
				return;
		}
	}
}
var app; if(!app) app = {};
app.init = function() {
	app.birdPos = new Vector2(10, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/app.l", 23, 29, null, null));
	app.birdSpeed = new Vector2(10, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/app.l", 43, 50, null, null));
	Platform.isLocal = true;
}
app.tick = function() {
	graphics.drawText("Hello World", new Vector2(0, 100, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/app.l", 117, 124, null, null)), new Vector2(0.0, 0.0, null), null, 1/*Center*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, 0, 1.0, 0.0, null, null, new Vector2(16, 16, null), false, 0/*None*/, 2/*Scale*/, 0, 0, null, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/app.l", 93, 124, null, null));
	graphics.drawImage($Image.Bird, app.birdPos, new Vector2(0.0, 0.0, null), null, 0, 0, 1.0, Color.White, 1/*Center*/, 1/*Middle*/, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/app.l", 127, 150, null, null));
	graphics.drawImage($Image.Background, new Vector2(0.0, 0.0, null), new Vector2(0.0, 0.0, null), null, 0, 0, 1.0, Color.White, 1/*Center*/, 1/*Middle*/, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/app.l", 153, 173, null, null));
	app.birdPos.plusAssign(app.birdSpeed);
	app.birdSpeed.y += 2;
	input.onTouchDown5(null, true, touch => {
		app.birdSpeed.y = -10;
	});
}
app.main01 = function() {
	System.print("main01", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/app.l", 261, 275, null, null));
}
app.main02 = function() {
	System.print("main02", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/app.l", 287, 301, null, null));
}
app.main03 = function() {
	System.print("main03", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/app.l", 313, 327, null, null));
}
app.gameOver = function() {
	System.print("gameOver", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/app.l", 341, 357, null, null));
}
app.flyOver01 = function() {
	System.print("flyOver01", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/app.l", 372, 389, null, null));
}
app.flyOver02 = function() {
	System.print("flyOver02", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/app.l", 404, 421, null, null));
}
app.flyOver03 = function() {
	System.print("flyOver03", new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/app.l", 436, 453, null, null));
}
function app_serialize_internal(buffer) {
	(app.birdPos || new _Vector2()).serialize_internal(buffer);
	(app.birdSpeed || new _Vector2()).serialize_internal(buffer);
}
function app_deserialize_internal(buffer) {
	(app.birdPos || (app.birdPos = new _Vector2())).deserialize_internal(buffer);
	(app.birdSpeed || (app.birdSpeed = new _Vector2())).deserialize_internal(buffer);
}
function app_serialize_external(buffer) {
	buffer.writeString("birdPos");
	let _birdPos_startPos = buffer.reserveSize();
	(app.birdPos || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(_birdPos_startPos);
	buffer.writeString("birdSpeed");
	let _birdSpeed_startPos = buffer.reserveSize();
	(app.birdSpeed || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(_birdSpeed_startPos);
	buffer.writeString("");
}
function app_deserialize_external(buffer) {
	let birdPos_is_set = false, birdSpeed_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "birdPos":
				buffer.readInt32();
				(app.birdPos || (app.birdPos = new _Vector2())).deserialize_external(buffer);
				birdPos_is_set = true;
				break;
			case "birdSpeed":
				buffer.readInt32();
				(app.birdSpeed || (app.birdSpeed = new _Vector2())).deserialize_external(buffer);
				birdSpeed_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!birdPos_is_set) app.birdPos = new Vector2(10, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/app.l", 23, 29, null, null));
				if(!birdSpeed_is_set) app.birdSpeed = new Vector2(10, 0, new SourceCodeLocation("vscode-vfs://github/up4playing/playground/src/app.l", 43, 50, null, null));
				return;
		}
	}
}
var _constCache = [null]
var _objectCache = []
var _objectCacheIndex = new Map();
var _lambdaContructors = [_Lambda0, _Lambda1, _Lambda2, _Lambda3, _Lambda4, _Lambda5, _Lambda6, _Lambda7, _Lambda8, _Lambda9, _Lambda10, _Lambda11, _Lambda12, _Lambda13, _Lambda14, _Lambda15, _Lambda16, _Lambda17, _Lambda18, _Lambda19, _Lambda20, _Lambda21, _Lambda22, _Lambda23, _Lambda24, _Lambda25, _Lambda26, _Lambda27];
function setup_serialize() {
	_objectCache.length = 0;
	_objectCache.push(..._constCache);
	_objectCacheIndex.clear();
	for(let i=1, len=_constCache.length; i<len; ++i)
		_objectCacheIndex.set(_constCache[i], i);
}
function setup_deserialize() {
	_objectCache.length = 0;
	_objectCache.push(..._constCache);
}
function serialize_internal(buffer) {
	setup_serialize();
	buffer.reset();
	Image_serialize_internal(buffer);
	Font_serialize_internal(buffer);
	math_serialize_internal(buffer);
	Loca_serialize_internal(buffer);
	fx_serialize_internal(buffer);
	Color_serialize_internal(buffer);
	Direction_serialize_internal(buffer);
	awardScreen_serialize_internal(buffer);
	EaseFunction_serialize_internal(buffer);
	lobby_serialize_internal(buffer);
	Framework_serialize_internal(buffer);
	networkVisualizer_serialize_internal(buffer);
	HTMLElement_serialize_internal(buffer);
	algorithms_serialize_internal(buffer);
	input_serialize_internal(buffer);
	networkData_serialize_internal(buffer);
	app_serialize_internal(buffer);
}
function deserialize_internal(buffer) {
	setup_deserialize();
	buffer.readPos = 0;
	Image_deserialize_internal(buffer);
	Font_deserialize_internal(buffer);
	math_deserialize_internal(buffer);
	Loca_deserialize_internal(buffer);
	fx_deserialize_internal(buffer);
	Color_deserialize_internal(buffer);
	Direction_deserialize_internal(buffer);
	awardScreen_deserialize_internal(buffer);
	EaseFunction_deserialize_internal(buffer);
	lobby_deserialize_internal(buffer);
	Framework_deserialize_internal(buffer);
	networkVisualizer_deserialize_internal(buffer);
	HTMLElement_deserialize_internal(buffer);
	algorithms_deserialize_internal(buffer);
	input_deserialize_internal(buffer);
	networkData_deserialize_internal(buffer);
	app_deserialize_internal(buffer);
}
function serialize_external(buffer) {
	setup_serialize();
	buffer.reset();
	buffer.writeString("Image");
	var Image_startPos = buffer.reserveSize();
	Image_serialize_external(buffer);
	buffer.writeSize(Image_startPos);
	buffer.writeString("Font");
	var Font_startPos = buffer.reserveSize();
	Font_serialize_external(buffer);
	buffer.writeSize(Font_startPos);
	buffer.writeString("math");
	var math_startPos = buffer.reserveSize();
	math_serialize_external(buffer);
	buffer.writeSize(math_startPos);
	buffer.writeString("Loca");
	var Loca_startPos = buffer.reserveSize();
	Loca_serialize_external(buffer);
	buffer.writeSize(Loca_startPos);
	buffer.writeString("fx");
	var fx_startPos = buffer.reserveSize();
	fx_serialize_external(buffer);
	buffer.writeSize(fx_startPos);
	buffer.writeString("Color");
	var Color_startPos = buffer.reserveSize();
	Color_serialize_external(buffer);
	buffer.writeSize(Color_startPos);
	buffer.writeString("Direction");
	var Direction_startPos = buffer.reserveSize();
	Direction_serialize_external(buffer);
	buffer.writeSize(Direction_startPos);
	buffer.writeString("awardScreen");
	var awardScreen_startPos = buffer.reserveSize();
	awardScreen_serialize_external(buffer);
	buffer.writeSize(awardScreen_startPos);
	buffer.writeString("EaseFunction");
	var EaseFunction_startPos = buffer.reserveSize();
	EaseFunction_serialize_external(buffer);
	buffer.writeSize(EaseFunction_startPos);
	buffer.writeString("lobby");
	var lobby_startPos = buffer.reserveSize();
	lobby_serialize_external(buffer);
	buffer.writeSize(lobby_startPos);
	buffer.writeString("Framework");
	var Framework_startPos = buffer.reserveSize();
	Framework_serialize_external(buffer);
	buffer.writeSize(Framework_startPos);
	buffer.writeString("networkVisualizer");
	var networkVisualizer_startPos = buffer.reserveSize();
	networkVisualizer_serialize_external(buffer);
	buffer.writeSize(networkVisualizer_startPos);
	buffer.writeString("HTMLElement");
	var HTMLElement_startPos = buffer.reserveSize();
	HTMLElement_serialize_external(buffer);
	buffer.writeSize(HTMLElement_startPos);
	buffer.writeString("algorithms");
	var algorithms_startPos = buffer.reserveSize();
	algorithms_serialize_external(buffer);
	buffer.writeSize(algorithms_startPos);
	buffer.writeString("input");
	var input_startPos = buffer.reserveSize();
	input_serialize_external(buffer);
	buffer.writeSize(input_startPos);
	buffer.writeString("networkData");
	var networkData_startPos = buffer.reserveSize();
	networkData_serialize_external(buffer);
	buffer.writeSize(networkData_startPos);
	buffer.writeString("app");
	var app_startPos = buffer.reserveSize();
	app_serialize_external(buffer);
	buffer.writeSize(app_startPos);
}
function deserialize_external(buffer) {
	setup_deserialize();
	buffer.readPos = 0;
	for(;;) {
		switch(buffer.readString()) {
			case "Image":
				buffer.readInt32();
				Image_deserialize_external(buffer);
				break;
			case "Font":
				buffer.readInt32();
				Font_deserialize_external(buffer);
				break;
			case "math":
				buffer.readInt32();
				math_deserialize_external(buffer);
				break;
			case "Loca":
				buffer.readInt32();
				Loca_deserialize_external(buffer);
				break;
			case "fx":
				buffer.readInt32();
				fx_deserialize_external(buffer);
				break;
			case "Color":
				buffer.readInt32();
				Color_deserialize_external(buffer);
				break;
			case "Direction":
				buffer.readInt32();
				Direction_deserialize_external(buffer);
				break;
			case "awardScreen":
				buffer.readInt32();
				awardScreen_deserialize_external(buffer);
				break;
			case "EaseFunction":
				buffer.readInt32();
				EaseFunction_deserialize_external(buffer);
				break;
			case "lobby":
				buffer.readInt32();
				lobby_deserialize_external(buffer);
				break;
			case "Framework":
				buffer.readInt32();
				Framework_deserialize_external(buffer);
				break;
			case "networkVisualizer":
				buffer.readInt32();
				networkVisualizer_deserialize_external(buffer);
				break;
			case "HTMLElement":
				buffer.readInt32();
				HTMLElement_deserialize_external(buffer);
				break;
			case "algorithms":
				buffer.readInt32();
				algorithms_deserialize_external(buffer);
				break;
			case "input":
				buffer.readInt32();
				input_deserialize_external(buffer);
				break;
			case "networkData":
				buffer.readInt32();
				networkData_deserialize_external(buffer);
				break;
			case "app":
				buffer.readInt32();
				app_deserialize_external(buffer);
				break;
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function init() {
	_constCache = [null];
	Array.init();
	Loca.init();
	Buffer.init();
	DateTime.init();
	Date.init();
	fx.init();
	Color.init();
	Direction.init();
	awardScreen.init();
	EaseFunction.init();
	lobby.init();
	Framework.init();
	networkVisualizer.init();
	HTMLElement.init();
	Snapshot.init();
	algorithms.init();
	PathfindingNode.init();
	networkData.init();
	Physics.init();
	speech.init();
	app.init();
}
